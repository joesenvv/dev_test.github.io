<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
  <title>Docker 学习 | wudaijun&#39;s blog | Coding is Funny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="docker">
  <meta name="description" content="一. 理解 DockerDocker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：

隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势
一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 学习">
<meta property="og:url" content="http://wudaijun.com/2016/11/docker-basic/index.html">
<meta property="og:site_name" content="wudaijun's blog">
<meta property="og:description" content="一. 理解 DockerDocker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：

隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势
一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，">
<meta property="og:updated_time" content="2016-11-17T08:43:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker 学习">
<meta name="twitter:description" content="一. 理解 DockerDocker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：

隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势
一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，">
  
    <link rel="alternative" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  
  <meta name="summary" content="&lt;h2 id=&quot;一-_理解_Docker&quot;&gt;一. 理解 Docker&lt;/h2&gt;&lt;p&gt;Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势&lt;/li&gt;
&lt;li&gt;一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。&lt;/li&gt;
&lt;/ul&gt;">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css?v=1.1.4">
</head>

<body>
  <div id="loading" class="active"></div>

  <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar"><img src="/favicon.png"></a>
        <hgroup class="introduce">
          <h5 class="nickname">wudaijun</h5>
          <a href="mailto:wdjlost@gmail.com" title="wdjlost@gmail.com" class="mail">wdjlost@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://blog.csdn.net/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-contao"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>

      <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>wudaijun&#39;s blog &copy; 2017</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

    </div>
  </div>
</aside>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Docker 学习</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container">
        <h1 class="title">Docker 学习</h1>
        
        

    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一-_理解_Docker"><span class="post-toc-text">一. 理解 Docker</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二-_Docker_容器"><span class="post-toc-text">二. Docker 容器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-_容器操作"><span class="post-toc-text">1. 容器操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-_网络模式"><span class="post-toc-text">2. 网络模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三-_Docker_镜像"><span class="post-toc-text">三. Docker 镜像</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-_Dockerfile"><span class="post-toc-text">1. Dockerfile</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#FROM"><span class="post-toc-text">FROM</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RUN"><span class="post-toc-text">RUN</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CMD"><span class="post-toc-text">CMD</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ENTRYPOINT"><span class="post-toc-text">ENTRYPOINT</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其它命令"><span class="post-toc-text">其它命令</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-_docker_build_原理"><span class="post-toc-text">2. docker build 原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#docker_commit"><span class="post-toc-text">docker commit</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#build_cache"><span class="post-toc-text">build cache</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-_docker_build_示例"><span class="post-toc-text">3. docker build 示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四-_参考"><span class="post-toc-text">四. 参考</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-docker-basic" 
  class="post-article article-type-post" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Docker 学习</h1>
        <div class="post-meta">
            <time datetime="2016-10-31T16:00:00.000Z" itemprop="datePublished" class="post-time">
  2016-11-01
</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Tool/">Tool</a></li></ul>



        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="一-_理解_Docker">一. 理解 Docker</h2><p>Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：</p>
<ul>
<li>隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势</li>
<li>一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。</li>
</ul>
<a id="more"></a>
<p>Docker和其它虚拟机或容器技术相比，一是轻量，开销很小，二是发展迅速， 平台兼容性增长很快。虽然Docker的应用场景很多，但都是基于虚拟化和容器技术的这两种特性在特定问题下提出的解决方案。</p>
<p>下面来看看Docker的基本概念：</p>
<ol>
<li>Docker是C/S模式的，包括docker CLI和docker daemon两部分，它们之间通过RESTful API交互，Docker CLI就是我们用的docker命令</li>
<li>镜像(Image)：是一个只读的模板，包含了系统和运行程序，是用于创建容器的一系列指令(Dockfile)，相当于一份虚拟机的磁盘文件。</li>
<li>容器(Container)：当镜像启动后就转化为容器，容器是运行着的镜像，在容器内的修改不会影响镜像，程序的写入操作都保存在容器中。容器可被启动，停止和删除，由docker daemon管理。</li>
<li>仓库(Registry)：Docker镜像可通过公有和私有的仓库来进行共享和分发，仓库是存放和分享镜像文件的场所，功能类似于Github。Docker仓库有免费的<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>和付费的<a href="https://store.docker.com/" target="_blank" rel="external">Docker Store</a>。</li>
</ol>
<h2 id="二-_Docker_容器">二. Docker 容器</h2><h3 id="1-_容器操作">1. 容器操作</h3><p>通常我们都使用docker CLI和docker daemon交互完成docker操作，随着docker日渐完善，docker所提供的功能和参数也更复杂，以下只列举几个常用的。</p>
<pre><code>docker run <span class="string">[OPTIONS]</span> IMAGE <span class="string">[COMMAND]</span> <span class="string">[ARG...]</span>
</code></pre><p>从镜像中创建并启动容器，常用Options有：</p>
<ul>
<li><code>-d</code>：后台运行</li>
<li><code>-t</code>：为容器分配一个伪终端，通常于-i一起使用</li>
<li><code>-i</code>：以交互模式运行容器，如果开了-i而没有指定-t，可以通过管道与容器交互</li>
<li><code>-v</code>：为容器挂载目录，冒号前为宿主机目录，其后为容器目录</li>
<li><code>-p</code>： [hip:]hport:cport 端口映射，将容器端口绑定到指定主机端口</li>
<li><code>--name</code>：为容器命名</li>
<li><code>--link</code>：链接到其它容器，之后可通过容器ID或容器名访问该容器(只针对bridge)</li>
<li><code>--ip</code>：指定容器的IP</li>
<li><code>--network</code>：配置容器的网络</li>
<li><code>--rm</code>：当容器退出时，删除容器</li>
</ul>
<p>完整的命令可通过<code>docker run --help</code>查看。</p>
<p>例如：</p>
<pre><code>docker <span class="command">run</span> -<span class="keyword">it</span> ubuntu:<span class="number">14.04</span> /bin/bash 
</code></pre><p>我们就以<code>ubuntu:14:04</code>镜像启动了一个容器，并进入到bash交互模式。docker所做的事情为，先在本地查找ubuntu镜像，如果没有，将从<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>中拉取到本地，解析镜像文件，创建容器，并运行<code>/bin/bash</code>命令。</p>
<p>每个容器在创建时，docker daemon都会为其生成一个Container ID，容器在运行结束后，为<code>STOP</code>状态，可以通过Container ID或容器名字再次启动/停止或删除。可通过<code>docker ps</code>来查看容器状态。以下是其它常用的容器管理命令：</p>
<pre><code>// 查看容器， 默认只显示运行中的容器，-a选项可显示所有容器
docker ps <span class="comment">[OPTIONS]</span>
// 启动容器
docker start/stop <span class="comment">[OPTIONS]</span> <span class="keyword">CONTAINER</span> <span class="comment">[CONTAINER...]</span>
// 停止容器
docker rm <span class="keyword">CONTAINER</span>
// 把后台容器调到前端
docker attach <span class="comment">[OPTIONS]</span> <span class="keyword">CONTAINER</span>
// 查询容器的详细信息，也可用于镜像
docker inspect <span class="comment">[OPTIONS]</span> <span class="keyword">CONTAINER</span>/IMAGE
// 在容器内执行指定命令 如:  docker exec -it <span class="keyword">CONTAINER</span> bash
docker exec <span class="comment">[OPTIONS]</span> <span class="keyword">CONTAINER</span> COMMAND <span class="comment">[ARG...]</span>
也可使用第三方工具如nsenter来进入容器
</code></pre><h3 id="2-_网络模式">2. 网络模式</h3><p>以Docker为平台部署服务器时，最应该理解透彻的便是网络配置，因此单独拿出来说一下。</p>
<p>通过<code>docker run</code>的<code>--network</code>选项可配置容器的网络模式，Docker提供了多种网络工作模式：</p>
<ul>
<li>none 模式(<code>--network none</code>)：不为Docker容器进行任何网络配置，容器将不能访问任何外部的路由(容器内部仍然有loopback接口)，与外部只能通过文件IO和标准输入输出交互。</li>
<li>bridge 模式(<code>--netwok bridge</code>)：默认设置，此模式下，容器有自己的独立的Network Namespace。bridge模式的详细实现可参考<a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part7" target="_blank" rel="external">Docker源码分析(七)：Docker Container网络(上)</a>，简单来说，Docker在宿主机上虚拟了一个子网络，宿主机上所有容器均在这个子网络中获取IP，这个子网通过网桥挂在宿主机网络上。Docker通过NAT技术确保容器可与宿主机外部网络交互。</li>
<li>host 模式(<code>--network host</code>)：与宿主机共用网络栈，IP和端口，容器本身看起来就像是个普通的进程，它暴露的端口可直接通过宿主机访问。相比于bridge模式，host模式有显著的性能优势(因为走的是宿主机的网络栈，而不是docker deamon为容器虚拟的网络栈)。</li>
<li>container 模式(<code>--network container:&lt;name|id&gt;</code>)：和host模式类似，新创建的容器将与已经存在的一个容器共享IP，端口和网络栈。两个容器之间可通过localhost进行通信。</li>
</ul>
<p>这里再提一下bridge模式，在bridge模式下，一个宿主机上的所有容器都在一个子网中(通常是<code>172.17.0.1/16</code>)，同一个宿主机上的容器之间，以及容器与宿主机之间可以直接通过IP交互。而对于宿主机之外的网络：</p>
<ul>
<li>容器访问外部网络时，会在宿主机上分配一个可用端口，通过这个端口做SNAT转换(将容器IP:Port换为宿主机IP:Port)，再向外部网络发出请求。当外部响应到达时，Docker再根据这一层端口映射关系，将响应路由给容器IP:Port</li>
<li>外部网络要访问容器Port0，需要先将Port0与宿主机Port1绑定(外部网络无法直接访问宿主机二级网络)，将宿主机IP:Port1暴露给外部网络，外部网络请求到达宿主机时，会进行DNAT转换(将宿主机IP:Port1换为容器IP:Port0)</li>
</ul>
<p>归根结底，Docker容器在bridge模式下不具有一个公有IP，即和宿主机的eth0不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。虽然NAT模式经过中间处理实现了这一点，但是NAT模式仍然存在问题与不便，如：容器均需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等。另外NAT模式会一定程度的影响网络传输效率。</p>
<p>其它容器网络配置选项参见<code>docker run --help</code>以及<a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="external">Docker run Reference</a>。</p>
<h2 id="三-_Docker_镜像">三. Docker 镜像</h2><h3 id="1-_Dockerfile">1. Dockerfile</h3><p>Docker的镜像通过一个Dockerfile构建，我们可以通过编Dockerfile来创建自定义镜像：</p>
<pre><code><span class="comment"># 这是注释</span>
<span class="title">INSTRUCTION</span> args
</code></pre><p>Dockerfile不区分大小写，但惯例是将指令大写，下面介绍几个Dockerfile中常用的指令：</p>
<h4 id="FROM">FROM</h4><p>FROM命令必须是Dockerfile的第一条指令，用于指明基础镜像(镜像基础层)：</p>
<pre><code><span class="preprocessor"># 格式：FROM &lt;image&gt;[:&lt;tag&gt;]</span>
FROM ubuntu:<span class="number">14</span>:<span class="number">04</span>
FROM erlang
</code></pre><h4 id="RUN">RUN</h4><p>在当前镜像的顶层执行命令(比如安装一个软件包)，将执行结果commit到当前镜像层。</p>
<p>RUN有两种格式：</p>
<pre><code><span class="comment"># shell 格式，相当于 /bin/sh -c &lt;command&gt;</span>
<span class="comment"># 意味着可以访问shell环境变量 如$HOME</span>
<span class="built_in">RUN</span> <span class="bash">&lt;<span class="built_in">command</span>&gt;
</span><span class="comment"># exec 格式，推荐格式，直接执行命令，不会打开shell</span>
<span class="comment"># 这种格式更灵活，强大</span>
<span class="built_in">RUN</span> <span class="bash">[<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]
</span><span class="comment"># 以下两种写法完全等价</span>
<span class="built_in">RUN</span> <span class="bash"><span class="built_in">echo</span> <span class="string">"hello"</span>
</span><span class="built_in">RUN</span> <span class="bash">[<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo hello"</span>]</span>
</code></pre><h4 id="CMD">CMD</h4><p>CMD指令的主要目的是为容器提供默认值，这些默认值可以包含容器执行入口和参数，也可以只指定参数，这种情况下，容器入口由ENTRYPOINT指出。CMD有三种定义方式：</p>
<pre><code><span class="comment"># exec 格式 指定了执行入口和参数</span>
<span class="comment"># 可被docker run &lt;image&gt;后的参数覆盖</span>
<span class="built_in">CMD</span> <span class="bash">[<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>]
</span><span class="comment"># 当ENTRYPOINT存在时，exec格式退化为默认参数格式</span>
<span class="comment"># 此时CMD提供的参数将被附加到ENTRYPOINT指定的入口上</span>
<span class="comment"># 可被docker run &lt;image&gt;后的参数覆盖</span>
<span class="built_in">CMD</span> <span class="bash">[<span class="string">"param1"</span>, <span class="string">"param2"</span>]
</span><span class="comment"># shell 格式 这种格式不能为ENTRYPOINT提供默认参数  只能提供默认执行入口</span>
<span class="comment"># 会被ENTRYPOINT或docker run &lt;image&gt;指定的入口覆盖</span>
<span class="built_in">CMD</span> <span class="bash"><span class="built_in">command</span> param1 param2</span>
</code></pre><p>Dockerfile中只能有一个CMD命令(如果有多个，只有最后一个生效)，如果CMD要作为ENTRYPOINT的默认参数(即第二种定义方式)，那么CMD和ENTRYPOINT都必须以Json数组的方式指定。</p>
<p>CMD和RUN的区别：RUN在<code>docker build</code>构建镜像时执行，将执行结果写入新的镜像层(实际上也是通过容器写入的，详见后面<code>docker build</code>命令)，而CMD在<code>docker run</code>时执行，执行结果不会写入镜像。</p>
<h4 id="ENTRYPOINT">ENTRYPOINT</h4><p>ENTRYPOINT用于设置在容器启动时执行命令，ENTRYPOINT有两种定义方式：</p>
<pre><code><span class="comment"># exec格式 推荐格式</span>
<span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]
</span><span class="comment"># shell格式 以这种方式定义，CMD和docker run提供的参数均不能附加给command命令参数</span>
<span class="built_in">ENTRYPOINT</span> <span class="bash"><span class="built_in">command</span> param1 param2</span>
</code></pre><p><code>docker run &lt;image&gt;</code>后面的参数将会附加在ENTRYPOINT指定的入口上，如：</p>
<pre><code><span class="built_in">FROM</span> ubuntu:<span class="number">14.04</span>
ENTRYPOINT [<span class="string">"echo"</span>, <span class="string">"hello"</span>]
<span class="built_in">CMD</span> <span class="bash">[<span class="string">"world"</span>]</span>
</code></pre><p>构建镜像<code>docker build -t echo_img .</code>，之后如果我们以<code>docker run --rm echo_img</code>启动容器，CMD指定的默认参数将附加在ENTRYPOINT的入口上，因此相当于执行<code>echo hello world</code>。而如果我们以<code>docker run --rm echo_img wudaijun</code>启动容器，此时<code>docker run</code>提供的参数将覆盖CMD指定的默认参数，相当于执行<code>echo hello wudaijun</code>。</p>
<p>再举个例子：</p>
<pre><code>FROM ubuntu:<span class="number">14.04</span>
CMD [<span class="string">"echo"</span>, <span class="string">"hello"</span>]
</code></pre><p>由于没有指定ENTRYPOINT，因此CMD指定了默认的执行入口<code>echo hello</code>，如果<code>docker run &lt;image&gt;</code>未指定任何参数，则执行<code>echo hello</code>，否则<code>docker run &lt;image&gt;</code>的参数将覆盖CMD指定的执行入口。如果我们再加上Dockerfile中再加一行<code>ENTRYPOINT [&quot;echo&quot;]</code>，并且<code>docker run &lt;image&gt;</code>后未指定参数，那么将执行<code>echo echo hello</code>，输出<code>echo hello</code>。</p>
<p>和CMD一样，ENTRYPOINT在Dockerfile中最多只能生效一个，如果定义了多个，只有最后一个生效，在docker run中可通过<code>docker run --entrypoint</code>覆盖ENTRYPOINT。</p>
<p>CMD和ENTRYPOINT的区别：CMD和ENTRYPOINT都可用于设置容器执行入口，但CMD会被<code>docker run &lt;image&gt;</code>后的参数覆盖；而ENTRYPOINT会将其当成参数附加给其指定的命令（不会对命令覆盖）。另外CMD还可以单独作为ENTRYPOINT的所接命令的可选参数。如果容器是Execuatble的，通常用法是，用ENTRYPOINT定义不常变动的执行入口和参数(exec格式)，用CMD提供额外默认参数(exec格式)，再用<code>docker run &lt;image&gt;</code>提供的参数来覆盖CMD。另外，ENTRYPOINT指定的入口也可以是shell script，用于实现更灵活的容器交互。</p>
<p>ENTRYPOINT，CMD，RUN在定义时，均推荐使用Json数组方式。参见<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices" target="_blank" rel="external">Dockerfile Best Practices</a></p>
<h4 id="其它命令">其它命令</h4><pre><code><span class="attribute">ENV</span>: <span class="string">定义环境变量，该变量可被后续其它指令引用，并且在生成的容器中同样有效</span>
<span class="attribute">ADD</span>: <span class="string">src dst 将本地文件拷贝到镜像，src可以是文件路径或URL，ADD支持自动解压tar文件</span>
<span class="attribute">COPY</span>: <span class="string">和ADD类似，但不支持URL并且不能自动解压</span>
<span class="attribute">EXPOSE</span>: <span class="string">port, 指定容器在运行时监听的端口</span>
<span class="attribute">WORKDIR</span>: <span class="string">path, 指定容器的工作目录(启动之后的当前目录)</span>
<span class="attribute">VOLUME</span>: <span class="string">[path], 在容器中设置一个挂载点，用于挂载宿主机或其它容器的目录 </span>
</code></pre><p>关于Dockerfile的语法参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile Reference</a>。</p>
<h3 id="2-_docker_build_原理">2. docker build 原理</h3><p><code>docker build</code>的核心机制包括<code>docker commit</code>和<code>build cache</code>两部分。</p>
<h4 id="docker_commit">docker commit</h4><p>写好Dockerfile之后，通过<code>docker build</code>即可构建镜像：</p>
<pre><code>docker build -t 镜像名<span class="string">[:tag]</span>  Dockerfile所在目录或URL
</code></pre><p><code>docker build</code>将按照指令顺序来逐层构建镜像，每一条指令的执行结果将会commit为一个新的镜像层，并用于下一条指令。理解镜像层和commit的概念，是理解Docker镜像构建的关键。</p>
<p>镜像是被一层一层地”commit”上去的，而commit操作本身是由Docker容器执行的。<code>docker build</code>在执行一条指令时，会根据当前镜像层启动一个容器，Docker会在容器的层级文件系统最上层建立一层空的可读可写层(镜像层的内容对于容器来说是readonly的)，之后Docker容器执行指令，将执行结果写入可读可写层(并更新镜像Json文件)，最后再通过<code>docker commit</code>命令将可读可写层提交为一个新的镜像层。</p>
<p>Docker镜像层与镜像层之间是存在层级关系的，<code>docker build</code>会为Dockerfile每一条指令建立(commit)一个镜像层，并最终产生一个带标签(tag)的镜像，之前Dockerfile指令得到的镜像层(不会在构建完成后删除)是这个含标签镜像的祖先镜像。这样做的好处是最大化地复用镜像，不同的镜像之间可以共享镜像层，组成树形的镜像层级关系。</p>
<h4 id="build_cache">build cache</h4><p>在<code>docker build</code>过程中，如果发现本地有镜像与即将构建出来的镜像层一致时，则使用已有镜像作为Cache，充当本次构建的结果。从而加快build过程，并且避免构建重复的镜像。</p>
<p>那么docker是如何知道当前尚未构建的镜像的形态，并且与本地镜像进行比较呢？</p>
<p>Docker镜像由镜像文件系统内容和镜像Json文件两部分构成，前者即为<code>docker commit</code>提交的可读可写层，而镜像Json文件的作用为：</p>
<ul>
<li>记录镜像的父子关系，以及父子间的差异信息</li>
<li>弥补镜像本身以及镜像到容器转换所需的额外信息</li>
</ul>
<p>比如镜像Json文件中记录了当前镜像的父镜像，以及当前镜像与父镜像的差异(比如执行了哪条指令)，<code>docker build</code>则在这个基础上进行预测：</p>
<ul>
<li>判断已有镜像和目标镜像(当前正在构建的镜像)是父镜像ID是否相同</li>
<li>评估已有镜像的Json文件(如执行了那条命令，有何变动)，与目标镜像是否匹配</li>
</ul>
<p>如果条件满足，则可将已有镜像作为目标镜像的Cache，当然这种机制是并不完善的，比如当你执行的指令有外部动态依赖，此时可通过<code>docker build --no-cache</code>禁止使用Cache。</p>
<p>另外，基于build cache的机制，我们在写Dockerfile的时候，应该将静态安装，配置命令等尽可能放在Dockerfile前面，这样才能最大程度地利用cache，加快build过程。因为一旦Dockerfile前面有指令更新了并导致新的镜像层生成，那么该指令之后的镜像层cache也就完全失效了(树结构长辈节点更新了，子节点当然就不一样了)。</p>
<h3 id="3-_docker_build_示例">3. docker build 示例</h3><p>Dcokerfile:</p>
<pre><code>FROM ubuntu:14.04
# 创建一个100M的文件 /<span class="keyword">test</span>
<span class="keyword">RUN</span> dd <span class="keyword">if</span>=/dev/zero of=/<span class="keyword">test</span> <span class="keyword">bs</span>=1M <span class="keyword">count</span>=100
<span class="keyword">RUN</span> <span class="keyword">rm</span> /<span class="keyword">test</span>
<span class="keyword">RUN</span> dd <span class="keyword">if</span>=/dev/zero of=/<span class="keyword">test</span> <span class="keyword">bs</span>=1M <span class="keyword">count</span>=100
# 在根目录统计容器大小
ENTRYPOINT [<span class="string">"du"</span>, <span class="string">"-sh"</span>]
</code></pre><p>build镜像：</p>
<pre><code>▶ docker build . 
Sending build context to Docker daemon   <span class="number">599</span> kB
Step <span class="number">1</span> : FROM ubuntu:<span class="number">14.04</span>
 ---&gt; <span class="number">1e0</span>c3dd64ccd
Step <span class="number">2</span> : RUN dd <span class="keyword">if</span>=/dev/zero of=/test bs=<span class="number">1</span>M count=<span class="number">100</span>
 ---&gt; Running in d98f674c46f2
<span class="number">100</span>+<span class="number">0</span> records in
<span class="number">100</span>+<span class="number">0</span> records out
<span class="number">104857600</span> bytes (<span class="number">105</span> MB) copied, <span class="number">0.0980112</span> s, <span class="number">1.1</span> GB/s
 ---&gt; f3a606172d91
Removing intermediate container d98f674c46f2
Step <span class="number">3</span> : RUN rm /test
 ---&gt; Running in <span class="number">14544</span>c0dc6a0
 ---&gt; <span class="number">7</span>efc0655e95d
Removing intermediate container <span class="number">14544</span>c0dc6a0
Step <span class="number">4</span> : RUN dd <span class="keyword">if</span>=/dev/zero of=/test bs=<span class="number">1</span>M count=<span class="number">100</span>
 ---&gt; Running in <span class="number">387</span>be027ef2f
<span class="number">100</span>+<span class="number">0</span> records in
<span class="number">100</span>+<span class="number">0</span> records out
<span class="number">104857600</span> bytes (<span class="number">105</span> MB) copied, <span class="number">0.0852024</span> s, <span class="number">1.2</span> GB/s
 ---&gt; <span class="number">38e3</span>ea5c1412
Removing intermediate container <span class="number">387</span>be027ef2f
Step <span class="number">5</span> : ENTRYPOINT du -sh
 ---&gt; Running in e190adcbcce2
 ---&gt; baec9103f182
Removing intermediate container e190adcbcce2
Successfully built baec9103f182
</code></pre><p>可以看到build过程为不断基于当前镜像启动中间容器(如d98f674c46f2容器基于1e0c3dd64ccd镜像层执行指令<code>RUN dd if=/dev/zero of=/test bs=1M count=100</code>并提交f3a606172d91镜像层)。通过<code>docker history &lt;image&gt;</code>可查看镜像层级关系：</p>
<pre><code>docker history baec9103f182                                                                                
<span class="constant">IMAGE</span>               <span class="constant">CREATED</span>             <span class="constant">CREATED</span> <span class="constant">BY</span>                                      <span class="constant">SIZE</span>                <span class="constant">COMMENT</span>
baec9103f182        <span class="number">4</span> minutes ago       /bin/sh -c <span class="comment">#(nop)  ENTRYPOINT ["du" "-sh"]      0 B</span>
<span class="number">38e3</span>ea5c1412        <span class="number">4</span> minutes ago       /bin/sh -c dd <span class="keyword">if</span>=<span class="regexp">/dev/zero</span> <span class="keyword">of</span>=<span class="regexp">/test bs=1M cou   104.9 MB
7efc0655e95d        4 minutes ago       /bin</span><span class="regexp">/sh -c rm /test</span>                             <span class="number">0</span> <span class="constant">B</span>
f3a606172d91        <span class="number">4</span> minutes ago       /bin/sh -c dd <span class="keyword">if</span>=<span class="regexp">/dev/zero</span> <span class="keyword">of</span>=<span class="regexp">/test bs=1M cou   104.9 MB
1e0c3dd64ccd        3 weeks ago         /bin</span><span class="regexp">/sh -c #(nop)  CMD ["/bin</span><span class="regexp">/bash"]            0 B
&lt;missing&gt;           3 weeks ago         /bin</span><span class="regexp">/sh -c mkdir -p /run</span><span class="regexp">/systemd &amp;&amp; echo 'doc   7 B
&lt;missing&gt;           3 weeks ago         /bin</span><span class="regexp">/sh -c sed -i 's/</span>^<span class="comment">#\s*\(deb.*universe\)$/   1.895 kB</span>
&lt;missing&gt;           <span class="number">3</span> weeks ago         /bin/sh -c rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">apt</span>/<span class="title">lists</span>/*          0 <span class="title">B</span></span>
&lt;missing&gt;           <span class="number">3</span> weeks ago         /bin/sh -c set -xe   &amp;&amp; echo <span class="string">'#!/bin/sh'</span> &gt; <span class="regexp">/u   194.6 kB
&lt;missing&gt;           3 weeks ago         /bin</span><span class="regexp">/sh -c #(nop) ADD file:bc2e0eb31424a88aad   187.7 MB</span>
</code></pre><p>注意到其中一些镜像层的SIZE为0，这是因为该镜像层执行的命令不会影响到镜像的文件系统大小，这些命令会单独记录在镜像Json文件中。由于镜像的层级原理，Docker在执行<code>RUN rm /test</code>指令时，并没有真正将其当前镜像f3a606172d91中的/test文件真正删掉，而是将rm操作记录在镜像Json文件中(容器只能在其上层的可读写层进行更改操作)，最终我们得到的镜像大小约为400M。</p>
<p>然后我们基于得到镜像启动容器：</p>
<pre><code>docker run --rm baec9103f182
du: cannot access './<span class="keyword">proc</span>/<span class="number">1</span>/task/<span class="number">1</span>/fd/<span class="number">4</span>': <span class="type">No</span> such file <span class="keyword">or</span> directory
du: cannot access './<span class="keyword">proc</span>/<span class="number">1</span>/task/<span class="number">1</span>/fdinfo/<span class="number">4</span>': <span class="type">No</span> such file <span class="keyword">or</span> directory
du: cannot access './<span class="keyword">proc</span>/<span class="number">1</span>/fd/<span class="number">4</span>': <span class="type">No</span> such file <span class="keyword">or</span> directory
du: cannot access './<span class="keyword">proc</span>/<span class="number">1</span>/fdinfo/<span class="number">4</span>': <span class="type">No</span> such file <span class="keyword">or</span> directory
<span class="number">296</span>M    .
</code></pre><p>我们的容器大小只是近300M，因此Docker镜像的大小和容器中文件系统内容的大小是两个概念。镜像的大小等于其包含的所有镜像层之和，并且由于镜像层共享技术的存在(比如我们再构建一个基于ubuntu14:04的镜像，将直接复用本地已有的ubuntu镜像层)，极大节省了磁盘空间。</p>
<h2 id="四-_参考">四. 参考</h2><ol>
<li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices" target="_blank" rel="external">Dockerfile Best Practices</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile Reference</a></li>
<li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="external">Docker run Reference</a></li>
<li><a href="http://docs.daocloud.io/allen-docker" target="_blank" rel="external">Allen谈Docker系列</a></li>
</ol>

        </div>
        
        <blockquote class="post-copyright">
            <div class="content">
               这里写留言或版权声明：<a href="/2016/11/docker-basic/" target="_blank" rel="external">http://wudaijun.com/2016/11/docker-basic/</a>
            </div>
            <footer>
                <a href="http://wudaijun.com">
                    <img src="/favicon.png" alt="wudaijun">
                    wudaijun
                </a>
            </footer>
        </blockquote>

        

        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li></ul>


            
            <div class="post-share-wrap">
                <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

                <a href="javascript:;" id="share-fab" class="post-share-fab waves-effect waves-circle">
                    <i class="icon icon-share-alt icon-lg"></i>
                </a>
            </div>
            

        </div>
    </div>   

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/11/docker-erlang/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">探索Docker在Erlang集群中的应用</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/10/erlang-server-design7-cluster-bug-note/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">开发笔记(7) 记线上一次回档BUG</h4>
      </a>
    </div>
  
</nav>


            
    


<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'wudaijun'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


</article>


</div>
  </main>
  <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Docker 学习",
    pic: "/favicon.png",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://wudaijun.com/2016/11/docker-basic/"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


  <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script src="/js/main.min.js?v=1.1.4"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.1.4"></script>





<script src="//s95.cnzz.com/z_stat.php?id=1254033667&web_id=1254033667"></script>





</body>
</html>
