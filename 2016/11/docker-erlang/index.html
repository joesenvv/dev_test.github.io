<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
  <title>探索Docker在Erlang集群中的应用 | wudaijun&#39;s blog | Coding is Funny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="docker">
  <meta name="description" content="接上篇，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。
简单Docker交互下面是个简单的echo server：
-module(server_echo).
-export([start/0]).

start() -&amp;gt;
     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),">
<meta property="og:type" content="article">
<meta property="og:title" content="探索Docker在Erlang集群中的应用">
<meta property="og:url" content="http://wudaijun.com/2016/11/docker-erlang/index.html">
<meta property="og:site_name" content="wudaijun's blog">
<meta property="og:description" content="接上篇，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。
简单Docker交互下面是个简单的echo server：
-module(server_echo).
-export([start/0]).

start() -&amp;gt;
     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),">
<meta property="og:updated_time" content="2016-11-14T08:42:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="探索Docker在Erlang集群中的应用">
<meta name="twitter:description" content="接上篇，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。
简单Docker交互下面是个简单的echo server：
-module(server_echo).
-export([start/0]).

start() -&amp;gt;
     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),">
  
    <link rel="alternative" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  
  <meta name="summary" content="&lt;p&gt;接&lt;a href=&quot;http://0.0.0.0:4444/2016/11/docker-basic/&quot;&gt;上篇&lt;/a&gt;，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。&lt;/p&gt;
&lt;h2 id=&quot;简单Docker交互&quot;&gt;简单Docker交互&lt;/h2&gt;&lt;p&gt;下面是个简单的echo server：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;(server_echo).
-&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt;([start/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]).

start&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; -&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;attribute&quot;&gt;io&lt;/span&gt;:format(&lt;span class=&quot;string&quot;&gt;&quot;SERVER Trying to bind to port 2345\n&quot;&lt;/span&gt;),
     {ok, Listen} = &lt;span class=&quot;attribute&quot;&gt;gen_tcp&lt;/span&gt;:listen(&lt;span class=&quot;number&quot;&gt;2345&lt;/span&gt;, [ binary
                                         , {packet, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;}
                                         , {reuseaddr, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;}
                                         , {active, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;}
                                         ]),
     &lt;span class=&quot;attribute&quot;&gt;io&lt;/span&gt;:format(&lt;span class=&quot;string&quot;&gt;&quot;SERVER Listening on port 2345\n&quot;&lt;/span&gt;),
     accept(Listen).

 accept&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(Listen)&lt;/span&gt; -&amp;gt;&lt;/span&gt;
     {ok, Socket} = &lt;span class=&quot;attribute&quot;&gt;gen_tcp&lt;/span&gt;:accept(Listen),
     WorkerPid = spawn&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(fun() -&amp;gt; echo(Socket) end)&lt;/span&gt;,
     &lt;span class=&quot;title&quot;&gt;gen_tcp&lt;/span&gt;:&lt;span class=&quot;title&quot;&gt;controlling_process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Socket, WorkerPid)&lt;/span&gt;,
     &lt;span class=&quot;title&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Listen)&lt;/span&gt;.

 &lt;span class=&quot;title&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Socket)&lt;/span&gt; -&amp;gt;&lt;/span&gt;
     receive
         {tcp, Socket, Bin}&lt;span class=&quot;function&quot;&gt; -&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;attribute&quot;&gt;io&lt;/span&gt;:format(&lt;span class=&quot;string&quot;&gt;&quot;SERVER Received: ~p\n&quot;&lt;/span&gt;, [Bin]),
             &lt;span class=&quot;attribute&quot;&gt;gen_tcp&lt;/span&gt;:send(Socket, Bin),
             echo(Socket);
         {tcp_closed, Socket}&lt;span class=&quot;function&quot;&gt; -&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;attribute&quot;&gt;io&lt;/span&gt;:format(&lt;span class=&quot;string&quot;&gt;&quot;SERVER: The client closed the connection\n&quot;&lt;/span&gt;)
     end.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单起见，我们直接用&lt;code&gt;telnet&lt;/code&gt;命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。&lt;/p&gt;">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css?v=1.1.4">
</head>

<body>
  <div id="loading" class="active"></div>

  <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar"><img src="/favicon.png"></a>
        <hgroup class="introduce">
          <h5 class="nickname">wudaijun</h5>
          <a href="mailto:wdjlost@gmail.com" title="wdjlost@gmail.com" class="mail">wdjlost@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://blog.csdn.net/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-contao"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>

      <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>wudaijun&#39;s blog &copy; 2017</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

    </div>
  </div>
</aside>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">探索Docker在Erlang集群中的应用</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container">
        <h1 class="title">探索Docker在Erlang集群中的应用</h1>
        
        

    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简单Docker交互"><span class="post-toc-text">简单Docker交互</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#容器中运行"><span class="post-toc-text">容器中运行</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#宿主机访问容器"><span class="post-toc-text">宿主机访问容器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#容器之间访问"><span class="post-toc-text">容器之间访问</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义Dockerfile"><span class="post-toc-text">定义Dockerfile</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Erlang多节点通信"><span class="post-toc-text">Erlang多节点通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#再谈Erlang分布式通信"><span class="post-toc-text">再谈Erlang分布式通信</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在同主机不同容器中部署集群"><span class="post-toc-text">在同主机不同容器中部署集群</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在不同的主机上部署集群"><span class="post-toc-text">在不同的主机上部署集群</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Erlang_In_Docker"><span class="post-toc-text">Erlang In Docker</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-docker-erlang" 
  class="post-article article-type-post" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">探索Docker在Erlang集群中的应用</h1>
        <div class="post-meta">
            <time datetime="2016-11-04T16:00:00.000Z" itemprop="datePublished" class="post-time">
  2016-11-05
</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/tool/">tool</a></li></ul>



        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>接<a href="http://0.0.0.0:4444/2016/11/docker-basic/" target="_blank" rel="external">上篇</a>，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。</p>
<h2 id="简单Docker交互">简单Docker交互</h2><p>下面是个简单的echo server：</p>
<pre><code>-<span class="built_in">module</span>(server_echo).
-<span class="keyword">export</span>([start/<span class="number">0</span>]).

start<span class="function"><span class="params">()</span> -&gt;</span>
     <span class="attribute">io</span>:format(<span class="string">"SERVER Trying to bind to port 2345\n"</span>),
     {ok, Listen} = <span class="attribute">gen_tcp</span>:listen(<span class="number">2345</span>, [ binary
                                         , {packet, <span class="number">0</span>}
                                         , {reuseaddr, <span class="literal">true</span>}
                                         , {active, <span class="literal">true</span>}
                                         ]),
     <span class="attribute">io</span>:format(<span class="string">"SERVER Listening on port 2345\n"</span>),
     accept(Listen).

 accept<span class="function"><span class="params">(Listen)</span> -&gt;</span>
     {ok, Socket} = <span class="attribute">gen_tcp</span>:accept(Listen),
     WorkerPid = spawn<span class="function"><span class="params">(fun() -&gt; echo(Socket) end)</span>,
     <span class="title">gen_tcp</span>:<span class="title">controlling_process</span><span class="params">(Socket, WorkerPid)</span>,
     <span class="title">accept</span><span class="params">(Listen)</span>.

 <span class="title">echo</span><span class="params">(Socket)</span> -&gt;</span>
     receive
         {tcp, Socket, Bin}<span class="function"> -&gt;</span>
             <span class="attribute">io</span>:format(<span class="string">"SERVER Received: ~p\n"</span>, [Bin]),
             <span class="attribute">gen_tcp</span>:send(Socket, Bin),
             echo(Socket);
         {tcp_closed, Socket}<span class="function"> -&gt;</span>
             <span class="attribute">io</span>:format(<span class="string">"SERVER: The client closed the connection\n"</span>)
     end.
</code></pre><p>简单起见，我们直接用<code>telnet</code>命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。</p>
<a id="more"></a>
<h3 id="容器中运行">容器中运行</h3><pre><code><span class="function_or_atom">sudo</span> <span class="function_or_atom">docker</span> <span class="function_or_atom">run</span> -<span class="function_or_atom">it</span> --<span class="function_or_atom">rm</span> -<span class="function_or_atom">v</span> ~/<span class="function_or_atom">docker</span>:/<span class="function_or_atom">code</span> -<span class="function_or_atom">w</span> /<span class="function_or_atom">code</span> <span class="function_or_atom">erlang</span> <span class="function_or_atom">erl</span>
<span class="variable">Erlang</span>/<span class="variable">OTP</span> <span class="number">19</span> [<span class="function_or_atom">erts</span>-<span class="number">8.1</span>] [<span class="function_or_atom">source</span>] [<span class="number">64</span>-<span class="function_or_atom">bit</span>] [<span class="function_or_atom">smp</span>:<span class="number">4</span>:<span class="number">4</span>] [<span class="function_or_atom">async</span>-<span class="function_or_atom">threads</span>:<span class="number">10</span>] [<span class="function_or_atom">hipe</span>] [<span class="function_or_atom">kernel</span>-<span class="function_or_atom">poll:false</span>]

<span class="variable">Eshell</span> <span class="variable">V8</span>.<span class="number">1</span>  (<span class="function_or_atom">abort</span> <span class="function_or_atom">with</span> ^<span class="variable">G</span>)
<span class="prompt">1&gt; </span><span class="function_or_atom">c</span>(<span class="function_or_atom">server_echo</span>).
{<span class="ok">ok</span>,<span class="function_or_atom">server_echo</span>}
<span class="prompt">2&gt; </span><span class="function_or_atom">server_echo:start</span>().
<span class="variable">SERVER</span> <span class="variable">Trying</span> <span class="function_or_atom">to</span> <span class="function_or_atom">bind</span> <span class="function_or_atom">to</span> <span class="function_or_atom">port</span> <span class="number">2345</span>
<span class="variable">SERVER</span> <span class="variable">Listening</span> <span class="function_or_atom">on</span> <span class="function_or_atom">port</span> <span class="number">2345</span>
</code></pre><p>在<code>docker run</code>中，我们将本地代码路径挂载到容器的/code目录，并且将/code作为容器的工作目录，此后对本地代码的修改，将直接反映在容器中，而无需拷贝。运行容器后会进入erl shell，并且当前路径(/code)即为本地代码路径(~/docker)，之后编译运行server即可。</p>
<h3 id="宿主机访问容器">宿主机访问容器</h3><p>如下方案可以让宿主机能访问容器端口：</p>
<ul>
<li>在<code>docker run</code>中指定<code>-p 2345:2345</code>导出2345端口，之后访问宿主机的2345端口等同于访问容器2345端口</li>
<li>在<code>docker run</code>中指定<code>--network host</code>使容器和宿主机共享网络栈，IP和端口</li>
<li>通过<code>docker inspect</code>查询容器IP地址(如:<code>172.17.0.2</code>)，可在宿主机上通过该IP访问容器</li>
</ul>
<h3 id="容器之间访问">容器之间访问</h3><p>容器间交互方式主要有三种：</p>
<ul>
<li>通过<code>docker inspect</code>得到容器IP地址，通过IP地址进行容器间的交互</li>
<li>通过<code>docker run</code>中指定<code>--network container:&lt;name or id&gt;</code>，将新创建的容器与一个已经存在的容器的共享网络栈，IP和端口</li>
<li>通过<code>docker run</code>的<code>--link &lt;name or id&gt;</code>选项链接两个容器，之后可以将容器名或容器ID作为Hostname来访问容器，注意<code>--link</code>选项仅在<code>--network bridge</code>下有效</li>
</ul>
<h3 id="定义Dockerfile">定义Dockerfile</h3><p>前面我是通过挂载目录的方式将本地代码映射到容器中，这种方式在本地开发中比较方便，但是在项目部署或环境配置比较复杂时，我们需要通过Dockerfile来构建自己的镜像(而不是基于官方Erlang镜像)，初始化项目环境，就本例而言，Dockerfile非常简单：</p>
<pre><code><span class="built_in">FROM</span> erlang

<span class="built_in">RUN</span> <span class="bash">mkdir code
</span>
<span class="built_in">COPY</span> <span class="bash">server_echo.erl code/server_echo.erl
</span>
<span class="built_in">RUN</span> <span class="bash"><span class="built_in">cd</span> code &amp;&amp; erlc server_echo.erl
</span>
<span class="built_in">WORKDIR</span> <span class="bash">/code
</span>
<span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"erl"</span>, <span class="string">"-noshell"</span>, <span class="string">"-run"</span>, <span class="string">"server_echo"</span>, <span class="string">"start"</span>]</span>
</code></pre><h2 id="Erlang多节点通信">Erlang多节点通信</h2><h3 id="再谈Erlang分布式通信">再谈Erlang分布式通信</h3><p>Erlang的分布式节点有自己的通信机制，这套通信机制对上层用户是透明的，我们只需一个节点名(<code>node@host</code>)，即可访问这个节点，而无需关心这个节点是在本机上还是在其它主机上。在这之上封装的Pid，进一步地屏蔽了节点内进程和跨节点进程的差异。</p>
<p>在<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>中，我提到了Erlang的分布式设施，其中epmd扮演着重要的角色：它维护了本机上所有节点的节点名到节点监听地址的映射，并且由于epmd进程本身的监听端口在集群内是周知的(默认为4369)，因此可以根据节点名<code>node@host</code>得到节点所在主机上epmd的监听地址(<code>host:4369</code>)，进而从epmd进程上查询到节点名<code>node</code>所监听的地址，实现节点间通信。</p>
<h3 id="在同主机不同容器中部署集群">在同主机不同容器中部署集群</h3><p>现在回到Docker，我们先尝试在同一个主机，不同容器上建立集群：</p>
<pre><code># 容器<span class="tag">A</span> 启动后通过<span class="tag">docker</span> <span class="tag">inspect</span>查询得到<span class="tag">IP</span>地址: <span class="tag">172</span><span class="class">.17</span><span class="class">.0</span><span class="class">.2</span>
<span class="tag">sudo</span> <span class="tag">docker</span> <span class="tag">run</span> <span class="tag">-it</span> <span class="tag">erlang</span> /<span class="tag">bin</span>/<span class="tag">bash</span>
<span class="tag">root</span>@<span class="tag">4453d880b5a5</span>:/# <span class="tag">erl</span> <span class="tag">-name</span> <span class="tag">n1</span>@<span class="tag">172</span><span class="class">.17</span><span class="class">.0</span><span class="class">.2</span> <span class="tag">-setcookie</span> <span class="tag">123</span>
<span class="tag">Eshell</span> <span class="tag">V8</span><span class="class">.1</span>  (abort with ^G)
(n1<span class="variable">@172</span>.<span class="number">17.0</span>.<span class="number">2</span>)<span class="tag">1</span>&gt; 

# 容器<span class="tag">B</span> 启动后通过<span class="tag">docker</span> <span class="tag">inspect</span>查询得到<span class="tag">IP</span>地址: <span class="tag">172</span><span class="class">.17</span><span class="class">.0</span><span class="class">.4</span>
<span class="tag">sudo</span> <span class="tag">docker</span> <span class="tag">run</span> <span class="tag">-it</span> <span class="tag">erlang</span> /<span class="tag">bin</span>/<span class="tag">bash</span>
<span class="tag">root</span>@<span class="tag">dd0f30178036</span>:/# <span class="tag">erl</span> <span class="tag">-name</span> <span class="tag">n2</span>@<span class="tag">172</span><span class="class">.17</span><span class="class">.0</span><span class="class">.4</span> <span class="tag">-setcookie</span> <span class="tag">123</span>
<span class="tag">Eshell</span> <span class="tag">V8</span><span class="class">.1</span>  (abort with ^G)
(n2<span class="variable">@172</span>.<span class="number">17.0</span>.<span class="number">4</span>)<span class="tag">1</span>&gt; <span class="tag">net_kernel</span><span class="pseudo">:connect_node</span>(<span class="string">'n1@172.17.0.2'</span>).
<span class="tag">true</span>
(n2<span class="variable">@172</span>.<span class="number">17.0</span>.<span class="number">4</span>)<span class="tag">2</span>&gt; <span class="tag">nodes</span>().
<span class="attr_selector">['n1@172.17.0.2']</span>
</code></pre><p>和在宿主机上一样，我们可以直接通过容器IP架设集群。这里使用的是<code>-name node@host</code>指定的longname，而如果使用shortname：</p>
<pre><code># 容器<span class="tag">A</span>
<span class="tag">root</span>@<span class="tag">4453d880b5a5</span>:/# <span class="tag">erl</span> <span class="tag">-sname</span> <span class="tag">n1</span> <span class="tag">-setcookie</span> <span class="tag">123</span>
<span class="tag">Eshell</span> <span class="tag">V8</span><span class="class">.1</span>  (abort with ^G)
(n1<span class="variable">@4453d880b5a5</span>)<span class="tag">1</span>&gt;

# 容器<span class="tag">B</span>
<span class="tag">root</span>@<span class="tag">dd0f30178036</span>:/# <span class="tag">erl</span> <span class="tag">-sname</span> <span class="tag">n2</span> <span class="tag">-setcookie</span> <span class="tag">123</span>
<span class="tag">Eshell</span> <span class="tag">V8</span><span class="class">.1</span>  (abort with ^G)
(n2<span class="variable">@dd0f30178036</span>)<span class="tag">1</span>&gt; <span class="tag">net_kernel</span><span class="pseudo">:connect_node</span>(<span class="string">'n1@4453d880b5a5'</span>).
<span class="tag">false</span>
</code></pre><p>在shortname方案中，我们并不能通过nodename访问节点，本质上是因为<code>n2</code>节点不能通过<code>4453d880b5a5:4369</code>访问到<code>n1</code>节点所在主机上的epmd进程。我们测试一下网络环境：</p>
<pre><code><span class="preprocessor"># 通过容器A名字ping</span>
ping <span class="number">4453</span>d880b5a5
ping: unknown host

<span class="preprocessor"># 直接ping容器A IP</span>
ping <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>
PING <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span> (<span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>): <span class="number">56</span> data bytes
<span class="number">64</span> bytes from <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>: icmp_seq=<span class="number">0</span> ttl=<span class="number">64</span> time=<span class="number">0.099</span> ms
<span class="number">64</span> bytes from <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.089</span> ms
</code></pre><p>发现是hostname解析出了问题，容器链接来解决这个问题：</p>
<pre><code># 重新启动容器<span class="tag">B</span> 并链接到容器<span class="tag">A</span>
<span class="tag">docker</span> <span class="tag">run</span> <span class="tag">-it</span> <span class="tag">--link</span> <span class="tag">4453d880b5a5</span> <span class="tag">erlang</span> /<span class="tag">bin</span>/<span class="tag">bash</span>
<span class="tag">root</span>@<span class="tag">7692c8c71218</span>:/# <span class="tag">erl</span> <span class="tag">-sname</span> <span class="tag">n2</span> <span class="tag">-setcookie</span> <span class="tag">123</span>
<span class="tag">Eshell</span> <span class="tag">V8</span><span class="class">.1</span>  (abort with ^G)
(n2<span class="variable">@dd0f30178036</span>)<span class="tag">1</span>&gt; <span class="tag">net_kernel</span><span class="pseudo">:connect_node</span>(<span class="string">'n1@4453d880b5a5'</span>).
<span class="tag">true</span>
</code></pre><p>有个有趣的问题是，当容器B link了容器A，那么容器B能通过容器A的Id或名字访问容器B，而反过来，容器A却不能以同样的方式访问容器B。也就是说link是单向的，这同样可以通过ping来验证。</p>
<h3 id="在不同的主机上部署集群">在不同的主机上部署集群</h3><p>在不同的主机上部署集群，问题开始变得复杂：</p>
<ol>
<li>不同的主机上的Docker容器处于不同的子网(一台主机对应一个子网)，因此不同主机上的容器不能直接访问，需要先发布(publish)Erlang节点监听端口</li>
<li>Erlang节点在Docker容器中的监听地址是由Erlang VM启动时分配的，因此我们无法在启动容器时就获知Erlang节点监听端口(从而发布该端口)</li>
<li>假定我们预配置了Erlang节点的监听端口xxx，如果我们使用<code>-p xxx:xxx</code>将可能导致端口争用(亦即一台物理机只能运行一个Docker容器)，如果我们使用<code>-p xxx</code>将该端口发布到主机任意一个端口，那么这个发布的主机端口，将只能通过Docker Daemon获取到(命令行下可通过<code>docker port</code>查看)</li>
<li>再来看epmd，每个Docker容器中都会跑一个epmd进程，它记录的是节点名到<strong>节点在容器中的监听地址</strong>，因此，epmd本身返回的地址是不能直接被其它主机上的节点使用的</li>
</ol>
<h4 id="Erlang_In_Docker">Erlang In Docker</h4><p>基于上面的种种限制，有人给出了一套解决方案：<a href="https://github.com/Random-Liu/Erlang-In-Docker" target="_blank" rel="external">Erlang In Docker</a>。这套方案对Erlang集群做了如下制约：</p>
<ol>
<li>每个Docker容器只能运行一个Erlang节点</li>
<li>预配置Erlang节点的监听端口</li>
<li>Erlang节点名格式为<code>DockerContainerID@HostIP</code></li>
<li>使用Docker Daemon而不是epmd来获取节点监听端口</li>
</ol>
<p>这套方案的核心思路是用Docker Daemon替换epmd做节点监听的服务发现，原因有二：</p>
<ul>
<li>Docker Daemon运行于主机同级网络中</li>
<li>维护了容器端口和主机端口的映射关系</li>
</ul>
<p>如果节点A想要访问节点B，则节点A需要提供：</p>
<ul>
<li>节点B所在主机地址: Host</li>
<li>节点B所在主机上Docker Daemon的监听端口: DaemonPort</li>
<li>节点B所在容器ID: ContainerID</li>
<li>节点B在所在容器中的监听端口: Port0</li>
</ul>
<p>之后就可以通过Docker Daemon(<code>Host:DaemonPort</code>)查询到<code>ContainerID</code>容器的<code>Port0</code>端口在主机上对应的发布端口<code>Port1</code>，之后节点A即可通过<code>Host:Port1</code>与节点B通信。</p>
<p>然而节点A只有节点B的名字，要在节点B中编码这四条信息是非常困难的，因此Erlang In Docker的做法是，预配置Port0(12345)和DaemonPort(4243)，剩下的主机地址和容器ID则编码在节点名中：<code>DockerContainerID@HostIP</code>。</p>
<p>EID代码并不复杂，得益于Erlang可替换的分布式通信协议，EID只自定义了<code>eid_tcp_dist</code>(替换默认的<code>inet_tcp_dist</code>模块)和dpmd(通过与Docker Daemon交互模拟epmd的功能)两个模块。</p>
<h4 id="总结">总结</h4><p>将Erlang应用到Docker上比较困难的主要原因是Erlang已经提供了非常完备的分布式设施(参见<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>)，并且这一套对上层都是透明的。EID这套方案看起来限制很多，但细想也没多大问题，具体还要看在生产环境中的表现，目前我比较顾虑它的通信效率(NAT)和<code>eid_tcp_dist</code>是否足够健壮。</p>

        </div>
        
        <blockquote class="post-copyright">
            <div class="content">
               这里写留言或版权声明：<a href="/2016/11/docker-erlang/" target="_blank" rel="external">http://wudaijun.com/2016/11/docker-erlang/</a>
            </div>
            <footer>
                <a href="http://wudaijun.com">
                    <img src="/favicon.png" alt="wudaijun">
                    wudaijun
                </a>
            </footer>
        </blockquote>

        

        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li></ul>


            
            <div class="post-share-wrap">
                <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

                <a href="javascript:;" id="share-fab" class="post-share-fab waves-effect waves-circle">
                    <i class="icon icon-share-alt icon-lg"></i>
                </a>
            </div>
            

        </div>
    </div>   

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/12/unicode-in-erlang/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Erlang Unicode编码</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/11/docker-basic/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Docker 学习</h4>
      </a>
    </div>
  
</nav>


            
    


<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'wudaijun'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


</article>


</div>
  </main>
  <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "探索Docker在Erlang集群中的应用",
    pic: "/favicon.png",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://wudaijun.com/2016/11/docker-erlang/"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


  <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script src="/js/main.min.js?v=1.1.4"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.1.4"></script>





<script src="//s95.cnzz.com/z_stat.php?id=1254033667&web_id=1254033667"></script>





</body>
</html>
