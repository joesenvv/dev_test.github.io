<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>探索Docker在Erlang集群中的应用 | wudaijun's blog</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">探索Docker在Erlang集群中的应用</h1><a id="logo" href="/.">wudaijun's blog</a><p class="description">Coding is Funny</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">探索Docker在Erlang集群中的应用</h1><div class="post-meta"><a href="/2016/11/docker-erlang/#comments" class="comment-count"><a id="uyan_count_unit" href="/2016/11/docker-erlang/"></a>留言</a><p><span class="date">Nov 05, 2016</span><span><a href="/categories/tool/" class="category">tool</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>接<a href="http://0.0.0.0:4444/2016/11/docker-basic/" target="_blank" rel="external">上篇</a>，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。</p>
<h2 id="简单Docker交互"><a href="#简单Docker交互" class="headerlink" title="简单Docker交互"></a>简单Docker交互</h2><p>下面是个简单的echo server：</p>
<pre><code>-module(server_echo).
-export([start/0]).

start() -&gt;
     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),
     {ok, Listen} = gen_tcp:listen(2345, [ binary
                                         , {packet, 0}
                                         , {reuseaddr, true}
                                         , {active, true}
                                         ]),
     io:format(&quot;SERVER Listening on port 2345\n&quot;),
     accept(Listen).

 accept(Listen) -&gt;
     {ok, Socket} = gen_tcp:accept(Listen),
     WorkerPid = spawn(fun() -&gt; echo(Socket) end),
     gen_tcp:controlling_process(Socket, WorkerPid),
     accept(Listen).

 echo(Socket) -&gt;
     receive
         {tcp, Socket, Bin} -&gt;
             io:format(&quot;SERVER Received: ~p\n&quot;, [Bin]),
             gen_tcp:send(Socket, Bin),
             echo(Socket);
         {tcp_closed, Socket} -&gt;
             io:format(&quot;SERVER: The client closed the connection\n&quot;)
     end.
</code></pre><p>简单起见，我们直接用<code>telnet</code>命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。</p>
<a id="more"></a>
<h3 id="容器中运行"><a href="#容器中运行" class="headerlink" title="容器中运行"></a>容器中运行</h3><pre><code>sudo docker run -it --rm -v ~/docker:/code -w /code erlang erl
Erlang/OTP 19 [erts-8.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.1  (abort with ^G)
1&gt; c(server_echo).
{ok,server_echo}
2&gt; server_echo:start().
SERVER Trying to bind to port 2345
SERVER Listening on port 2345
</code></pre><p>在<code>docker run</code>中，我们将本地代码路径挂载到容器的/code目录，并且将/code作为容器的工作目录，此后对本地代码的修改，将直接反映在容器中，而无需拷贝。运行容器后会进入erl shell，并且当前路径(/code)即为本地代码路径(~/docker)，之后编译运行server即可。</p>
<h3 id="宿主机访问容器"><a href="#宿主机访问容器" class="headerlink" title="宿主机访问容器"></a>宿主机访问容器</h3><p>如下方案可以让宿主机能访问容器端口：</p>
<ul>
<li>在<code>docker run</code>中指定<code>-p 2345:2345</code>导出2345端口，之后访问宿主机的2345端口等同于访问容器2345端口</li>
<li>在<code>docker run</code>中指定<code>--network host</code>使容器和宿主机共享网络栈，IP和端口</li>
<li>通过<code>docker inspect</code>查询容器IP地址(如:<code>172.17.0.2</code>)，可在宿主机上通过该IP访问容器</li>
</ul>
<h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器间交互方式主要有三种：</p>
<ul>
<li>通过<code>docker inspect</code>得到容器IP地址，通过IP地址进行容器间的交互</li>
<li>通过<code>docker run</code>中指定<code>--network container:&lt;name or id&gt;</code>，将新创建的容器与一个已经存在的容器的共享网络栈，IP和端口</li>
<li>通过<code>docker run</code>的<code>--link &lt;name or id&gt;</code>选项链接两个容器，之后可以将容器名或容器ID作为Hostname来访问容器，注意<code>--link</code>选项仅在<code>--network bridge</code>下有效</li>
</ul>
<h3 id="定义Dockerfile"><a href="#定义Dockerfile" class="headerlink" title="定义Dockerfile"></a>定义Dockerfile</h3><p>前面我是通过挂载目录的方式将本地代码映射到容器中，这种方式在本地开发中比较方便，但是在项目部署或环境配置比较复杂时，我们需要通过Dockerfile来构建自己的镜像(而不是基于官方Erlang镜像)，初始化项目环境，就本例而言，Dockerfile非常简单：</p>
<pre><code>FROM erlang

RUN mkdir code

COPY server_echo.erl code/server_echo.erl

RUN cd code &amp;&amp; erlc server_echo.erl

WORKDIR /code

ENTRYPOINT [&quot;erl&quot;, &quot;-noshell&quot;, &quot;-run&quot;, &quot;server_echo&quot;, &quot;start&quot;]
</code></pre><h2 id="Erlang多节点通信"><a href="#Erlang多节点通信" class="headerlink" title="Erlang多节点通信"></a>Erlang多节点通信</h2><h3 id="再谈Erlang分布式通信"><a href="#再谈Erlang分布式通信" class="headerlink" title="再谈Erlang分布式通信"></a>再谈Erlang分布式通信</h3><p>Erlang的分布式节点有自己的通信机制，这套通信机制对上层用户是透明的，我们只需一个节点名(<code>node@host</code>)，即可访问这个节点，而无需关心这个节点是在本机上还是在其它主机上。在这之上封装的Pid，进一步地屏蔽了节点内进程和跨节点进程的差异。</p>
<p>在<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>中，我提到了Erlang的分布式设施，其中epmd扮演着重要的角色：它维护了本机上所有节点的节点名到节点监听地址的映射，并且由于epmd进程本身的监听端口在集群内是周知的(默认为4369)，因此可以根据节点名<code>node@host</code>得到节点所在主机上epmd的监听地址(<code>host:4369</code>)，进而从epmd进程上查询到节点名<code>node</code>所监听的地址，实现节点间通信。</p>
<h3 id="在同主机不同容器中部署集群"><a href="#在同主机不同容器中部署集群" class="headerlink" title="在同主机不同容器中部署集群"></a>在同主机不同容器中部署集群</h3><p>现在回到Docker，我们先尝试在同一个主机，不同容器上建立集群：</p>
<pre><code># 容器A 启动后通过docker inspect查询得到IP地址: 172.17.0.2
sudo docker run -it erlang /bin/bash
root@4453d880b5a5:/# erl -name n1@172.17.0.2 -setcookie 123
Eshell V8.1  (abort with ^G)
(n1@172.17.0.2)1&gt; 

# 容器B 启动后通过docker inspect查询得到IP地址: 172.17.0.4
sudo docker run -it erlang /bin/bash
root@dd0f30178036:/# erl -name n2@172.17.0.4 -setcookie 123
Eshell V8.1  (abort with ^G)
(n2@172.17.0.4)1&gt; net_kernel:connect_node(&#39;n1@172.17.0.2&#39;).
true
(n2@172.17.0.4)2&gt; nodes().
[&#39;n1@172.17.0.2&#39;]
</code></pre><p>和在宿主机上一样，我们可以直接通过容器IP架设集群。这里使用的是<code>-name node@host</code>指定的longname，而如果使用shortname：</p>
<pre><code># 容器A
root@4453d880b5a5:/# erl -sname n1 -setcookie 123
Eshell V8.1  (abort with ^G)
(n1@4453d880b5a5)1&gt;

# 容器B
root@dd0f30178036:/# erl -sname n2 -setcookie 123
Eshell V8.1  (abort with ^G)
(n2@dd0f30178036)1&gt; net_kernel:connect_node(&#39;n1@4453d880b5a5&#39;).
false
</code></pre><p>在shortname方案中，我们并不能通过nodename访问节点，本质上是因为<code>n2</code>节点不能通过<code>4453d880b5a5:4369</code>访问到<code>n1</code>节点所在主机上的epmd进程。我们测试一下网络环境：</p>
<pre><code># 通过容器A名字ping
ping 4453d880b5a5
ping: unknown host

# 直接ping容器A IP
ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.099 ms
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.089 ms
</code></pre><p>发现是hostname解析出了问题，容器链接来解决这个问题：</p>
<pre><code># 重新启动容器B 并链接到容器A
docker run -it --link 4453d880b5a5 erlang /bin/bash
root@7692c8c71218:/# erl -sname n2 -setcookie 123
Eshell V8.1  (abort with ^G)
(n2@dd0f30178036)1&gt; net_kernel:connect_node(&#39;n1@4453d880b5a5&#39;).
true
</code></pre><p>有个有趣的问题是，当容器B link了容器A，那么容器B能通过容器A的Id或名字访问容器B，而反过来，容器A却不能以同样的方式访问容器B。也就是说link是单向的，这同样可以通过ping来验证。</p>
<h3 id="在不同的主机上部署集群"><a href="#在不同的主机上部署集群" class="headerlink" title="在不同的主机上部署集群"></a>在不同的主机上部署集群</h3><p>在不同的主机上部署集群，问题开始变得复杂：</p>
<ol>
<li>不同的主机上的Docker容器处于不同的子网(一台主机对应一个子网)，因此不同主机上的容器不能直接访问，需要先发布(publish)Erlang节点监听端口</li>
<li>Erlang节点在Docker容器中的监听地址是由Erlang VM启动时分配的，因此我们无法在启动容器时就获知Erlang节点监听端口(从而发布该端口)</li>
<li>假定我们预配置了Erlang节点的监听端口xxx，如果我们使用<code>-p xxx:xxx</code>将可能导致端口争用(亦即一台物理机只能运行一个Docker容器)，如果我们使用<code>-p xxx</code>将该端口发布到主机任意一个端口，那么这个发布的主机端口，将只能通过Docker Daemon获取到(命令行下可通过<code>docker port</code>查看)</li>
<li>再来看epmd，每个Docker容器中都会跑一个epmd进程，它记录的是节点名到<strong>节点在容器中的监听地址</strong>，因此，epmd本身返回的地址是不能直接被其它主机上的节点使用的</li>
</ol>
<h4 id="Erlang-In-Docker"><a href="#Erlang-In-Docker" class="headerlink" title="Erlang In Docker"></a>Erlang In Docker</h4><p>基于上面的种种限制，有人给出了一套解决方案：<a href="https://github.com/Random-Liu/Erlang-In-Docker" target="_blank" rel="external">Erlang In Docker</a>。这套方案对Erlang集群做了如下制约：</p>
<ol>
<li>每个Docker容器只能运行一个Erlang节点</li>
<li>预配置Erlang节点的监听端口</li>
<li>Erlang节点名格式为<code>DockerContainerID@HostIP</code></li>
<li>使用Docker Daemon而不是epmd来获取节点监听端口</li>
</ol>
<p>这套方案的核心思路是用Docker Daemon替换epmd做节点监听的服务发现，原因有二：</p>
<ul>
<li>Docker Daemon运行于主机同级网络中</li>
<li>维护了容器端口和主机端口的映射关系</li>
</ul>
<p>如果节点A想要访问节点B，则节点A需要提供：</p>
<ul>
<li>节点B所在主机地址: Host</li>
<li>节点B所在主机上Docker Daemon的监听端口: DaemonPort</li>
<li>节点B所在容器ID: ContainerID</li>
<li>节点B在所在容器中的监听端口: Port0</li>
</ul>
<p>之后就可以通过Docker Daemon(<code>Host:DaemonPort</code>)查询到<code>ContainerID</code>容器的<code>Port0</code>端口在主机上对应的发布端口<code>Port1</code>，之后节点A即可通过<code>Host:Port1</code>与节点B通信。</p>
<p>然而节点A只有节点B的名字，要在节点B中编码这四条信息是非常困难的，因此Erlang In Docker的做法是，预配置Port0(12345)和DaemonPort(4243)，剩下的主机地址和容器ID则编码在节点名中：<code>DockerContainerID@HostIP</code>。</p>
<p>EID代码并不复杂，得益于Erlang可替换的分布式通信协议，EID只自定义了<code>eid_tcp_dist</code>(替换默认的<code>inet_tcp_dist</code>模块)和dpmd(通过与Docker Daemon交互模拟epmd的功能)两个模块。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>将Erlang应用到Docker上比较困难的主要原因是Erlang已经提供了非常完备的分布式设施(参见<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>)，并且这一套对上层都是透明的。EID这套方案看起来限制很多，但细想也没多大问题，具体还要看在生产环境中的表现，目前我比较顾虑它的通信效率(NAT)和<code>eid_tcp_dist</code>是否足够健壮。</p>
</div><div class="tags"><a href="/tags/docker/">docker</a></div><div class="post-share"></div><div class="post-nav"><a href="/2016/12/unicode-in-erlang/" class="pre">Erlang Unicode编码</a><a href="/2016/11/docker-basic/" class="next">Docker 学习</a></div><div id="comments"><div id="uyan_frame"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单Docker交互"><span class="toc-text">简单Docker交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器中运行"><span class="toc-text">容器中运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宿主机访问容器"><span class="toc-text">宿主机访问容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器之间访问"><span class="toc-text">容器之间访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义Dockerfile"><span class="toc-text">定义Dockerfile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Erlang多节点通信"><span class="toc-text">Erlang多节点通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#再谈Erlang分布式通信"><span class="toc-text">再谈Erlang分布式通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在同主机不同容器中部署集群"><span class="toc-text">在同主机不同容器中部署集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在不同的主机上部署集群"><span class="toc-text">在不同的主机上部署集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Erlang-In-Docker"><span class="toc-text">Erlang In Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/go-interface-implement/">Go Interface实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/go-scheduler/">Go 调度模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/gc-study/">常见GC算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/hexo-with-mathjax/">Hexo使用mathjax渲染公式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/docker-network/">docker 网络模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/ngs-battle/">探讨服务端回合制战斗系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/go-conetxt-usage/">用context库规范化Go的异步调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/go-vs-erlang/">Go vs Erlang</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/erlang-lua-reconstruction/">Erlang+Lua的一次重构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/lua-notes/">Lua 闭包 环境 包管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gameserver/">gameserver</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">os</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/system/">system</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/other/" style="font-size: 15px;">other</a> <a href="/tags/ngserver/" style="font-size: 15px;">ngserver</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/skynet/" style="font-size: 15px;">skynet</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/firefly/" style="font-size: 15px;">firefly</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/kbengine/" style="font-size: 15px;">kbengine</a> <a href="/tags/distribution/" style="font-size: 15px;">distribution</a> <a href="/tags/unity/" style="font-size: 15px;">unity</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/c-c/" style="font-size: 15px;">c/c++</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/gameserver/" style="font-size: 15px;">gameserver</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/goa/" style="font-size: 15px;">goa</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/macosx/" style="font-size: 15px;">macosx</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wudaijun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="http://v2.uyan.cc/code/uyan.js?uid=2157109"></script></body></html>