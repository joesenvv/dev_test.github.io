<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Go 笔记(1) 常用数据结构及实现 | wudaijun's blog</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go 笔记(1) 常用数据结构及实现</h1><a id="logo" href="/.">wudaijun's blog</a><p class="description">Coding is Funny</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Go 笔记(1) 常用数据结构及实现</h1><div class="post-meta"><a href="/2016/09/go-notes-1-datastructures/#comments" class="comment-count"><i data-disqus-identifier="2016/09/go-notes-1-datastructures/" class="disqus-comment-count"></i>留言</a><p><span class="date">Sep 09, 2016</span><span><a href="/categories/go/" class="category">go</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>学习一下go中常用的几种数据结构，结合源码了解其实现原理。</p>
<h2 id="一-类型系统"><a href="#一-类型系统" class="headerlink" title="一. 类型系统"></a>一. 类型系统</h2><h3 id="1-array"><a href="#1-array" class="headerlink" title="1. array"></a>1. array</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x [2]<span class="keyword">int</span>)</span></span>&#123;</div><div class="line">	x[<span class="number">1</span>] = <span class="number">9</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line">	b := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">	f(a) <span class="comment">// error: cannot use a (type [3]int) as type [2]int in argument to f</span></div><div class="line">	f(b) <span class="comment">// 数组是值语义 因此f无法改变b中元素内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>array的特性:</p>
<ul>
<li>固定大小，且大小为类型的一部分</li>
<li>数组元素在内存中连续存放</li>
<li>值语义: 数组本身(传参会完整拷贝数组)</li>
</ul>
<h3 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice"></a>2. slice</h3><h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><p>slice(切片)，提供描述array部分连续元素的能力。</p>
<blockquote>
<blockquote>
<p>A slice is a data structure describing a contiguous section of an array stored separately from the slice variable itself. A slice is not an array. A slice describes a piece of an array.</p>
</blockquote>
</blockquote>
<p>slice只持有array的引用，而不会拷贝元素，因此它在实现上只需持有指向array元素的pointer和slice长度length即可。但由于slice的length可以收缩或扩张，因此slice还需要一个字段capacity来保存其最初引用的array的size，当length &gt; capacity时，说明对array的访问越界，触发panic错误。</p>
<p>因此slice一共有三个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> sliceHeader&#123;</div><div class="line">	Length 	<span class="keyword">int</span>			<span class="comment">// slice长度</span></div><div class="line">	Capacity 	<span class="keyword">int</span> 		<span class="comment">// slice引用的array size</span></div><div class="line">	Elem 	 	*ElemType <span class="comment">// 指向slice第一个元素array中的地址</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接创建slice 等价于:</span></div><div class="line"><span class="comment">// tmp := [5]int&#123;2,3,5,7,11&#125;</span></div><div class="line"><span class="comment">// a := tmp[0:5]</span></div><div class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>&#125;</div><div class="line">b := a[<span class="number">1</span>:<span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>此时a,b的sliceHeader示意图为:</p>
<p><img src="/assets/image/go/go-slice-implement.png" alt=""></p>
<p>由于slice b在slice a中的起始偏移为1，因此 cap(b) = cap(a)-1 = 4。但b只能访问到a[1],a[2]两个元素:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 尝试访问&gt;=length(2)的元素，会触发panic error</span></div><div class="line">fmt.Println(b[<span class="number">2</span>])</div><div class="line"><span class="comment">// 等价于 c := b[0:len(b)] c和b引用完全相同的数组切片</span></div><div class="line">c := b[:]</div><div class="line"><span class="comment">// 虽然b只能访问数组[1],[2]两个元素，但d可以在[0,cap(b)]再次切片扩展引用的数组范围</span></div><div class="line">d := b[<span class="number">0</span>:<span class="built_in">cap</span>(b)]</div><div class="line">fmt.Println(d[<span class="number">3</span>]) <span class="comment">// 11</span></div></pre></td></tr></table></figure>
<p>那么slice这种数组切片的概念，究竟带来了什么好处？比如我们有一个操作，要去掉数组的首尾元素，在C中，我们会创建(动态分配)一个新数组，然后将arr[1,n-1)拷贝出来。在C++中，有vector会方便一些，但移除元素会导致后续元素移动拷贝开销。而在Go中，<code>slice = slice[1:len(slice)-1]</code>即可完成操作，这中间不会涉及到内存分配，移动拷贝等，是个非常高效的操作。当然，由于slice是引用的数组元素，因此slice修改数组元素时，对其它引用到该元素的slice也是可见的。</p>
<p>下面来说说slice的值语义。前面提到的sliceHeader，实际就是slice的值语义，我们创建一个slice，在底层就创建了一个sliceHeader结构体。在参数传递时，将会拷贝sliceHeader，但由于sliceHeader中持有指针，因此在调用函数内可修改数组元素，但无法修改sliceHeader结构体的成员值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Extend</span><span class="params">(slice []<span class="keyword">int</span>, element <span class="keyword">int</span> )</span></span>&#123;</div><div class="line">	n := <span class="built_in">len</span>(slice)</div><div class="line">	slice = slice[<span class="number">0</span> : n+<span class="number">1</span>] <span class="comment">// 不会影响到传入的slice的length</span></div><div class="line">	slice[n] = element <span class="comment">// 修改了数组内容，对传入的slice可见</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次摘录一段<a href="https://blog.golang.org/slices" target="_blank" rel="external">golang blog</a>关于slice值语义的描述:</p>
<blockquote>
<blockquote>
<p>It’s important to understand that even though a slice contains a pointer, it is itself a value. Under the covers, it is a struct value holding a pointer and a length. It is not a pointer to a struct.</p>
</blockquote>
</blockquote>
<p>BTW，在Go里面的参数传递都是值传递的，只是针对各种类型，其值语义不同，比如int,array它们的值语义就是数据本身，不包含对外的引用(指针)，因此在传参时会完整拷贝整个数据，是没有副作用的。而对slice来说，其值语义中包含对数组的引用，因此在传参时，其引用内容可能被修改，但其值语义(sliceHeader)本身仍然是完整拷贝的。</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>前面提到slice本质上是数组切片，但slice本身也可以作为动态数组:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">	s := a[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">	fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line">	<span class="comment">// len=3 cap=5 capacity足够 无需重新分配 因此修改会作用于a之上</span></div><div class="line">	s = <span class="built_in">append</span>(s, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">	fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line">	<span class="comment">// len=5 cap=5 append通过make()重新分配新的slice 并通过copy()拷贝已有元素</span></div><div class="line">	<span class="comment">// 此后s不再指向a 而指向新分配的连续内存空间</span></div><div class="line">	s = <span class="built_in">append</span>(s, <span class="number">8</span>)</div><div class="line">	fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line">	<span class="comment">// 对s的修改将不在作用于a上</span></div><div class="line">	s[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">	fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出:</span></div><div class="line"><span class="built_in">cap</span>:  <span class="number">5</span> <span class="built_in">len</span>:  <span class="number">3</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</div><div class="line"><span class="built_in">cap</span>:  <span class="number">5</span> <span class="built_in">len</span>:  <span class="number">5</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</div><div class="line"><span class="built_in">cap</span>:  <span class="number">10</span> <span class="built_in">len</span>:  <span class="number">6</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</div><div class="line"><span class="built_in">cap</span>:  <span class="number">10</span> <span class="built_in">len</span>:  <span class="number">6</span> slice:  [<span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</div></pre></td></tr></table></figure>
<p>append会在<strong>len(s)+添加的元素个数&gt;cap(s)时</strong>，重新分配(make)一个slice，拷贝(copy)已有元素，添加新元素，最后返回这个新的slice。在使用append时，需要保存其返回值，因为append传入的是slice的值，也就是sliceHeader结构体，当slice capacity扩展时，append函数内不能修改sliceHeader中的Length和Capacity字段，因此需要返回一个新的sliceHeader。</p>
<p>为了避免混淆，不要像上例一样将slice的切片特性和动态数组特性混用，使用动态数组时，使用空的slice(<code>var s []int</code>)或make(<code>make([]int, len, cap)</code>)初始化一个slice会比较好。</p>
<h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p>Go中的string更像是C中的字符串字面量，而不是字符数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">str := <span class="string">"Hello, 世界"</span></div><div class="line"><span class="comment">//str[0] = 'X' // error 不可改变字符串(类似字面常量)</span></div><div class="line"></div><div class="line"><span class="comment">// 字符串可通过 + 进行拼接</span></div><div class="line">str += <span class="string">" !"</span></div><div class="line"></div><div class="line"><span class="comment">// 以ANSI字符遍历 ch是一个byte n=15(每个中文在UTF-8中占3个字节)</span></div><div class="line">n := <span class="built_in">len</span>(str)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; n; i++ &#123;</div><div class="line">    ch := str[i]</div><div class="line">    fmt.Println(i, ch)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 以Unicode字符遍历 ch是一个rune 而不是byte 此时遍历得到11个Unicode字符</span></div><div class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> str&#123;</div><div class="line">    fmt.Println(i, ch)                </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现上，string是个read-only byte slice，另外，string的”sliceHeader”没有capacity字段：</p>
<p><img src="/assets/image/go/go-string-implement.png" alt=""></p>
<pre><code>s := &quot;hello&quot;
t := s[2:3] // &quot;l&quot;
v := t[0:2] // 没有capacity字段，无法扩展，触发panic error: out of range
</code></pre><p>由于string的slice特性，len(s)操作非常高效，字符串切割也给代码处理带来很高的灵活度，如官方runtime/string.go的atoi函数是这样写的:</p>
<pre><code>func atoi(s string) int{
    n := 0
       for len(s) &gt; 0 &amp;&amp; &apos;0&apos; &lt;= s[0] &amp;&amp; s[0] &lt;= &apos;9&apos; {
        n = n*10 + int(s[0]) - &apos;0&apos;
        s = s[1:]
    }
    return n
}
</code></pre><p>PS，slice的这种切片特性，与Erlang的<a href="http://wudaijun.com/2015/12/erlang-datastructures/#refc-bianry">refc binary和sub binary</a>实现有相似之处，这种高效的处理方案有个老大难问题，那就是slice string未释放，那么它引用的string本身也不会被GC，哪怕只引用了很小一部分。</p>
<h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map通过hash表实现，实现位于runtime/hashmap.go，以下是主要字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">	bucketCntBits = <span class="number">3</span></div><div class="line">	bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</div><div class="line">)</div><div class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</div><div class="line">	count <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></div><div class="line">	flags <span class="keyword">uint8</span></div><div class="line">	B     <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></div><div class="line"></div><div class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></div><div class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></div><div class="line">	</div><div class="line">	evacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="comment">// A bucket for a Go map.</span></div><div class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</div><div class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></div><div class="line">	<span class="comment">// Followed by bucketCnt keys and then bucketCnt values.</span></div><div class="line">	<span class="comment">// Followed by an overflow pointer.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>摘自源码注释：</p>
<blockquote>
<blockquote>
<p>A map is just a hash table.  The data is arranged into an array of buckets.  Each bucket contains up to 8 key/value pairs.  The low-order bits of the hash are used to select a bucket.  Each bucket contains a few high-order bits of each hash to distinguish the entries within a single bucket.</p>
<p>If more than 8 keys hash to a bucket, we chain on extra buckets.</p>
<p>When the hashtable grows, we allocate a new array of buckets twice as big.  Buckets are incrementally copied from the old bucket array to the new bucket array.</p>
</blockquote>
</blockquote>
<p>hmap的buckets数组大小为2^B，通过取余(<code>hash(key)&amp;(1&lt;&lt;B-1)</code>)可得到key对应的bucket在buckets数组中的下标，每个bucket可以容纳2^bucketCntBits=8个key/value对，落到该桶的key个数超过8个时，会在堆上分配一个新的bucket，并挂在链表末，因此go hashmap通过链表(8个元素一组)来解决hash碰撞问题。</p>
<p>go的hash map使用的是可扩展hash算法，在负载因子loadFactor(<code>hmap.count/(1&lt;&lt;B)</code>)大于某个值(这个值太大会导致overflow buckets过多，查找效率降低，过小会浪费存储空间，经源码作者测试确认为6.5)时，进行hash扩展。此时B=B&lt;&lt;1，原有buckets由oldbuckets指向，新的buckets重新分配，此时由于hash表大小变更，部分key得到的buckets下标也会改变，因此需要将oldbuckets中的数据按照新的hash表大小重新迁移(evacuate)，出于效率考虑，这个操作是增量进行的，在hash map每次写入时，都会尝试迁移两个bucket(以及后续overflow bucket)，一个是写入的目标bucket(局部迁移)，一个是hmap.evacuate指向的bucket(增量迁移)，这样兼顾局部性和全局性，同时也能保证在新的buckets loadFacotr到达6.5前，所有迁移工作一定能完成。迁移工作完成后，oldbucket置为nil。PS: hash map通过bucket的tophash[0]来标记bucket的迁移状态，保留的标记值为0-3，key的tophash在这个范围内时，会被+4修正</p>
<p>上述是基于go1.5 hashmap实现，在go1.8中，添加了sameSizeGrow，当overflow buckets的数量超过一定数量(2^B)而负载未大于阀值6.5时，此时可能存在部分空的bucket，即bucket未有效利用，这时会触发sameSizeGrow，即B不变，但走数据迁移流程，将oldbuckets的数据重新紧凑排列提高bucket的利用率。当然在sameSizeGrow过程中，不能触发loadFactorGrow。</p>
<p>下面来看个结构图:</p>
<p><img src="/assets/image/go/go-map-implement.png" alt=""></p>
<p>再来看Key查找过程(简化版):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// From go 1.8.1 src/runtime/hashmap.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 并发检查 go hashmap不支持并发访问</span></div><div class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</div><div class="line">		throw(<span class="string">"concurrent map read and map write"</span>)</div><div class="line">	&#125;</div><div class="line">	alg := t.key.alg</div><div class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</div><div class="line">	m := <span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span></div><div class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</div><div class="line">	<span class="comment">// step1: 找到bucket</span></div><div class="line">	<span class="comment">// 如果oldbuckets未迁移完成 则找打oldbuckets中对应的bucket(低B-1位)</span></div><div class="line">	<span class="comment">// 否则为buckets中的bucket(低B位)</span></div><div class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</div><div class="line">			m &gt;&gt;= <span class="number">1</span></div><div class="line">		&#125;</div><div class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</div><div class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</div><div class="line">			b = oldb</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	top := <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</div><div class="line">	<span class="keyword">if</span> top &lt; minTopHash &#123;</div><div class="line">		top += minTopHash</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">// step2: 比较tophash</span></div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</div><div class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// dataOffset为key数组在bucket(bmap结构)中的起始偏移</span></div><div class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</div><div class="line">			<span class="keyword">if</span> t.indirectkey &#123;</div><div class="line">				k = *((*unsafe.Pointer)(k))</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// step3: 比较key</span></div><div class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</div><div class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</div><div class="line">				<span class="keyword">if</span> t.indirectvalue &#123;</div><div class="line">					v = *((*unsafe.Pointer)(v))</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> v</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		b = b.overflow(t)</div><div class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>限于理解深度，其它一些细节没有提到，比如对不含pointer的key/value优化，另外，go map还针对常用key类型(如int32,int64,string)进行了特例优化，代码位于src/runtime/hashmap_fast.go。以下是上面已经提到的一些小的优化细节：</p>
<ul>
<li>key value采用k1,k2,..v1,v2,…排列，而不是k1,v1,k2,v2，这是出于内存对齐考虑，节约空间</li>
<li>tophash可用于加快key的查找，同时用于标记key的迁移状态</li>
<li>map大小是2的幂，因此hash值可快速求余: hash(key)&amp;(1&lt;&lt;B-1)</li>
<li>hash map的增量式扩展，sameSizeGrow</li>
</ul>
<p>其它:</p>
<ul>
<li>go map不支持并发</li>
<li>go map目前只有扩展 没有收缩操作(shrink)</li>
<li>go map迁移时，会创建新的bucket，而不会复用oldbucket中的overflow bucket(作者TODO里面)</li>
</ul>
<p>值语义：如hmap结构体所示，buckets为bucket指针数组，那么对key,value的操作都是引用语义的。</p>
<h3 id="5-channel"><a href="#5-channel" class="headerlink" title="5. channel"></a>5. channel</h3><p>channel是goroutine用于数据交互的通道，和Erlang的Actor以通信实体为第一类对象不同(Actor模型)，Go以通信介质作为第一类对象(CSP模型)，channel支持多写入者和读取者，并且可通过缓冲来实现同步/异步(一定数量)通信。</p>
<p>在实现上，channel其实就是个消息队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 省略部分字段</span></div><div class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</div><div class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></div><div class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></div><div class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></div><div class="line">	elemsize <span class="keyword">uint16</span></div><div class="line">	closed   <span class="keyword">uint32</span></div><div class="line">	elemtype *_type <span class="comment">// element type</span></div><div class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></div><div class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></div><div class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></div><div class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></div><div class="line">	lock mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下图描述了一个缓冲区大小为5，并阻塞了若干读goroutine的情况:</p>
<p><img src="/assets/image/go/go-chan-implement.png" alt=""></p>
<p>该图省略了hchan和sudog的部分字段，waitq在实现上是双向链表，虽然实际只会用到单链表语义(FIFO)。</p>
<p>根据上图情形，此时如果有其它goroutine写入channel:</p>
<ol>
<li>从recvq中pop第一个读写者的sudog</li>
<li>将写入channel的数据拷贝到该sudog的elem字段</li>
<li>唤醒该读写者goroutine(sudog.g)</li>
</ol>
<p>当recvq队列为空，此时写入:</p>
<ol>
<li>将写入的数据缓存到buff[sendx]</li>
<li>sendx环形自增，qcount++</li>
</ol>
<p>当buff缓冲区写满(qcount==dataqsiz)，此时写入:</p>
<ol>
<li>为写入者创建一个sudog，并插入到sendq队列末</li>
<li>挂起该写入者goroutine</li>
</ol>
<p>如果此时有goroutine再次读channel:</p>
<ol>
<li>从buf[recvx]读取第一个数据</li>
<li>从sendq中pop第一个阻塞的写入者goroutine(sudog)</li>
<li>将该sudog中的elem字段数据拷贝到buf[recvx]，相当于将elem数据push到buf末尾</li>
<li>recvx++</li>
<li>唤醒该发送者goroutine</li>
</ol>
<p>没有缓冲的channel(dataqsize==0)操作要简单一些，写入时如果recvq-&gt;first!=nil，则直接拷贝数据到读取者的elem字段，否则将写入者挂起。反之，读写过程也类似。</p>
<p>另外，由于一个goroutine读写多个channel，因此go提供语言级别的select，用于处理异步IO问题。这其实本质上仍然是尝试对channel进行读写操作(chanrecv)，只不过由block参数为false表明该读写不阻塞，当读写操作需要挂起时，立即返回false。而select操作本身其实就是个多分支的if-elseif-else表达式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">src/runtime/<span class="keyword">chan</span>.<span class="keyword">go</span></div><div class="line"><span class="comment">// compiler implements</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//	select &#123;</span></div><div class="line"><span class="comment">//	case c &lt;- v:</span></div><div class="line"><span class="comment">//		... foo</span></div><div class="line"><span class="comment">//	default:</span></div><div class="line"><span class="comment">//		... bar</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// as</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//	if selectnbsend(c, v) &#123;</span></div><div class="line"><span class="comment">//		... foo</span></div><div class="line"><span class="comment">//	&#125; else &#123;</span></div><div class="line"><span class="comment">//		... bar</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> chansend(t, c, elem, <span class="literal">false</span>, getcallerpc(unsafe.Pointer(&amp;t)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>select的if-elseif-else语句分支顺序是随机的，在每次执行select时会将所有scase(包含hchan)顺序随机排列。参考src/runtime/select.go hselect和scase结构体。</p>
<p>通过<code>cap(chan)</code>和<code>len(chan)</code>可以获取channel的缓冲区大小(dataqsize)和当前消息数量(qcount)。</p>
<h3 id="6-interface"><a href="#6-interface" class="headerlink" title="6. interface"></a>6. interface</h3><p>interface接口的用法和实现单独放到<a href="http://wudaijun.com/2016/09/go-notes-3-object-oriented/">go面向对象</a>一节。</p>
<h3 id="7-make-amp-new"><a href="#7-make-amp-new" class="headerlink" title="7. make &amp; new"></a>7. make &amp; new</h3><p>go中有make和new两个关键字用于分配一个对象，简要提一下两者的区别：</p>
<p>内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型<strong>零值</strong>的指针</p>
<p>内建函数 make 用来为 slice，map 或 chan 类型分配内存和<strong>初始化</strong>一个对象(目前只能用于这三种类型)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体使用如下：</p>
<pre><code>// 等价于 a := [capacity]int{}  s := a[0:2]
s := make([]int, length [,capacity])
m := make(map[int]string [,size])
c := make(chan int, [,length])
</code></pre><h3 id="8-常量"><a href="#8-常量" class="headerlink" title="8. 常量"></a>8. 常量</h3><p>Go中的常量是无类型的，字面常量(如：3.14, “ok”)是无类型的，可以赋给任何满在其值域中的类型。Go预定义了三个常量：true, false, iota，其中iota是一个可以被编译器修改的常量，它代表一个整数，在每个const出现时被重置为0，然后iota每出现一次，其所代表的值即自增一次。iota通常用来定义枚举值，这类值应用程序不关心具体数值，只需确保其在同一个const枚举声明中不会冲突即可。</p>
<pre><code>const (
    c0 = iota    // c0 == 0
    c1 = iota    // c1 == 1
    c2 = iota    // c2 == 2
)

// 根据枚举定义相同表达式的缩写，等价于
const (
    c0 = iota    // c0 == 0
    c1            // c1 == 1
    c2            // c2 == 2
)
</code></pre></div><div class="tags"><a href="/tags/go/">go</a></div><div class="post-share"></div><div class="post-nav"><a href="/2016/09/erlang-rebar3/" class="pre">Rebar3 Erlang/OTP构建利器</a><a href="/2016/09/go-notes-2-procedural-programming/" class="next">Go 笔记(2) 顺序编程</a></div><div id="comments"><div id="disqus_thread"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-类型系统"><span class="toc-text">一. 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-array"><span class="toc-text">1. array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-slice"><span class="toc-text">2. slice</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组切片"><span class="toc-text">数组切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态数组"><span class="toc-text">动态数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-string"><span class="toc-text">3. string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-map"><span class="toc-text">4. map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-channel"><span class="toc-text">5. channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-interface"><span class="toc-text">6. interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-make-amp-new"><span class="toc-text">7. make & new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-常量"><span class="toc-text">8. 常量</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/docker-network/">docker 网络模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/ngs-battle/">探讨服务端回合制战斗系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/go-conetxt-usage/">用context库规范化Go的异步调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/go-vs-erlang/">Go vs Erlang</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/erlang-lua-reconstruction/">Erlang+Lua的一次重构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/lua-notes/">Lua 闭包 环境 包管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/max-osx-ulimit/">Mac OS X下的资源限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/go-command-notes/">Go 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/css-notes/">CSS 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/erlang-memory-debug/">Erlang 内存问题诊断</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gameserver/">gameserver</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">os</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/system/">system</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/unity/" style="font-size: 15px;">unity</a> <a href="/tags/ngserver/" style="font-size: 15px;">ngserver</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/skynet/" style="font-size: 15px;">skynet</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/firefly/" style="font-size: 15px;">firefly</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/kbengine/" style="font-size: 15px;">kbengine</a> <a href="/tags/distribution/" style="font-size: 15px;">distribution</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/c-c/" style="font-size: 15px;">c/c++</a> <a href="/tags/other/" style="font-size: 15px;">other</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/gameserver/" style="font-size: 15px;">gameserver</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/goa/" style="font-size: 15px;">goa</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/macosx/" style="font-size: 15px;">macosx</a> <a href="/tags/web/" style="font-size: 15px;">web</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wudaijun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>var disqus_shortname = 'wudaijun';
var disqus_identifier = '2016/09/go-notes-1-datastructures/';
var disqus_title = 'Go 笔记(1) 常用数据结构及实现';
var disqus_url = 'http://wudaijun.com/2016/09/go-notes-1-datastructures/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wudaijun.disqus.com/count.js" async></script><script type="text/javascript" src="//wudaijun.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></body></html>