<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Go 基础学习 | wudaijun&#39;s blog</title>
  <meta name="author" content="wudaijun">
  
  <meta name="description" content="一. 类型系统1. slice数组切片提供了动态数组的能力，功能和实现都类似于C++ Vector。
// 初始化一个数组
var Arr [3]int = [3]int{1,2,3}

var Slice1 []int
// 通过数组初始化切片 得到[1 2]
Slice1 = Arr[:2]
// 直接创建切片 其中size = 5 capacity = 10 尝试访问[size,capacity]之间的元素会得到运行时错误
Slice2 := make([]int, 5, 10)
Slice3 := []int{1,2,3}
// 从切片创建切片 [:last] 只要last&amp;lt;=capacity 均合法
Slice4 := Slice2[:8]
// 切片拷贝 如果两个切片不一样大 会按照较小的数组切片元素个数拷贝
// 这里的拷贝 可以看作是：先置0 再拷贝
copy(Slice4, Slice3)

// 遍历切片[0:size] 多返回值简化了迭代
for i, v := range Slice1 {
    ...
}

// 通过append在size后面添加元素 capacity会自动扩展
// 同样, 多参数简化了迭代
Slice3 = append(Slice3, 1,2,3,4,5,6,7,8,9)">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Go 基础学习"/>
  <meta property="og:site_name" content="wudaijun&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>

<body>
  <header id="header" class="inner"><div class= "header-content">
	<div class = "alignleft col-one">
		
			<img src = "/assets/avatar/avatar.png">
		
		<div class="header-div">
		    <h1><a href="/", style="font-family:Fantasy">wudaijun&#39;s blog</a></h1>
		    <h2><a href="/">Coding is Funny</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
			<img src = "/assets/avatar/hello.jpg">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div id="main-nav" class="alignleft">
	    
	      <a href="/">首页</a>
	    
	      <a href="/archives">归档</a>
	    
	</div>
	<div id="sub-nav" class="alignright">
	    
	      <a href="/about">关于我</a>
	    
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
      <div id="content" class="inner">
  		<div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        <time datetime="2016-09-08T16:00:00.000Z"><a href="/2016/09/go-basic/">2016-09-09</a></time>
        
  
    <h1 class="title">Go 基础学习</h1>
  

    </header>
    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-_类型系统"><span class="toc-text">一. 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_slice"><span class="toc-text">1. slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_map"><span class="toc-text">2. map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_string"><span class="toc-text">3. string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-_值语义和引用语义"><span class="toc-text">4. 值语义和引用语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-_常量"><span class="toc-text">5. 常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-_顺序编程"><span class="toc-text">二. 顺序编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_不定参数&多返回值"><span class="toc-text">1. 不定参数&多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_匿名函数&闭包"><span class="toc-text">2. 匿名函数&闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的概念"><span class="toc-text">闭包的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的价值"><span class="toc-text">闭包的价值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go语言中的闭包"><span class="toc-text">Go语言中的闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-_面向对象："><span class="toc-text">三. 面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_类型扩展"><span class="toc-text">1. 类型扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_类和继承"><span class="toc-text">2. 类和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_访问控制"><span class="toc-text">3. 访问控制</span></a></li></ol></li></ol>
</div>
      
        <h2 id="一-_类型系统">一. 类型系统</h2><h3 id="1-_slice">1. slice</h3><p>数组切片提供了动态数组的能力，功能和实现都类似于C++ Vector。</p>
<pre><code><span class="comment">// 初始化一个数组</span>
var Arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}

var Slice1 []<span class="keyword">int</span>
<span class="comment">// 通过数组初始化切片 得到[1 2]</span>
Slice1 = Arr[:<span class="number">2</span>]
<span class="comment">// 直接创建切片 其中size = 5 capacity = 10 尝试访问[size,capacity]之间的元素会得到运行时错误</span>
Slice2 := make([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)
Slice3 := []<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}
<span class="comment">// 从切片创建切片 [:last] 只要last&lt;=capacity 均合法</span>
Slice4 := Slice2[:<span class="number">8</span>]
<span class="comment">// 切片拷贝 如果两个切片不一样大 会按照较小的数组切片元素个数拷贝</span>
<span class="comment">// 这里的拷贝 可以看作是：先置0 再拷贝</span>
copy(Slice4, Slice3)

<span class="comment">// 遍历切片[0:size] 多返回值简化了迭代</span>
<span class="keyword">for</span> i, v := range Slice1 {
    ...
}

<span class="comment">// 通过append在size后面添加元素 capacity会自动扩展</span>
<span class="comment">// 同样, 多参数简化了迭代</span>
Slice3 = append(Slice3, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)
</code></pre><a id="more"></a>
<h3 id="2-_map">2. map</h3><p>map的使用很简单，唯一需要注意的就是通过delete删除key：</p>
<pre><code>m := make (<span class="built_in">map</span>[<span class="keyword">int</span>]<span class="built_in">string</span>)
m[<span class="number">1</span>] = <span class="string">"one"</span>
m[<span class="number">2</span>] = <span class="string">"two"</span>
<span class="keyword">delete</span>(m, <span class="number">2</span>)
v, ok := m[<span class="number">2</span>] <span class="comment">// 多返回值再一次简化了查询</span>
<span class="keyword">if</span> ok {
    <span class="comment">// do something when found</span>
}
</code></pre><h3 id="3-_string">3. string</h3><p>Go中的string可以看做字符数组，但与字符数组有几点不同：</p>
<pre><code><span class="keyword">str</span> := <span class="string">"Hello, 世界"</span>
//<span class="keyword">str</span>[<span class="number">0</span>] = <span class="string">'X'</span> // error 不可改变字符串(字面常量)

// 字符串可通过 + 进行拼接
<span class="keyword">str</span> += <span class="string">" !"</span>

// 以ANSI字符遍历 <span class="number">ch</span>是一个<span class="preprocessor">byte</span> n=<span class="number">15</span>(每个中文在UTF-<span class="number">8</span>中占<span class="number">3</span>个字节)
n := len(<span class="keyword">str</span>)
for i := <span class="number">0</span><span class="comment">; i&lt; n; i++ {</span>
    <span class="number">ch</span> := <span class="keyword">str</span>[i]
    fmt.Println(i, <span class="number">ch</span>)
}
// 以Unicode字符遍历 <span class="number">ch</span>是一个rune 而不是<span class="preprocessor">byte</span> 此时遍历得到<span class="number">11</span>个Unicode字符
for i, <span class="number">ch</span> := range <span class="keyword">str</span>{
    fmt.Println(i, <span class="number">ch</span>)                
}
</code></pre><h3 id="4-_值语义和引用语义">4. 值语义和引用语义</h3><ul>
<li>值语义：基本类型和数组，结构体，指针等</li>
<li>引用语义：slice，map，channel，interface</li>
</ul>
<h3 id="5-_常量">5. 常量</h3><p>Go中的常量是无类型的，字面常量(如：3.14, “ok”)是无类型的，可以赋给任何满在其值域中的类型。Go预定义了三个常量：true, false, itoa，其中itoa是一个可以被编译器修改的常量，它代表一个整数，在每个const出现时被重置为0，然后itoa每出现一次，其所代表的值即自增一次。itoa通常用来定义枚举值，这类值应用程序不关心具体数值，只需确保其在同一个const枚举声明中不会冲突即可。</p>
<pre><code><span class="keyword">const</span> (
    c0 = <span class="constant">iota</span>    <span class="comment">// c0 == 0</span>
    c1 = <span class="constant">iota</span>    <span class="comment">// c1 == 1</span>
    c2 = <span class="constant">iota</span>    <span class="comment">// c2 == 2</span>
)

<span class="comment">// 根据枚举定义相同表达式的缩写，等价于</span>
<span class="keyword">const</span> (
    c0 = <span class="constant">iota</span>    <span class="comment">// c0 == 0</span>
    c1            <span class="comment">// c1 == 1</span>
    c2            <span class="comment">// c2 == 2</span>
)
</code></pre><h2 id="二-_顺序编程">二. 顺序编程</h2><h3 id="1-_不定参数&amp;多返回值">1. 不定参数&amp;多返回值</h3><p>不定参数只能是最后一个参数，它实际上是数组切片参数的语法糖：</p>
<pre><code><span class="comment">// 语法糖 相当于 func myfunc(args []int)</span>
<span class="function">func <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span>{
    <span class="keyword">for</span> _, arg := range args {
    fmt.Println(arg)
}

<span class="comment">// 语法糖 等价于 myfunc([]int{1,3,5,7,9})</span>
myfunc(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)
</code></pre><p>多返回值为函数提供了更大的便利性，无需传引用或者专门构造返回值结构体，并且在错误处理方面也更简便，在前面的示例代码中已经初尝甜头。</p>
<pre><code><span class="comment">// 定义多返回值函数时，可以为返回值指定名字</span>
func (<span class="keyword">file</span> *<span class="keyword">File</span>) <span class="keyword">Read</span>(b []byte) (<span class="keyword">n</span> int, <span class="keyword">err</span> <span class="keyword">Error</span>){
    <span class="comment">// n和err在函数开始时，被自动初始化为空</span>
    ...
    ... <span class="keyword">n</span> = xxx
    ...
    ... <span class="keyword">err</span> = xxx
    ...
    <span class="comment">// 直接执行return时，将返回n和err变量的值</span>
    <span class="literal">return</span>
}
</code></pre><h3 id="2-_匿名函数&amp;闭包">2. 匿名函数&amp;闭包</h3><p>匿名函数允许函数像变量一样被定义，传递，和使用。Go语言支持随时在代码里定义匿名函数。</p>
<pre><code><span class="comment">// 赋给变量</span>
F = func (a, b <span class="keyword">int</span>) <span class="keyword">int</span> {
    <span class="keyword">return</span> a + b
}
F(<span class="number">1</span>,<span class="number">2</span>)
<span class="comment">// 直接执行</span>
func (a, b <span class="keyword">int</span>) <span class="keyword">int</span> {
    <span class="keyword">return</span> a + b
}(<span class="number">1</span>,<span class="number">2</span>)
</code></pre><h4 id="闭包的概念">闭包的概念</h4><p>闭包是可以包含自由(未绑定到特定对象)变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块(由于自由变量包含在代码块中，所以这些自由变量以及它们所引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)。</p>
<h4 id="闭包的价值">闭包的价值</h4><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一类对象，就是说这些函数可以存储到变量中作为参数传递给其它函数，最重要的是能够被函数动态创建和返回。</p>
<h4 id="Go语言中的闭包">Go语言中的闭包</h4><p>Go语言中的闭包同样也会引用到函数外的变量，闭包的实现确保只要闭包还被使用，那么闭包引用的变量会一直存在。 </p>
<pre><code>package main

<span class="keyword">import</span> "fmt"

<span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {
    <span class="keyword">var</span> j int = <span class="number">5</span>
    a := <span class="func"><span class="keyword">func</span><span class="params">()</span></span>(<span class="func"><span class="keyword">func</span><span class="params">()</span></span>) {
        <span class="keyword">var</span> i int = <span class="number">10</span>
        <span class="keyword">return</span> <span class="func"><span class="keyword">func</span><span class="params">()</span></span> {
            fmt.<span class="type">Printf</span>(<span class="string">"i, j: %d, %d\n"</span>, i, j)
        }
    }()

    a()

    j *= <span class="number">2</span>
    a()
}
</code></pre><h2 id="三-_面向对象：">三. 面向对象：</h2><h3 id="1-_类型扩展">1. 类型扩展</h3><pre><code>package main

import <span class="string">"fmt"</span>

type Integer <span class="built_in">int</span>

<span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span> <span class="title">Less</span><span class="params">(b Integer)</span> <span class="title">bool</span> {</span>
    <span class="keyword">return</span> a &lt; b
}

<span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span> <span class="title">Integer</span>{</span>
    <span class="keyword">return</span> *a + b
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span> {</span>
    var a Integer = <span class="number">2</span>
    fmt.Println( a.Add(<span class="number">1</span>).Less(<span class="number">3</span>) )
}
</code></pre><h3 id="2-_类和继承">2. 类和继承</h3><p>在Go中，传统意义上的类相当于是对struct的类型扩展：</p>
<pre><code>package main

<span class="keyword">import</span> "fmt"

type <span class="type">Rect</span> <span class="class"><span class="keyword">struct</span></span>{
    x, y float64
    w, l float64
}

<span class="func"><span class="keyword">func</span> <span class="params">(r Rect)</span></span> <span class="type">Area</span>() float64{
    <span class="keyword">return</span> r.l * r.w
}

<span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">c</span> := <span class="type">Rect</span>{<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>}
    fmt.<span class="type">Println</span>(<span class="built_in">c</span>.<span class="type">Area</span>())
}
</code></pre><p>Go中的继承通过匿名组合实现：</p>
<pre><code>package main

<span class="keyword">import</span> "fmt"

type <span class="type">Base</span> <span class="class"><span class="keyword">struct</span> </span>{
    <span class="type">Name</span> string
}
<span class="func"><span class="keyword">func</span> <span class="params">(base *Base)</span></span> <span class="type">Foo</span>() {
    fmt.<span class="type">Println</span>(<span class="string">"Base Foo()"</span>)
}
<span class="func"><span class="keyword">func</span> <span class="params">(base *Base)</span></span> <span class="type">Bar</span>() {
    fmt.<span class="type">Println</span>(<span class="string">"Base Bar()"</span>)
}
<span class="comment">// 以组合的方式 定义继承</span>
<span class="comment">// 当derive.<span class="label">xxx在Derive中未找到时，将从基类Base中查找</span></span>
<span class="comment">// 也可通过derive.Base.<span class="label">xxx直接引用基类Base的方法或成员</span></span>
type <span class="type">Derive</span> <span class="class"><span class="keyword">struct</span> </span>{
    <span class="type">Base</span>
    age int <span class="comment">// 这里的同名成员将覆盖Base中的成员</span>
}
<span class="comment">// 重写基类方法</span>
<span class="func"><span class="keyword">func</span> <span class="params">(d *Derive)</span></span> <span class="type">Bar</span>() {
    fmt.<span class="type">Println</span>(<span class="string">"Derive Bar()"</span>)
}

<span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
    b := <span class="type">Base</span>{<span class="string">"name"</span>}
    d := <span class="type">Derive</span>{b, <span class="number">99</span>}
    d.<span class="type">Foo</span>() <span class="comment">// == d.Base.Foo() 语法糖，Foo()函数的接收者只能是Base*</span>
    d.<span class="type">Bar</span>()
    fmt.<span class="type">Println</span>(d.<span class="type">Name</span>,d.age)
}
</code></pre><p>还可以以指针的方式从一个类型派生：</p>
<pre><code><span class="typedef"><span class="keyword">type</span> <span class="type">Derive</span> struct <span class="container">{
    *<span class="type">Base</span>
    ...
}</span></span>
</code></pre><p>这个时候Derive的初始化需要提供一个Base的指针，它存在的意义类似于C++中的虚基类，很少用到。Go将C++面向对象中一些”黑盒子”放到了台面上来，如this指针(作为一个特殊的参数显现出来)，虚函数表(Go中不允许派生类指针到基类指针的隐式转换，也就无需虚函数表来实现多态)，虚基类(通过显式基类指针，简洁明了的实现了这一需求)。</p>
<h3 id="3-_访问控制">3. 访问控制</h3><p>Go中没有private public等关键字，要使符号对其它包可见，则需要将该符号定义为大写字母开头。如Base中的Name能被其它引用了Base所在包的代码访问到，而Derive中age则不能。Go中没有类级别的访问控制。</p>

      
    </div>
    <footer>
<!--        -->
        
  
  <div class="categories">
    <a href="/categories/go/">go</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/go/">go</a>
  </div>

        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
<!--   <h1 class="title">留言</h1> -->


    <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="2016/09/go-basic/" data-title="Go 基础学习" data-url="http://wudaijun.com/2016/09/go-basic/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wudaijun"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


  
</section>



</div></div>
  		<aside id="sidebar" class="alignright">
   <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:wudaijun.com">
  </form>
</div> 

  
<div class="widget tag">
  <h3 class="title">分类</h3>
<!--   
	
		<li><a href="/categories/c-c/">c/c++</a><small>5</small></li>
	
  
	
		<li><a href="/categories/database/">database</a><small>4</small></li>
	
  
	
		<li><a href="/categories/erlang/">erlang</a><small>22</small></li>
	
  
	
		<li><a href="/categories/gameserver/">gameserver</a><small>20</small></li>
	
  
	
		<li><a href="/categories/go/">go</a><small>1</small></li>
	
  
	
		<li><a href="/categories/lua/">lua</a><small>1</small></li>
	
  
	
		<li><a href="/categories/network/">network</a><small>3</small></li>
	
  
	
		<li><a href="/categories/os/">os</a><small>2</small></li>
	
  
	
		<li><a href="/categories/other/">other</a><small>1</small></li>
	
  
	
		<li><a href="/categories/python/">python</a><small>1</small></li>
	
  
	
		<li><a href="/categories/tool/">tool</a><small>3</small></li>
	
  
	
		<li><a href="/categories/unity/">unity</a><small>3</small></li>
	
  
	
		<li><a href="/categories/web/">web</a><small>1</small></li>
	
   -->
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gameserver/">gameserver</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">os</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">1</span></li></ul> 
</div>
 


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">2016年09月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">2016年08月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">2016年07月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">2016年06月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">2016年05月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">2016年04月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">2016年03月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">2016年02月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">2016年01月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">2015年12月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">2015年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">2015年10月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">2015年09月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">2015年08月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">2015年07月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">2015年06月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">2015年05月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">2015年04月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">2015年03月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">2015年02月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">2015年01月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">2014年12月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">2014年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">2014年10月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">2014年09月</a><span class="archive-list-count">1</span></li></ul>
  </div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/c-c/" style="font-size: 15.71px;">c/c++</a> <a href="/tags/distribution/" style="font-size: 14.29px;">distribution</a> <a href="/tags/erlang/" style="font-size: 20px;">erlang</a> <a href="/tags/firefly/" style="font-size: 11.43px;">firefly</a> <a href="/tags/gameserver/" style="font-size: 10px;">gameserver</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/kbengine/" style="font-size: 11.43px;">kbengine</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lua/" style="font-size: 17.14px;">lua</a> <a href="/tags/mongodb/" style="font-size: 14.29px;">mongodb</a> <a href="/tags/multi-thread/" style="font-size: 12.86px;">multi-thread</a> <a href="/tags/ngserver/" style="font-size: 18.57px;">ngserver</a> <a href="/tags/os/" style="font-size: 11.43px;">os</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/python/" style="font-size: 14.29px;">python</a> <a href="/tags/skynet/" style="font-size: 14.29px;">skynet</a> <a href="/tags/tcp-ip/" style="font-size: 12.86px;">tcp/ip</a> <a href="/tags/tool/" style="font-size: 11.43px;">tool</a> <a href="/tags/unity/" style="font-size: 12.86px;">unity</a> <a href="/tags/web/" style="font-size: 10px;">web</a>
  </div>
</div>

</aside>
           <div class="clearfix"></div>
      </div>
  	
   <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 wudaijun
  
</div>
<div class="alignright">
	<a href="https://github.com/pengloo53/light-ch">Hexo theme</a>
</div>
<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?380ce5c81e06b297c4a75c0c66825c3d";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>
<!--  -->


</body>
</html>