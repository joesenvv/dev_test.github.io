<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Go 基础特性 | wudaijun&#39;s blog</title>
  <meta name="author" content="wudaijun">
  
  <meta name="description" content="一. 类型系统1. slice数组切片提供了动态数组的能力，功能和实现都类似于C++ Vector。
// 初始化一个数组
var Arr [3]int = [3]int{1,2,3}

var Slice1 []int
// 通过数组初始化切片 得到[1 2]
Slice1 = Arr[:2]
// 直接创建切片 其中size = 5 capacity = 10 尝试访问[size,capacity]之间的元素会得到运行时错误
Slice2 := make([]int, 5, 10)
Slice3 := []int{1,2,3}
// 从切片创建切片 [:last] 只要last&amp;lt;=capacity 均合法
Slice4 := Slice2[:8]
// 切片拷贝 如果两个切片不一样大 会按照较小的数组切片元素个数拷贝
// 这里的拷贝 可以看作是：先置0 再拷贝
copy(Slice4, Slice3)

// 遍历切片[0:size] 多返回值简化了迭代
for i, v := range Slice1 {
    ...
}

// 通过append在size后面添加元素 capacity会自动扩展
// 同样, 多参数简化了迭代
Slice3 = append(Slice3, 1,2,3,4,5,6,7,8,9)">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Go 基础特性"/>
  <meta property="og:site_name" content="wudaijun&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>

<body>
  <header id="header" class="inner"><div class= "header-content">
	<div class = "alignleft col-one">
		
			<img src = "/assets/avatar/avatar.png">
		
		<div class="header-div">
		    <h1><a href="/", style="font-family:Fantasy">wudaijun&#39;s blog</a></h1>
		    <h2><a href="/">Coding is Funny</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
			<img src = "/assets/avatar/hello.jpg">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div id="main-nav" class="alignleft">
	    
	      <a href="/">首页</a>
	    
	      <a href="/archives">归档</a>
	    
	</div>
	<div id="sub-nav" class="alignright">
	    
	      <a href="/about">关于我</a>
	    
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
      <div id="content" class="inner">
  		<div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        <time datetime="2016-09-08T16:00:00.000Z"><a href="/2016/09/go-basic/">2016-09-09</a></time>
        
  
    <h1 class="title">Go 基础特性</h1>
  

    </header>
    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-_类型系统"><span class="toc-text">一. 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_slice"><span class="toc-text">1. slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_map"><span class="toc-text">2. map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_string"><span class="toc-text">3. string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-_值语义和引用语义"><span class="toc-text">4. 值语义和引用语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-_make_&_new"><span class="toc-text">5. make & new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-_常量"><span class="toc-text">6. 常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-_顺序编程"><span class="toc-text">二. 顺序编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_不定参数&多返回值"><span class="toc-text">1. 不定参数&多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_匿名函数&闭包"><span class="toc-text">2. 匿名函数&闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-_闭包的概念"><span class="toc-text">a. 闭包的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-_闭包的价值"><span class="toc-text">b. 闭包的价值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-_Go语言中的闭包"><span class="toc-text">c. Go语言中的闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_错误处理"><span class="toc-text">3. 错误处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-_面向对象："><span class="toc-text">三. 面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_类型扩展"><span class="toc-text">1. 类型扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_类和继承"><span class="toc-text">2. 类和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_接口"><span class="toc-text">3. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-_非侵入式接口"><span class="toc-text">a. 非侵入式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-_接口赋值"><span class="toc-text">b. 接口赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-_接口查询"><span class="toc-text">c. 接口查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-_接口组合"><span class="toc-text">d. 接口组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-_任意类型"><span class="toc-text">e. 任意类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-_访问控制"><span class="toc-text">4. 访问控制</span></a></li></ol></li></ol>
</div>
      
        <h2 id="一-_类型系统">一. 类型系统</h2><h3 id="1-_slice">1. slice</h3><p>数组切片提供了动态数组的能力，功能和实现都类似于C++ Vector。</p>
<pre><code><span class="comment">// 初始化一个数组</span>
var Arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}

var Slice1 []<span class="keyword">int</span>
<span class="comment">// 通过数组初始化切片 得到[1 2]</span>
Slice1 = Arr[:<span class="number">2</span>]
<span class="comment">// 直接创建切片 其中size = 5 capacity = 10 尝试访问[size,capacity]之间的元素会得到运行时错误</span>
Slice2 := make([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)
Slice3 := []<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}
<span class="comment">// 从切片创建切片 [:last] 只要last&lt;=capacity 均合法</span>
Slice4 := Slice2[:<span class="number">8</span>]
<span class="comment">// 切片拷贝 如果两个切片不一样大 会按照较小的数组切片元素个数拷贝</span>
<span class="comment">// 这里的拷贝 可以看作是：先置0 再拷贝</span>
copy(Slice4, Slice3)

<span class="comment">// 遍历切片[0:size] 多返回值简化了迭代</span>
<span class="keyword">for</span> i, v := range Slice1 {
    ...
}

<span class="comment">// 通过append在size后面添加元素 capacity会自动扩展</span>
<span class="comment">// 同样, 多参数简化了迭代</span>
Slice3 = append(Slice3, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)
</code></pre><a id="more"></a>
<h3 id="2-_map">2. map</h3><p>map的使用很简单，唯一需要注意的就是通过delete删除key：</p>
<pre><code>m := make (<span class="built_in">map</span>[<span class="keyword">int</span>]<span class="built_in">string</span>)
m[<span class="number">1</span>] = <span class="string">"one"</span>
m[<span class="number">2</span>] = <span class="string">"two"</span>
<span class="keyword">delete</span>(m, <span class="number">2</span>)
v, ok := m[<span class="number">2</span>] <span class="comment">// 多返回值再一次简化了查询</span>
<span class="keyword">if</span> ok {
    <span class="comment">// do something when found</span>
}
</code></pre><h3 id="3-_string">3. string</h3><p>Go中的string可以看做字符数组，但与字符数组有几点不同：</p>
<pre><code><span class="keyword">str</span> := <span class="string">"Hello, 世界"</span>
//<span class="keyword">str</span>[<span class="number">0</span>] = <span class="string">'X'</span> // error 不可改变字符串(字面常量)

// 字符串可通过 + 进行拼接
<span class="keyword">str</span> += <span class="string">" !"</span>

// 以ANSI字符遍历 <span class="number">ch</span>是一个<span class="preprocessor">byte</span> n=<span class="number">15</span>(每个中文在UTF-<span class="number">8</span>中占<span class="number">3</span>个字节)
n := len(<span class="keyword">str</span>)
for i := <span class="number">0</span><span class="comment">; i&lt; n; i++ {</span>
    <span class="number">ch</span> := <span class="keyword">str</span>[i]
    fmt.Println(i, <span class="number">ch</span>)
}
// 以Unicode字符遍历 <span class="number">ch</span>是一个rune 而不是<span class="preprocessor">byte</span> 此时遍历得到<span class="number">11</span>个Unicode字符
for i, <span class="number">ch</span> := range <span class="keyword">str</span>{
    fmt.Println(i, <span class="number">ch</span>)                
}
</code></pre><h3 id="4-_值语义和引用语义">4. 值语义和引用语义</h3><ul>
<li>值语义：基本类型和数组，结构体，指针等</li>
<li>引用语义：slice，map，channel，interface</li>
</ul>
<h3 id="5-_make_&amp;_new">5. make &amp; new</h3><p>内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型<strong>零值</strong>的指针</p>
<p>内建函数 make 用来为 slice，map 或 chan 类型分配内存和<strong>初始化</strong>一个对象(注意：只能用在这三种类型上)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下：</p>
<ul>
<li>Slice: 第二个参数 size 指定了它的长度，它的容量和长度相同。你可以传入第三个参数来指定不同的容量值，但必须不能比长度值小。</li>
<li>Map: 根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存</li>
<li>Channel: 管道缓冲区依据缓冲区容量被初始化。如果容量为 0 或者忽略容量，管道是没有缓冲区的</li>
</ul>
<h3 id="6-_常量">6. 常量</h3><p>Go中的常量是无类型的，字面常量(如：3.14, “ok”)是无类型的，可以赋给任何满在其值域中的类型。Go预定义了三个常量：true, false, itoa，其中itoa是一个可以被编译器修改的常量，它代表一个整数，在每个const出现时被重置为0，然后itoa每出现一次，其所代表的值即自增一次。itoa通常用来定义枚举值，这类值应用程序不关心具体数值，只需确保其在同一个const枚举声明中不会冲突即可。</p>
<pre><code><span class="keyword">const</span> (
    c0 = <span class="constant">iota</span>    <span class="comment">// c0 == 0</span>
    c1 = <span class="constant">iota</span>    <span class="comment">// c1 == 1</span>
    c2 = <span class="constant">iota</span>    <span class="comment">// c2 == 2</span>
)

<span class="comment">// 根据枚举定义相同表达式的缩写，等价于</span>
<span class="keyword">const</span> (
    c0 = <span class="constant">iota</span>    <span class="comment">// c0 == 0</span>
    c1            <span class="comment">// c1 == 1</span>
    c2            <span class="comment">// c2 == 2</span>
)
</code></pre><h2 id="二-_顺序编程">二. 顺序编程</h2><h3 id="1-_不定参数&amp;多返回值">1. 不定参数&amp;多返回值</h3><p>不定参数只能是最后一个参数，它实际上是数组切片参数的语法糖：</p>
<pre><code><span class="comment">// 语法糖 相当于 func myfunc(args []int)</span>
<span class="function">func <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span>{
    <span class="keyword">for</span> _, arg := range args {
    fmt.Println(arg)
}

<span class="comment">// 语法糖 等价于 myfunc([]int{1,3,5,7,9})</span>
myfunc(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)
</code></pre><p>多返回值为函数提供了更大的便利性，无需传引用或者专门构造返回值结构体，并且在错误处理方面也更简便，在前面的示例代码中已经初尝甜头。</p>
<pre><code><span class="comment">// 定义多返回值函数时，可以为返回值指定名字</span>
func (<span class="keyword">file</span> *<span class="keyword">File</span>) <span class="keyword">Read</span>(b []byte) (<span class="keyword">n</span> int, <span class="keyword">err</span> <span class="keyword">Error</span>){
    <span class="comment">// n和err在函数开始时，被自动初始化为空</span>
    ...
    ... <span class="keyword">n</span> = xxx
    ...
    ... <span class="keyword">err</span> = xxx
    ...
    <span class="comment">// 直接执行return时，将返回n和err变量的值</span>
    <span class="literal">return</span>
}
</code></pre><h3 id="2-_匿名函数&amp;闭包">2. 匿名函数&amp;闭包</h3><p>匿名函数允许函数像变量一样被定义，传递，和使用。Go语言支持随时在代码里定义匿名函数。</p>
<pre><code><span class="comment">// 赋给变量</span>
F = func (a, b <span class="keyword">int</span>) <span class="keyword">int</span> {
    <span class="keyword">return</span> a + b
}
F(<span class="number">1</span>,<span class="number">2</span>)
<span class="comment">// 直接执行</span>
func (a, b <span class="keyword">int</span>) <span class="keyword">int</span> {
    <span class="keyword">return</span> a + b
}(<span class="number">1</span>,<span class="number">2</span>)
</code></pre><h4 id="a-_闭包的概念">a. 闭包的概念</h4><p>闭包是可以包含自由(未绑定到特定对象)变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块(由于自由变量包含在代码块中，所以这些自由变量以及它们所引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)。</p>
<h4 id="b-_闭包的价值">b. 闭包的价值</h4><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一类对象，就是说这些函数可以存储到变量中作为参数传递给其它函数，最重要的是能够被函数动态创建和返回。</p>
<h4 id="c-_Go语言中的闭包">c. Go语言中的闭包</h4><p>Go语言中的闭包同样也会引用到函数外的变量，闭包的实现确保只要闭包还被使用，那么闭包引用的变量会一直存在。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">var</span> j <span class="typename">int</span> = <span class="number">5</span></span><br><span class="line">    return_closure := <span class="keyword">func</span>()(<span class="keyword">func</span>()) &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="typename">int</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">            fmt.Printf(<span class="string">"i, j: %d, %d\n"</span>, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个闭包c1 共享所有外部环境 i, j</span></span><br><span class="line">    c1 := return_closure()</span><br><span class="line">    c1()</span><br><span class="line">    c1()</span><br><span class="line"></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">    <span class="comment">// c1 c2 只共享return_closure作用域之外的变量 j</span></span><br><span class="line">    <span class="comment">// return_closure之内定义的变量i将在每次调用时重新生成，因此只对同一个closure有效</span></span><br><span class="line">    c2 := return_closure()</span><br><span class="line">    c2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">i, j: <span class="number">11</span>, <span class="number">6</span></span><br><span class="line">i, j: <span class="number">12</span>, <span class="number">7</span></span><br><span class="line">i, j: <span class="number">11</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="3-_错误处理">3. 错误处理</h3><p>Go的错误处理主要依靠 <code>panic</code>，<code>recover</code>，<code>defer</code>，前两者相当于throw和catch，而defer则是Go又一个让人惊喜的特性，defer确保语句在函数结束(包括异常中断)前执行，defer有如下特性：</p>
<ol>
<li>一个函数可定义多个defer语句</li>
<li>多个defer语句按照先入后出的顺序执行</li>
<li>defer表达式中的变量值在defer表达式定义时就已经明确</li>
<li>defer表达式可以修改函数中的命名返回值</li>
</ol>
<p>defer的作用：</p>
<ol>
<li>简化异常处理(在defetr中recover)，避免异常与控制流程混合(try … catch … finally)</li>
<li>在defer中做环境清理和资源释放</li>
</ol>
<p>BTW，Go鼓励少用异常，用error和多返回值来处理错误。</p>
<h2 id="三-_面向对象：">三. 面向对象：</h2><h3 id="1-_类型扩展">1. 类型扩展</h3><pre><code>package main

import <span class="string">"fmt"</span>

type Integer <span class="built_in">int</span>

<span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span> <span class="title">Less</span><span class="params">(b Integer)</span> <span class="title">bool</span> {</span>
    <span class="keyword">return</span> a &lt; b
}

<span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span> <span class="title">Integer</span>{</span>
    <span class="keyword">return</span> *a + b
}

<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span> {</span>
    var a Integer = <span class="number">2</span>
    fmt.Println( a.Add(<span class="number">1</span>).Less(<span class="number">3</span>) )
}
</code></pre><h3 id="2-_类和继承">2. 类和继承</h3><p>在Go中，传统意义上的类相当于是对struct的类型扩展：</p>
<pre><code>package main

<span class="keyword">import</span> "fmt"

type <span class="type">Rect</span> <span class="class"><span class="keyword">struct</span></span>{
    x, y float64
    w, l float64
}

<span class="func"><span class="keyword">func</span> <span class="params">(r Rect)</span></span> <span class="type">Area</span>() float64{
    <span class="keyword">return</span> r.l * r.w
}

<span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">c</span> := <span class="type">Rect</span>{<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>}
    fmt.<span class="type">Println</span>(<span class="built_in">c</span>.<span class="type">Area</span>())
}
</code></pre><p>Go中的继承通过匿名组合实现：</p>
<pre><code>package main

<span class="keyword">import</span> "fmt"

type <span class="type">Base</span> <span class="class"><span class="keyword">struct</span> </span>{
    <span class="type">Name</span> string
}
<span class="func"><span class="keyword">func</span> <span class="params">(base *Base)</span></span> <span class="type">Foo</span>() {
    fmt.<span class="type">Println</span>(<span class="string">"Base Foo()"</span>)
}
<span class="func"><span class="keyword">func</span> <span class="params">(base *Base)</span></span> <span class="type">Bar</span>() {
    fmt.<span class="type">Println</span>(<span class="string">"Base Bar()"</span>)
}
<span class="comment">// 以组合的方式 定义继承</span>
<span class="comment">// 当derive.<span class="label">xxx在Derive中未找到时，将从基类Base中查找</span></span>
<span class="comment">// 也可通过derive.Base.<span class="label">xxx直接引用基类Base的方法或成员</span></span>
type <span class="type">Derive</span> <span class="class"><span class="keyword">struct</span> </span>{
    <span class="type">Base</span>
    age int <span class="comment">// 这里的同名成员将覆盖Base中的成员</span>
}
<span class="comment">// 重写基类方法</span>
<span class="func"><span class="keyword">func</span> <span class="params">(d *Derive)</span></span> <span class="type">Bar</span>() {
    fmt.<span class="type">Println</span>(<span class="string">"Derive Bar()"</span>)
}

<span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{
    b := <span class="type">Base</span>{<span class="string">"name"</span>}
    d := <span class="type">Derive</span>{b, <span class="number">99</span>}
    d.<span class="type">Foo</span>() <span class="comment">// == d.Base.Foo() 语法糖，Foo()函数的接收者只能是Base*</span>
    d.<span class="type">Bar</span>()
    fmt.<span class="type">Println</span>(d.<span class="type">Name</span>,d.age)
}
</code></pre><p>还可以以指针的方式从一个类型派生：</p>
<pre><code><span class="typedef"><span class="keyword">type</span> <span class="type">Derive</span> struct <span class="container">{
    *<span class="type">Base</span>
    ...
}</span></span>
</code></pre><p>这个时候Derive的初始化需要提供一个Base的指针，它存在的意义类似于C++中的虚基类，很少用到。Go将C++面向对象中一些”黑盒子”放到了台面上来，如this指针(作为一个特殊的参数显现出来)，虚函数表(Go中不允许派生类指针到基类指针的隐式转换，也就无需虚函数表来实现多态)，虚基类(通过显式基类指针，简洁明了的实现了这一需求)。</p>
<h3 id="3-_接口">3. 接口</h3><h4 id="a-_非侵入式接口">a. 非侵入式接口</h4><p>侵入式接口是指实现类需要明确声明实现了某个接口，目前C++/Java等语言均为侵入式接口。这类接口的缺点是类的实现方需要知道需求方需要的接口，并提前实现这些接口。这给类设计带来很大困难，因为设计类的时候，你并不知道也不应该关心它会被怎么使用。</p>
<p>GO中的接口是非侵入式的，接口与类分离，类只需要关心它应该有那些功能(函数)，而无需操心其应该满足哪些接口(契约)，<strong>一个类只要实现了某个接口的所有函数，那么它就实现了这个接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IReader <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">    Write(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IStream <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">    Write(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IDevice <span class="keyword">interface</span>&#123;</span><br><span class="line">    Name() <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File定义无需指定实现接口，直接实现其方法即可</span></span><br><span class="line"><span class="comment">// 根据File类的实现，可以得到：</span></span><br><span class="line"><span class="comment">// File类实现了 IDevice接口</span></span><br><span class="line"><span class="comment">// File*类实现了以上所有接口</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (f *File) Read(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (f *File) Write(buf []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (f File) Name() (s <span class="typename">string</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go的非侵入式接口的意义：</p>
<ol>
<li>Go语言的标准库，没有复杂的继承树，接口与类之间是平坦的，无需绘制类库的继承树图。</li>
<li>实现类的时候，只需要关心自己应该提供哪些方法(自身功能)，不用再纠结实现哪些接口，接口由使用方按需定义，而不用事前规划。</li>
<li>不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。</li>
</ol>
<h4 id="b-_接口赋值">b. 接口赋值</h4><p>接口赋值分为两种：将对象赋值给接口和将接口赋值给接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将对象赋值给接口</span></span><br><span class="line"><span class="comment">// 赋值条件：对象需实现该接口</span></span><br><span class="line">f := File&#123;&#125;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> I1 IDevice = f</span><br><span class="line"><span class="comment">// ok. Go会根据 func (f File) Name() 自动生成 func (f *file) Name()方法</span></span><br><span class="line"><span class="keyword">var</span> I2 IDevice = &amp;f</span><br><span class="line"><span class="comment">// error. File类实现的IFile接口中，有函数的接收者为File*</span></span><br><span class="line"><span class="comment">// func (f *File) Read(buf []byte) 不能转化为 func (f File) Read(buf []byte)</span></span><br><span class="line"><span class="comment">// 因为前者可能在函数中改变f，后者不能，可能造成语义上的不一致</span></span><br><span class="line"><span class="keyword">var</span> I3 IFile = f</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> I4 IFile = &amp;f</span><br><span class="line"><span class="comment">// 赋值完成之后 可通过接口直接调用对象方法</span></span><br><span class="line">I1.Name()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将接口赋值给接口</span></span><br><span class="line"><span class="comment">// 赋值条件：左值接口需是右值接口的子集</span></span><br><span class="line"><span class="keyword">var</span> I5 IReader = I1 <span class="comment">// error</span></span><br><span class="line"><span class="keyword">var</span> I6 IFile   = I3 <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> I7 IReader = I3 <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h4 id="c-_接口查询">c. 接口查询</h4><p>既然我们可以将对象或者接口赋值给接口，那么也应该有方法能让我们从一个接口查询出其指向对象的类型信息和接口信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f := File&#123;&#125;</span><br><span class="line"><span class="comment">// 接口查询</span></span><br><span class="line"><span class="keyword">var</span> I1 IDevice = f</span><br><span class="line"><span class="comment">// 判断接口I1指向的对象是否实现了IFile接口</span></span><br><span class="line">I2, ok := I1.(IFile) <span class="comment">// ok = false File类型没有实现IFile接口 File*类型实现了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型查询</span></span><br><span class="line"><span class="comment">// 方法一 type assertions</span></span><br><span class="line">f2, ok := I1.(File) <span class="comment">// ok = true</span></span><br><span class="line"><span class="comment">// 方法二 type switch</span></span><br><span class="line"><span class="comment">// X.(type)方法只能用在switch语句中</span></span><br><span class="line"><span class="keyword">switch</span>(I1.(<span class="keyword">type</span>))&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="typename">int</span>:       <span class="comment">// 如果I1指向的对象为int</span></span><br><span class="line">    <span class="keyword">case</span> File:      <span class="comment">// 如果I1指向的对象为File</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="d-_接口组合">d. 接口组合</h4><p>前面的IFile接口定义等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</span><br><span class="line">    IReader</span><br><span class="line">    IWriter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口组合可以以更简便的方式复用接口类似于类继承，只不过没有成员变量。</p>
<h4 id="e-_任意类型">e. 任意类型</h4><p>在Go中的任何对象都满足空接口<code>interface{}</code>，所以<code>interface{}</code>可以指向任何对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">interface</span>&#123;&#125; = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">var</span> v3 <span class="keyword">interface</span>&#123;&#125; = <span class="keyword">struct</span>&#123; x <span class="typename">int</span> &#125;&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v4 <span class="keyword">interface</span>&#123;&#125; = v3</span><br></pre></td></tr></table></figure>
<p><code>interface{}</code>比C++中的<code>void*</code>更强大，比<code>template&lt;&gt;</code>更灵活，结合接口查询和反射，构建底层代码变得非常容易。</p>
<h3 id="4-_访问控制">4. 访问控制</h3><p>Go中没有private public等关键字，要使符号对其它包可见，则需要将该符号定义为大写字母开头。如Base中的Name能被其它引用了Base所在包的代码访问到，而Derive中age则不能。Go中没有类级别的访问控制。</p>

      
    </div>
    <footer>
<!--        -->
        
  
  <div class="categories">
    <a href="/categories/go/">go</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/go/">go</a>
  </div>

        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
<!--   <h1 class="title">留言</h1> -->


    <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="2016/09/go-basic/" data-title="Go 基础特性" data-url="http://wudaijun.com/2016/09/go-basic/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wudaijun"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


  
</section>



</div></div>
  		<aside id="sidebar" class="alignright">
   <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:wudaijun.com">
  </form>
</div> 

  
<div class="widget tag">
  <h3 class="title">分类</h3>
<!--   
	
		<li><a href="/categories/c-c/">c/c++</a><small>5</small></li>
	
  
	
		<li><a href="/categories/database/">database</a><small>4</small></li>
	
  
	
		<li><a href="/categories/erlang/">erlang</a><small>22</small></li>
	
  
	
		<li><a href="/categories/gameserver/">gameserver</a><small>20</small></li>
	
  
	
		<li><a href="/categories/go/">go</a><small>1</small></li>
	
  
	
		<li><a href="/categories/lua/">lua</a><small>1</small></li>
	
  
	
		<li><a href="/categories/network/">network</a><small>3</small></li>
	
  
	
		<li><a href="/categories/os/">os</a><small>2</small></li>
	
  
	
		<li><a href="/categories/other/">other</a><small>1</small></li>
	
  
	
		<li><a href="/categories/python/">python</a><small>1</small></li>
	
  
	
		<li><a href="/categories/tool/">tool</a><small>3</small></li>
	
  
	
		<li><a href="/categories/unity/">unity</a><small>3</small></li>
	
  
	
		<li><a href="/categories/web/">web</a><small>1</small></li>
	
   -->
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gameserver/">gameserver</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">os</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">1</span></li></ul> 
</div>
 


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">2016年09月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">2016年08月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">2016年07月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">2016年06月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">2016年05月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">2016年04月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">2016年03月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">2016年02月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">2016年01月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">2015年12月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">2015年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">2015年10月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">2015年09月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">2015年08月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">2015年07月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">2015年06月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">2015年05月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">2015年04月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">2015年03月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">2015年02月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">2015年01月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">2014年12月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">2014年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">2014年10月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">2014年09月</a><span class="archive-list-count">1</span></li></ul>
  </div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/c-c/" style="font-size: 15.71px;">c/c++</a> <a href="/tags/distribution/" style="font-size: 14.29px;">distribution</a> <a href="/tags/erlang/" style="font-size: 20px;">erlang</a> <a href="/tags/firefly/" style="font-size: 11.43px;">firefly</a> <a href="/tags/gameserver/" style="font-size: 10px;">gameserver</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/kbengine/" style="font-size: 11.43px;">kbengine</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lua/" style="font-size: 17.14px;">lua</a> <a href="/tags/mongodb/" style="font-size: 14.29px;">mongodb</a> <a href="/tags/multi-thread/" style="font-size: 12.86px;">multi-thread</a> <a href="/tags/ngserver/" style="font-size: 18.57px;">ngserver</a> <a href="/tags/os/" style="font-size: 11.43px;">os</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/python/" style="font-size: 14.29px;">python</a> <a href="/tags/skynet/" style="font-size: 14.29px;">skynet</a> <a href="/tags/tcp-ip/" style="font-size: 12.86px;">tcp/ip</a> <a href="/tags/tool/" style="font-size: 11.43px;">tool</a> <a href="/tags/unity/" style="font-size: 12.86px;">unity</a> <a href="/tags/web/" style="font-size: 10px;">web</a>
  </div>
</div>

</aside>
           <div class="clearfix"></div>
      </div>
  	
   <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 wudaijun
  
</div>
<div class="alignright">
	<a href="https://github.com/pengloo53/light-ch">Hexo theme</a>
</div>
<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?380ce5c81e06b297c4a75c0c66825c3d";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>
<!--  -->


</body>
</html>