<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
  <title>NGServer 消息的注册与回调 | wudaijun&#39;s blog | Coding is Funny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="ngserver">
  <meta name="description" content="在前面Service框架的介绍中，提到在GameService的ProcessMsg(UserMessage*)和ProcessMsg(InsideMessage*)中，都完成了消息的回调处理。消息响应函数的注册是在服务初始化(Init())中完成的。需要注册和回调的消息有InsideMessage和UserMessage，对于InsideMessage，响应函数只有一种形式：即为响应服务的成员函">
<meta property="og:type" content="article">
<meta property="og:title" content="NGServer 消息的注册与回调">
<meta property="og:url" content="http://wudaijun.com/2014/11/ngserver-message-callback/index.html">
<meta property="og:site_name" content="wudaijun's blog">
<meta property="og:description" content="在前面Service框架的介绍中，提到在GameService的ProcessMsg(UserMessage*)和ProcessMsg(InsideMessage*)中，都完成了消息的回调处理。消息响应函数的注册是在服务初始化(Init())中完成的。需要注册和回调的消息有InsideMessage和UserMessage，对于InsideMessage，响应函数只有一种形式：即为响应服务的成员函">
<meta property="og:updated_time" content="2016-09-24T08:55:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NGServer 消息的注册与回调">
<meta name="twitter:description" content="在前面Service框架的介绍中，提到在GameService的ProcessMsg(UserMessage*)和ProcessMsg(InsideMessage*)中，都完成了消息的回调处理。消息响应函数的注册是在服务初始化(Init())中完成的。需要注册和回调的消息有InsideMessage和UserMessage，对于InsideMessage，响应函数只有一种形式：即为响应服务的成员函">
  
    <link rel="alternative" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  
  <meta name="summary" content="&lt;p&gt;在前面Service框架的介绍中，提到在GameService的&lt;code&gt;ProcessMsg(UserMessage*)&lt;/code&gt;和&lt;code&gt;ProcessMsg(InsideMessage*)&lt;/code&gt;中，都完成了消息的回调处理。消息响应函数的注册是在服务初始化(Init())中完成的。需要注册和回调的消息有InsideMessage和UserMessage，对于InsideMessage，响应函数只有一种形式：即为响应服务的成员函数。而对于UserMessage，由于UserMessage有Player指针，响应函数则会有多种形式：&lt;/p&gt;">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css?v=1.1.4">
</head>

<body>
  <div id="loading" class="active"></div>

  <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar"><img src="/favicon.png"></a>
        <hgroup class="introduce">
          <h5 class="nickname">wudaijun</h5>
          <a href="mailto:wdjlost@gmail.com" title="wdjlost@gmail.com" class="mail">wdjlost@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://blog.csdn.net/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-contao"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>

      <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>wudaijun&#39;s blog &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

    </div>
  </div>
</aside>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">NGServer 消息的注册与回调</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container">
        <h1 class="title">NGServer 消息的注册与回调</h1>
        
        

    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用消息注册与回调"><span class="post-toc-number">1.</span> <span class="post-toc-text">使用消息注册与回调</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DelegateManager"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">DelegateManager</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-ngserver-message-callback" 
  class="post-article article-type-post" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">NGServer 消息的注册与回调</h1>
        <div class="post-meta">
            <time datetime="2014-11-04T16:00:00.000Z" itemprop="datePublished" class="post-time">
  2014-11-05
</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/gameserver/">gameserver</a></li></ul>



        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>在前面Service框架的介绍中，提到在GameService的<code>ProcessMsg(UserMessage*)</code>和<code>ProcessMsg(InsideMessage*)</code>中，都完成了消息的回调处理。消息响应函数的注册是在服务初始化(Init())中完成的。需要注册和回调的消息有InsideMessage和UserMessage，对于InsideMessage，响应函数只有一种形式：即为响应服务的成员函数。而对于UserMessage，由于UserMessage有Player指针，响应函数则会有多种形式：</p>
<a id="more"></a>
<ol>
<li>作为注册Service的成员函数，并且将Player作为第一个参数。这常在登录和注册流程中发生，如 <code>LoginService::OnPlayerLogin(Player&amp; player, const C2S_Login&amp; msg)</code>。 登录和注册的验证流程在LoginService中统一处理。</li>
<li>作为Player的成员函数，当Player登录成功后，此时客户端与服务器进行的交互都是基于业务逻辑的，因此应在Player的成员函数处理。如 <code>Player::OnEnterGate(const C2S_EnterGate&amp; msg)</code></li>
<li>其它响应函数，如全局函数。</li>
</ol>
<p>事实上，基于UserMessage中的Player指针，我们可以实现上面的调用方式，现在就需要通过一种或多种的注册回调机制，来实现对各种响应函数形式的注册和回调。</p>
<h2 id="使用消息注册与回调">使用消息注册与回调</h2><p>消息的注册通过指定消息ID和消息响应函数来完成，注册函数主要有如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MapService::Init()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 注册用户消息 响应函数原型： void MapService::OnWorldChat(Player* player, C2S_WorldChat&amp; msg)</span></span><br><span class="line">	RegistPlayer(MsgId::kC2S_WorldChat, &amp;MapService::OnWorldChat, <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// 注册用户消息 响应函数原型： void Player::OnEnterGate(const C2S_EnterGate&amp; msg)</span></span><br><span class="line">	RegistPlayer(yuedong::protocol::kC2S_EnterGate, &amp;Player::OnEnterGate);</span><br><span class="line">	<span class="comment">// 注册用户消息 响应函数原型：void Test(Player* player, Test);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注册响应服务之间的内部消息</span></span><br><span class="line">	RegistInside(SSMsgId::kSS_PlayerLogin, &amp;MapService::OnPlayerLogin, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面注册了三种主要消息，通过RegistPlayer注册玩家消息，通过RegistInside注册内部消息。RegistPlayer通过模板推导和函数重载完成了三种响应函数原型的注册。下面以RegistPlayer为例，讲述消息注册机的内部机制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GameService : <span class="keyword">public</span> Service</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// 消息注册</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 注册第一个参数为Player*的回调函数 </span></span><br><span class="line">	<span class="comment">// 当 F 模板推导为全局函数时，第一个参数为Player*  </span></span><br><span class="line">	<span class="comment">//	如 void Test(Player*, C2S_Test&amp;)</span></span><br><span class="line">	<span class="comment">// 当 F 模板推导为Player成员函数时，将解析出来的Player*直接作为this指针调用该成员函数</span></span><br><span class="line">	<span class="comment">//  如 Player::OnEnterGate(C2S_EnterGate&amp;)</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> MsgEnum, <span class="keyword">typename</span> F&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegistPlayer</span><span class="params">(MsgEnum msgid, F f)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">	    _calltype[(<span class="keyword">uint16_t</span>)msgid] = cbPlayerAgent;</span><br><span class="line">	    _player_delegate.Regist((<span class="keyword">uint16_t</span>)msgid, f);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注册第一个参数为Player*的MapService成员函数 </span></span><br><span class="line">	<span class="comment">//	如MapService::OnWorldChat(Player*, C2S_WorldChat&amp;)</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> MsgEnum, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ObjT&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegistPlayer</span><span class="params">(MsgEnum msgid, F f, ObjT* obj)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">	    _calltype[(<span class="keyword">uint16_t</span>)msgid] = cbPlayerAgent;</span><br><span class="line">	    _player_delegate.Regist((<span class="keyword">uint16_t</span>)msgid, f, obj);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DelegateManager&lt;<span class="built_in">std</span>::pair&lt;Player*, ProtocolReader&amp;&gt;&gt; _player_delegate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>bool MapService::ProcessMsg(UserMessage* msg)</code>中回调响应函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MapService::ProcessMsg(UserMessage* msg)</span><br><span class="line">&#123;</span><br><span class="line">    UserMessageT&lt;PlayerPtr&gt;* msgT = <span class="keyword">dynamic_cast</span>&lt;UserMessageT&lt;PlayerPtr&gt;*&gt;(msg);</span><br><span class="line">    <span class="keyword">if</span> (msgT == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    PlayerPtr player = msgT-&gt;GetClient();</span><br><span class="line">    <span class="keyword">int32_t</span> sid = player-&gt;GetSid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是发送给当前服务的消息 转发</span></span><br><span class="line">    <span class="keyword">if</span> (sid != _sid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceManager::Send(sid, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        player-&gt;Offline();</span><br><span class="line">        _session_manager-&gt;RemoveSession(player-&gt;GetConnId());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ProtocolReader <span class="title">reader</span><span class="params">(msg-&gt;_data, msg-&gt;_len)</span></span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> msgid = reader.ReadMsgId();</span><br><span class="line">    CallBackType cbType = _calltype[msgid];</span><br><span class="line">    <span class="keyword">switch</span> (cbType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> cbPlayerDelegate:</span><br><span class="line">        <span class="keyword">auto</span> arg = <span class="built_in">std</span>::pair&lt;Player*, ProtocolReader&amp;&gt;(player.get(), reader);</span><br><span class="line">        _player_delegate.Call(msgid, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case ...</span></span><br><span class="line">	<span class="comment">//	break;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>bool MapService::ProcessMsg(UserMessage* msg)</code>中，取出UserMessage中的PlayerPtr指针，将其与ProtocolReader一起打包成std::pair，而事实上，这个pair才是最终的解码器，在这一点上，也可以专门写一个UserMessageReader类来读取UserMessage的Player指针，以及消息数据。后面也会向这方面改进。可以注意到这个pair也是 _player_delegate的DelegateManager模板参数,下面介绍DelegateManager.</p>
<h4 id="DelegateManager">DelegateManager</h4><p>DelegateManager是一个模板类，它第一个模板参数Decoder，是解码器</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">AutoCall</span>.h</span><br><span class="line"><span class="title">template</span>&lt;typename <span class="type">Decoder</span>, size_t <span class="type">Capacity</span> = <span class="number">65535</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DelegateManager</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    typedef typename <span class="type">IDelegate</span>&lt;<span class="type">Decoder</span>&gt;* <span class="type">DelegatePtr</span>;</span><br><span class="line">    <span class="type">DelegatePtr</span> _caller[<span class="type">Capacity</span>];</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="type">DelegateManager</span><span class="container">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        memset<span class="container">(<span class="title">_caller</span>, 0, <span class="title">sizeof</span>(<span class="title">_caller</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="type">DelegateManager</span><span class="container">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        for <span class="container">(<span class="title">size_t</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="type">Capacity</span>; <span class="title">i</span>++)</span></span><br><span class="line">        &#123;</span><br><span class="line">            if <span class="container">(<span class="title">_caller</span>[<span class="title">i</span>] != <span class="title">nullptr</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                delete _caller[i];</span><br><span class="line">                _caller[i] = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool <span class="type">Call</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">Decoder</span>&amp; <span class="title">s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if <span class="container">(<span class="title">_caller</span>[<span class="title">id</span>] != <span class="title">nullptr</span>)</span></span><br><span class="line">            return _caller[id]-&gt;<span class="type">Call</span><span class="container">(<span class="title">s</span>)</span>;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 内部注册接口</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">DelegatePtr</span> <span class="title">dp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if <span class="container">(<span class="title">_caller</span>[<span class="title">id</span>] != <span class="title">nullptr</span>)</span></span><br><span class="line">            delete _caller[id];</span><br><span class="line"></span><br><span class="line">        _caller[id] = dp;</span><br><span class="line">        return dp;</span><br><span class="line">    &#125;</span><br><span class="line">// 外部具体注册方式 省略了函数原型不完全匹配时的注册接口 此时参数类型需要显式给出 在调用时隐含转换</span><br><span class="line">public:</span><br><span class="line">	// 完全匹配 全局函数</span><br><span class="line">    template&lt;typename <span class="type">R</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(*<span class="title">f</span>)</span><span class="container">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate0</span>&lt;<span class="type">Decoder</span>&gt;(<span class="title">f</span>)</span>);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">T1</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(*<span class="title">f</span>)</span><span class="container">(<span class="type">T1</span>)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate1</span>&lt;<span class="type">Decoder</span>, <span class="type">T1</span>&gt;(<span class="title">f</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">T1</span>, typename <span class="type">T2</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(*<span class="title">f</span>)</span><span class="container">(<span class="type">T1</span>, <span class="type">T2</span>)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate2</span>&lt;<span class="type">Decoder</span>, <span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="title">f</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 完全匹配 成员函数</span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">ObjT</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(<span class="type">ObjT</span>::*<span class="title">f</span>)</span><span class="container">()</span>, <span class="type">ObjT</span>* obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::function&lt;<span class="type">R</span><span class="container">()</span>&gt; bindf = std::bind<span class="container">(<span class="title">f</span>, <span class="title">obj</span>)</span>;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate0</span>&lt;<span class="type">Decoder</span>&gt;(<span class="title">bindf</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">ObjT</span>, typename <span class="type">T1</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(<span class="type">ObjT</span>::*<span class="title">f</span>)</span><span class="container">(<span class="type">T1</span>)</span>, <span class="type">ObjT</span>* obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::function&lt;<span class="type">R</span><span class="container">(<span class="type">T1</span>)</span>&gt; bindf = std::bind<span class="container">(<span class="title">f</span>, <span class="title">obj</span>, <span class="title">std</span>::<span class="title">placeholders</span>::<span class="title">_1</span>)</span>;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate1</span>&lt;<span class="type">Decoder</span>, <span class="type">T1</span>&gt;(<span class="title">bindf</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">ObjT</span>, typename <span class="type">T1</span>, typename <span class="type">T2</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(<span class="type">ObjT</span>::*<span class="title">f</span>)</span><span class="container">(<span class="type">T1</span>, <span class="type">T2</span>)</span>, <span class="type">ObjT</span>* obj)</span><br><span class="line">    &#123;</span><br><span class="line">        std::function&lt;<span class="type">R</span><span class="container">(<span class="type">T1</span>, <span class="type">T2</span>)</span>&gt; bindf = std::bind<span class="container">(<span class="title">f</span>, <span class="title">obj</span>, <span class="title">std</span>::<span class="title">placeholders</span>::<span class="title">_1</span>, <span class="title">std</span>::<span class="title">placeholders</span>::<span class="title">_2</span>)</span>;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate2</span>&lt;<span class="type">Decoder</span>, <span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="title">bindf</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 完全匹配  成员函数  该成员函数的this指针从<span class="type">Decoder</span>中读取</span><br><span class="line">    // 这里必须要使用bind函数 预留出this指针的位置</span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">ObjT</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(<span class="type">ObjT</span>::*<span class="title">f</span>)</span><span class="container">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        auto bindf = std::bind<span class="container">(<span class="title">f</span>, <span class="title">placeholders</span>::<span class="title">_1</span>)</span>;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate1</span>&lt;<span class="type">Decoder</span>, <span class="type">ObjT</span>*&gt;(<span class="title">bindf</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">ObjT</span>, typename <span class="type">T1</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(<span class="type">ObjT</span>::*<span class="title">f</span>)</span><span class="container">(<span class="type">T1</span>)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        auto bindf = std::bind<span class="container">(<span class="title">f</span>, <span class="title">placeholders</span>::<span class="title">_1</span>, <span class="title">placeholders</span>::<span class="title">_2</span>)</span>;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate2</span>&lt;<span class="type">Decoder</span>, <span class="type">ObjT</span>*, <span class="type">T1</span>&gt;(<span class="title">bindf</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename <span class="type">R</span>, typename <span class="type">ObjT</span>, typename <span class="type">T1</span>, typename <span class="type">T2</span>&gt;</span><br><span class="line">    <span class="type">DelegatePtr</span> <span class="type">Regist</span><span class="container">(<span class="title">uint16_t</span> <span class="title">id</span>, <span class="type">R</span>(<span class="type">ObjT</span>::*<span class="title">f</span>)</span><span class="container">(<span class="type">T1</span>, <span class="type">T2</span>)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        auto bindf = std::bind<span class="container">(<span class="title">f</span>, <span class="title">placeholders</span>::<span class="title">_1</span>, <span class="title">placeholders</span>::<span class="title">_2</span>, <span class="title">placeholders</span>::<span class="title">_3</span>)</span>;</span><br><span class="line">        return <span class="type">Regist</span><span class="container">(<span class="title">id</span>, <span class="type">CreateDelegate3</span>&lt;<span class="type">Decoder</span>, <span class="type">ObjT</span>*, <span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="title">bindf</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>DelegateManager管理所有消息ID到消息响应的映射，并提供注册和回调结果。<br>Regist的多种重载识别出需要创建的Delegate对象，由DelegateManager统一管理。</p>
<p>注册主要通过Regist函数的重载和模板推导来进行三种注册方式(实际上不止三种)：全局函数，Service成员函数，Player成员函数。</p>
<p>DelegateManager中，通过Delegate类来代理响应函数。CreateDelegate用于创建响应函数对应的Delegate：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoCall.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Decoder, <span class="keyword">typename</span> FuncT&gt;</span><br><span class="line">IDelegate&lt;Decoder&gt;* CreateDelegate0(FuncT f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Delegate0&lt;Decoder, FuncT&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Decoder, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> FuncT&gt;</span><br><span class="line">IDelegate&lt;Decoder&gt;* CreateDelegate1(FuncT f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Delegate1&lt;Decoder, T1, FuncT&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Decoder, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> FuncT&gt;</span><br><span class="line">IDelegate&lt;Decoder&gt;* CreateDelegate2(FuncT f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Delegate2&lt;Decoder, T1, T2, FuncT&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的Delegate，需要保存回调函数，并提供调用接口Call:</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">template <span class="variable">&lt;typename Decoder&gt;</span></span><br><span class="line">class IDelegate</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~IDelegate()&#123;&#125;</span><br><span class="line">    virtual bool Call(Decoder&amp; s) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span>    默认的Delegate，所有参数都通过Decode全局函数解码得出    <span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">// 0个参数的响应函数</span><br><span class="line">template<span class="variable">&lt;typename Decoder, typename FuncT&gt;</span></span><br><span class="line">class Delegate0 : public IDelegate <span class="variable">&lt; Decoder &gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncT _func;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Delegate0(FuncT func) :</span><br><span class="line">        _func(func)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool Call(Decoder&amp; s) override</span><br><span class="line">    &#123;</span><br><span class="line">        _func();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 1个参数的响应函数</span><br><span class="line">template<span class="variable">&lt;typename Decoder, typename T1, typename FuncT&gt;</span></span><br><span class="line">class Delegate1 : public IDelegate <span class="variable">&lt; Decoder &gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncT _func;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Delegate1(FuncT func) :</span><br><span class="line">        _func(func)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool Call(Decoder&amp; s) override</span><br><span class="line">    &#123;</span><br><span class="line">        std::remove_const <span class="variable">&lt; std::remove_reference&lt;T1&gt;</span>::type &gt;::type t1;</span><br><span class="line"></span><br><span class="line">        if (!Decode(s, t1))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        _func(t1);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 2个参数</span><br><span class="line">template<span class="variable">&lt;typename Decoder, typename T1, typename T2, typename FuncT&gt;</span></span><br><span class="line">class Delegate2 : public IDelegate <span class="variable">&lt; Decoder &gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncT _func;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Delegate2(FuncT func) :</span><br><span class="line">        _func(func)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool Call(Decoder&amp; s) override</span><br><span class="line">    &#123;</span><br><span class="line">        std::remove_const<span class="variable">&lt; std::remove_reference&lt;T1&gt;</span>::type &gt;::type t1;</span><br><span class="line">        std::remove_const<span class="variable">&lt; std::remove_reference&lt;T2&gt;</span>::type &gt;::type t2;</span><br><span class="line"></span><br><span class="line">        if (!Decode(s, t1))</span><br><span class="line">            return false;</span><br><span class="line">        if (!Decode(s, t2))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        _func(t1, t2);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Delegate保存回调函数，并且提供调用接口，调用接口Call仅有一个参数，就是解码器，也是DelegateManager的模板参数。对于我们的_player_delegate来说，就是pair<player*, protocolreader&="">。而上面的Delegate类是默认实现，通过Decode全局函数完成对Decoder的解码，在前面消息编解码中提到过，ProtocolReader实现了这样一个接口。而对于我们的pair，需要特例化，方式一是特例化Decode，方式二是特例化Delegate类。我们采用方法二：</player*,></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// AutoCallSpecial.h</span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span>   特例化Decoder: std::pair<span class="variable">&lt;T1, ProtocolReader&amp;&gt;</span> T1是响应函数的第一个参数 其他参数从ProtocolReader中读取  <span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">// 带一个参数 T1</span><br><span class="line">template<span class="variable">&lt;typename T1, typename FuncT&gt;</span></span><br><span class="line">class Delegate1<span class="variable">&lt;std::pair&lt;T1, ProtocolReader&amp;&gt;</span>, T1, FuncT&gt; : public IDelegate <span class="variable">&lt; std::pair&lt;T1, ProtocolReader&amp;&gt;</span> &gt;</span><br><span class="line">&#123;</span><br><span class="line">    FuncT _func;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Delegate1(FuncT f) :</span><br><span class="line">        _func(f)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool Call(std::pair<span class="variable">&lt;T1, ProtocolReader&amp;&gt;</span>&amp; s) override</span><br><span class="line">    &#123;</span><br><span class="line">        _func(s.first);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 带两个参数  第一个参数为T1 第二个参数从ProtocolReader中读取</span><br><span class="line">template <span class="variable">&lt; typename T1, typename T2, typename FuncT &gt;</span> </span><br><span class="line">class Delegate2<span class="variable">&lt;std::pair&lt;T1, ProtocolReader&amp;&gt;</span>, T1, T2, FuncT&gt; : public IDelegate <span class="variable">&lt; std::pair&lt;T1, ProtocolReader&amp;&gt;</span> &gt; </span><br><span class="line">&#123;</span><br><span class="line">    FuncT _func;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Delegate2(FuncT f) :</span><br><span class="line">        _func(f)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool Call(std::pair<span class="variable">&lt;T1, ProtocolReader&amp;&gt;</span>&amp; s) override</span><br><span class="line">    &#123;</span><br><span class="line">        std::remove_const<span class="variable">&lt; std::remove_reference&lt;T2&gt;</span>::type &gt;::type t2;</span><br><span class="line"></span><br><span class="line">        if (!Decode(s.second, t2))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        _func(s.first, t2);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果通过一个UserMessageReader来对UserMessage特殊解码的话，便可以直接特例化Decode，更加简便一些。</p>
<p>AutoCallSpecial.h中还对InsideMessage完成了特例化，而消息的回调方式也不仅限于cbPlayerDelegate一种。添加一种自定义的回调方式也比较简单：</p>
<ol>
<li>先自定义一个解码器，将所需参数包含进去，解码器可以是个自定义类，也可以是个容器或其它，将其作为DelegateManager的模板参数</li>
<li>在CallBackType中添加该回调类型</li>
<li>在对应ProcessMsg中，组建自己的解码器，调用DelegateManager::Call函数</li>
<li>DelegateManager会最终调到 Delegate::Call 因此如果有必要  需要对Delegate进行特例化，保证使用你的解码器能正确解码 或者直接使用默认Delegate类中的Decode方式，特例化全局Decode函数。</li>
</ol>

        </div>
        
        <blockquote class="post-copyright">
            <div class="content">
               这里写留言或版权声明：<a href="/2014/11/ngserver-message-callback/" target="_blank" rel="external">http://wudaijun.com/2014/11/ngserver-message-callback/</a>
            </div>
            <footer>
                <a href="http://wudaijun.com">
                    <img src="/favicon.png" alt="wudaijun">
                    wudaijun
                </a>
            </footer>
        </blockquote>

        

        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngserver/">ngserver</a></li></ul>


            
            <div class="post-share-wrap">
                <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

                <a href="javascript:;" id="share-fab" class="post-share-fab waves-effect waves-circle">
                    <i class="icon icon-share-alt icon-lg"></i>
                </a>
            </div>
            

        </div>
    </div>   

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2014/11/ngserver-message-encoder/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">NGServer 消息的编解码</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2014/10/ngserver-service/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">NGServer Service框架</h4>
      </a>
    </div>
  
</nav>


            
    
<div class="duoshuo">
	<div class="ds-thread" data-thread-key="ngserver-message-callback" data-title="NGServer 消息的注册与回调" data-url="http://wudaijun.com/2014/11/ngserver-message-callback/"></div>
</div>
<script src="/js/embed.min.js?v=1.1.4"></script>
<script src="//cdn.bootcss.com/marked/0.3.6/marked.min.js" async="async"></script>
<script>
var duoshuoQuery = {short_name:'wudaijun', theme: 'none'}
</script>




</article>


</div>
  </main>
  <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "NGServer 消息的注册与回调",
    pic: "/favicon.png",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://wudaijun.com/2014/11/ngserver-message-callback/"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


  <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script src="/js/main.min.js?v=1.1.4"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.1.4"></script>





<script src="//s95.cnzz.com/z_stat.php?id=1254033667&web_id=1254033667"></script>





</body>
</html>
