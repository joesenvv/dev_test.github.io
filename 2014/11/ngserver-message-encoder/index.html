<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>NGServer 消息的编解码 | wudaijun&#39;s blog | Coding is Funny</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="ngserver">
    <meta name="description" content="消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。">
<meta name="keywords" content="ngserver">
<meta property="og:type" content="article">
<meta property="og:title" content="NGServer 消息的编解码">
<meta property="og:url" content="http://wudaijun.com/2014/11/ngserver-message-encoder/index.html">
<meta property="og:site_name" content="wudaijun&#39;s blog">
<meta property="og:description" content="消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。">
<meta property="og:updated_time" content="2016-09-24T08:56:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NGServer 消息的编解码">
<meta name="twitter:description" content="消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。">
    
        <link rel="alternate" type="application/atom+xml" title="wudaijun&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/favicon.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">wudaijun</h5>
          <a href="mailto:wdjlost@gmail.com" title="wdjlost@gmail.com" class="mail">wdjlost@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://blog.csdn.net/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-contao"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">NGServer 消息的编解码</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">NGServer 消息的编解码</h1>
        <h5 class="subtitle">
            
                <time datetime="2014-11-04T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2014-11-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/gameserver/">gameserver</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一-消息编码格式"><span class="post-toc-text">一. 消息编码格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二-ProtocolStream"><span class="post-toc-text">二. ProtocolStream</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三-数据类型"><span class="post-toc-text">三. 数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四-ProtocolReader解码推导流程"><span class="post-toc-text">四. ProtocolReader解码推导流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五-自定义消息类型的特例化"><span class="post-toc-text">五. 自定义消息类型的特例化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#六-特例化宏"><span class="post-toc-text">六. 特例化宏</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#七-回到ProtocolReader"><span class="post-toc-text">七. 回到ProtocolReader</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-ngserver-message-encoder"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">NGServer 消息的编解码</h1>
        <div class="post-meta">
            <time class="post-time" title="2014-11-05 00:00:00" datetime="2014-11-04T16:00:00.000Z"  itemprop="datePublished">2014-11-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/gameserver/">gameserver</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。</p>
<a id="more"></a>
<h3 id="一-消息编码格式"><a href="#一-消息编码格式" class="headerlink" title="一. 消息编码格式"></a>一. 消息编码格式</h3><p>NGServer的消息分为首部和消息体，首部共四个字节，包括消息长度(包括首部)和消息ID，各占两个字节。消息体为消息编码后的二进制数据。</p>
<p>在消息体中，针对于不同的数据类型而不同编码。对于POD类型，直接进行内存拷贝，对于非POD类型，如标准库容器，则需要自定义编码格式，以下是几种最常见的数据类型编码：</p>
<p>std::string 先写入字符串长度，占两个字节，再写入字符串内容。<br>std::vector 先写入vector的元素个数(占两个字节)，在对其元素逐个递归编码(如果元素类型为string，则使用string的编码方式)。<br>std::list    编码方式与vector类似<br>T arr[N]    对于这种类型，不需要写入元素个数，因为在消息结构体中指出了固定长度N，因此可以通过模板推导得到N。所以递归写入N个元素T即可。对于简单数据类型T，如T为char时，可以通过模板特例化对其优化。</p>
<h3 id="二-ProtocolStream"><a href="#二-ProtocolStream" class="headerlink" title="二. ProtocolStream"></a>二. ProtocolStream</h3><p>NGServer的消息编解码依靠两个类：ProtocolReader和ProtocolWriter。这两个类派生于ProtocolStream，ProtocolStream简单维护一个用于编码或解码的线性缓冲区，并记录缓冲区的当前状态，如总大小，当前偏移，等等。一个ProtocolStream的缓冲区即代表一条消息，因此它ProtocolReader/ProtocolWriter总是在缓冲区头四个字节中读出或写入消息长度和消息ID。</p>
<p>ProtocolReader从缓冲区中读出消息，也就是解码，由于缓冲区的数据是二进制的，因此我们需要提供需要读出的数据类型。因此ProtocolReader提供的接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::AutoDecode(T&amp; t);</div></pre></td></tr></table></figure>
<p>Decode在缓冲区的当前偏移处，读出数据t，并返回操作结果。而根据T的类型不同，读取方式也不一样，这需要通过模板推导来完成。</p>
<h3 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三. 数据类型"></a>三. 数据类型</h3><p>T的类型概括有四种：</p>
<ul>
<li>基本POD类型，如 int, double, char 等  </li>
<li>标准库非POD类型，如 std::string, std::vector, std::list 等</li>
<li>自定义POD类型，如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct A1</div><div class="line">&#123;</div><div class="line">	char name[36];</div><div class="line">	char pwd[36];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>自定义非POD类型，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct A2</div><div class="line">&#123;</div><div class="line">	string name;</div><div class="line">	vector&lt;int&gt; data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>C数组类型 由于其推导方式不同 因此单独归为一类</li>
</ul>
<p>关于c++ POD类型和std::is_pod，std::is_standard_layout，std::is_trivial等函数，可参见下面两篇博客：</p>
<ol>
<li><a href="http://m.oschina.net/blog/156796" target="_blank" rel="external">http://m.oschina.net/blog/156796</a></li>
<li><a href="http://www.cnblogs.com/hancm/p/3665998.html" target="_blank" rel="external">http://www.cnblogs.com/hancm/p/3665998.html</a></li>
</ol>
<p>这里说的POD指的是 std::is_trivial<t\>::value &amp;&amp; std::is_standard_layout<t\>::value</t\></t\></p>
<h3 id="四-ProtocolReader解码推导流程"><a href="#四-ProtocolReader解码推导流程" class="headerlink" title="四. ProtocolReader解码推导流程"></a>四. ProtocolReader解码推导流程</h3><p>推导流程如下：</p>
<p><strong>1.如果T是C数组类型 (std::is_array<t>::value == true)</t></strong>，那么下一个推导模型应该为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, size_t arraySize&gt;</div><div class="line">bool ProtocolReader::DecodeArray(const T (&amp;arr)[arraySize]);</div></pre></td></tr></table></figure>
<p>如此便能推导出数组的元素类型，以及数组的大小</p>
<p>注：std::is_array<t\>用于判别一个类型是否为<strong>C风格数组类型</strong>，对于c++的容器vector，std::is_array<vector<int\>&gt;::value的值为false，因为vector本身也是一个类。</vector<int\></t\></p>
<p>根据我们对C数组的编码方式，下一步我们需要递归通过ProtocolReader::AutoDecode(arr[i])来依次递归对数组元素进行解码。</p>
<p><strong>2.如果T不是C型数组</strong>，那么T是一个类(或基本类型)。此时通过Decode来对该类进行编解码，Decode读取缓冲区数据，对POD类型和预定义的特例化类型(一般是标准库容器)进行读取并解码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::Decode(T&amp; t);</div></pre></td></tr></table></figure>
<p>对于POD类型，无论是基本数据类型或者自定义类型，均无需特例化，直接内存拷贝即可。这也是Decode()的默认实现。而对于标准库中的容器，则可以针对性的模板特例化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::Decode(std::vector&lt;T&gt;&amp; vec);</div></pre></td></tr></table></figure>
<p>而对于最后一种类型，自定义非POD类型，模板自动推导则爱莫能助了，比如对于结构体A2，它的推导流程是: AutoDecode(A2&amp;) -&gt; Decode(A2&amp;) 到了这里，框架无法再推导出A2内部的乾坤了。这就需要A2的定义者提供一个特例化的解码函数AutoDecode(A2&amp;)，为什么不特例化Decode(A2&amp;)呢？因为AutoDecode()是解码的最外层接口，使用者通过自定义的AutoDecode能够获得最大的灵活性。</p>
<p>那么问题来了，由于上面提到的AutoDecode Decode等函数均是ProtocolReader的成员函数，那么AutoDecode(A2&amp;)也应该定义在ProtocolReader中，这样做有两点不足之处：</p>
<ol>
<li>大量的模板特例化会使ProtocolReader变得异常臃肿难读，并且消息的定义和特例化在不同的文件。容易在定义之后忘记特例化。</li>
<li>编译依赖性增大，添加任意一条非POD消息，都需要重新编译整个ProtocolReader.h以及包含它的所有模块。</li>
</ol>
<p>而解决方案就是将类中的模板推导转为全局模板推导AutoDecode，然后自定义类的特例化均在全局中，最后再通过Decode调用ProtocolReader接口进行已知类型的推导。</p>
<p>具体流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/******************* STEP 1 内部自动解码接口 转向全局自动模板推导 **************************/ </div><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::Decode(T&amp; t)</div><div class="line">&#123;</div><div class="line">	// 转向全局推导</div><div class="line">	return AutoDecode(*this, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/****************** STEP 2 通过是否是C数组分发到不同推导接口 ******************************/</div><div class="line">// 全局自动推导 这是全局入口 也是自定义的非POD消息的重载入口</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool AutoDecode(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">	/* </div><div class="line">	*	Serializer是辅助类 它通过 std::is_array&lt;T&gt;::value 的不同值来转调到不同的模板推导接口</div><div class="line">   	*	即 Serializer&lt;true&gt;::DeSerialize(s,t) 和 Serializer&lt;false&gt;::DeSerialize(s,t)</div><div class="line">	*/</div><div class="line">	return Serializer&lt;std::is_array&lt;T&gt;::value&gt;::DeSerialize(s, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/***************** STEP 3 Serializer 完成对C数组和非C数组的分发 *************************/</div><div class="line">/* Serializer对C数组的分发接口</div><div class="line">*	推导出数组元素类型和元素个数</div><div class="line">*	通过DecodeArray进行解码</div><div class="line">*/</div><div class="line">template&lt;typename S, typename T, size_t arraySize&gt;</div><div class="line">bool Serializer&lt;true&gt;::DeSerialize(S&amp; s, T (&amp;t)[arraySize])</div><div class="line">&#123;</div><div class="line">	return DecodeArray(s, t, arraySize);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Serializer对非C数组的分发接口</div><div class="line">*  通过Decode尝试直接解码</div><div class="line">*/</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Serializer&lt;false&gt;::DeSerialize(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">	return Decode(s, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/****************** STEP 4.A 对C数组 T[arraySize] 进行解码 *****************************/</div><div class="line">/*</div><div class="line">*	DecodeArray </div><div class="line">*	对固定长度的数组进行解码</div><div class="line">*/</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool DecodeArray(S&amp; s, T* t, size_t arraySize)</div><div class="line">&#123;</div><div class="line">	uint16_t size = static_cast&lt;uint16_t&gt;(arraySize);</div><div class="line">	for(uint16_t i=0; i&lt;size; i++)</div><div class="line">	&#123;</div><div class="line">		// 递归对元素进行自动解码</div><div class="line">		if(!AutoDecode(s, t[i]))</div><div class="line">			return false;</div><div class="line">	&#125;</div><div class="line">	return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 对基本类型的C数组特例化 直接内存拷贝</div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, int* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(int)); &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, float* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(float)); &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, double* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(double)); &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, int64_t* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(int64_t)); &#125;</div><div class="line"></div><div class="line">/*********************** STEP 4.B 对非C数组 进行直接解码 *******************************/</div><div class="line">// 默认解码 对于POD类型 直接内存拷贝</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Decode(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">    static_assert(std::is_trivial&lt;T&gt;::value, &quot;is not trivial. need to customize&quot;);</div><div class="line">    static_assert(std::is_standard_layout&lt;T&gt;::value, &quot;is not standard_layout. need to customize&quot;);</div><div class="line">    return s.Read((void*)&amp;t, sizeof(t));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 预定义特例化</div><div class="line">// 对string的解码 在ProtocolReader中完成 此时类型已确定</div><div class="line">template&lt;typename S&gt;</div><div class="line">bool Decode(S&amp; s, std::string&amp; t)&#123; return s.Read(t);  &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool Decode(S&amp; s, std::wstring&amp; t)&#123; return s.Read(t);	&#125;</div><div class="line"></div><div class="line">// 对标准库容器的解码 由于标准容器元素类型可能仍为自定义类型，因此需要继续递归解码</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Decode(S&amp; s, std::vector&lt;T&gt;&amp; t)&#123; return DecodeArray(s, t); &#125;</div><div class="line"></div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Decode(S&amp; s, std::list&lt;T&gt;&amp; t)&#123; return DecodeArray(s, t); &#125;</div><div class="line"></div><div class="line">// 解码动态长度容器 </div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool DecodeArray(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">    uint16_t size;</div><div class="line">    if (s.Read(size))</div><div class="line">    &#123;</div><div class="line">        for (uint16_t i = 0; i &lt; size; i++)</div><div class="line">        &#123;</div><div class="line">            T::value_type v;</div><div class="line">			// 逐个对元素进行自动解码</div><div class="line">            if (!AutoDecode(s, v))</div><div class="line">                return false;</div><div class="line">            t.push_back(v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，对数组元素或标准库容器元素解码时，都调用AutoDecode，这是因为如果容器元素是用户自定义的非POD类型，那么可以通过用户重载的AutoDecode进行正确解码。总之，对于未知类型，都应该通过AutoDecode确保用户自定义类型得到正确解码。而Decode只针对于两种类型：POD类型和标准库容器类型，对于前者默认内存拷贝，对于后者通过AutoDecode对元素逐个解码。如果用户没有提供自定义类型的AutoDecode特例化，那么Decode判断其POD类型并执行内存拷贝，如果该类型不是POD类型，那么static_assert将在编译器给出错误：”is not trivial. need to customize” 或 “is not standard layout. need to customize”。<br>而C数组通过在AutoDecode转向分支DecodeArray，DecodeArray完成元素个数解析之后，也通过AutoDecode对元素递归解码。</p>
<h3 id="五-自定义消息类型的特例化"><a href="#五-自定义消息类型的特例化" class="headerlink" title="五. 自定义消息类型的特例化"></a>五. 自定义消息类型的特例化</h3><p>自定义的非POD消息类型A2的特例化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bool AutoDecode(ProtocolReader&amp; s, A2&amp; t)</div><div class="line">&#123;</div><div class="line">	return AutoDecode(s, t.name) &amp;&amp; AutoDecode(s, t.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是全部特例化，它特例化了解码类ProtocolReader和解码类型A2。而自动化模板推导中使用typename S来模板化编解码类，这是为了提高灵活性，让全局自动模板推导框架可以用于多种编解码类。</p>
<p>如果自定义消息类更复杂一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct A3</div><div class="line">&#123;</div><div class="line">	std::string str;</div><div class="line">	A2 a2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此时A3为复合的自定义非POD类型，如果只为A3提供特例化而忘了给A2特例化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bool AutoDecode(ProtocolReader&amp; s, A3&amp; t)</div><div class="line">&#123;</div><div class="line">	return AutoDecode(s, t.str) &amp;&amp; AutoDecode(s, t.a2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么 <code>AutoDecode(s, t.str)</code>能够解码成功，而<code>AutoDecode(s, t.a2)</code>，则会失败。因此最好在定义任何一个与客户端交互的非POD结构体时，都需要提供对应编解码规则。而不是在特例化消息的时候才去注意其成员有无非POD类型需要特例化。</p>
<h3 id="六-特例化宏"><a href="#六-特例化宏" class="headerlink" title="六. 特例化宏"></a>六. 特例化宏</h3><p>编码的推导过程和解码大同小异，只不过最终是写入缓冲区而不是读取缓冲区。NGServer还有一个ProtocolSize类，用于获取消息编码之后的大小，推导流程也和编解码流程一致。目前没有什么太大的作用。因此实际上在特例化自定义类的编解码规则时，需要同时提供AutoEncode，AutoDecode，AutoMsgSize三个全局函数。这样在消息比较多时，编写对应编解码规则是一件比较麻烦的事情，并且容易出错。</p>
<p>因此可以对这些编解码特例化提供一个宏，方便定义其编解码规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#define AUTOCUSTOMMSG1(T, v1) \</div><div class="line">    bool Encode(ProtocolWriter&amp; s, const T&amp; t)&#123; \</div><div class="line">        return AutoEncode(s, t.v1); &#125; \</div><div class="line">    \</div><div class="line">    bool Decode(ProtocolReader&amp; s,  T&amp; t)&#123; \</div><div class="line">        return AutoDecode(s, t.v1); &#125; \</div><div class="line">    \</div><div class="line">    uint32_t GetMsgSize(ProtocolSize&amp; s, const T&amp; t )&#123; \</div><div class="line">        return AutoMsgSize(s, t.v1); &#125; </div><div class="line"></div><div class="line">#define AUTOCUSTOMMSG2(T, v1, v2) \</div><div class="line">    bool Encode(ProtocolWriter&amp; s, const T&amp; t)&#123; \</div><div class="line">        return AutoEncode(s, t.v1) &amp;&amp; AutoEncode(s, t.v2); &#125; \</div><div class="line">    \</div><div class="line">    bool Decode(ProtocolReader&amp; s,  T&amp; t)&#123; \</div><div class="line">        return AutoDecode(s, t.v1) &amp;&amp; AutoDecode(s, t.v2); &#125; \</div><div class="line">    \</div><div class="line">    uint32_t GetMsgSize(ProtocolSize&amp; s, const T&amp; t )&#123; \</div><div class="line">        return AutoMsgSize(s, t.v1) + AutoMsgSize(s, t.v2); &#125; </div><div class="line"></div><div class="line">#define AUTOCUSTOMMSG3(T, v1, v2, v3) \ </div><div class="line">......</div></pre></td></tr></table></figure>
<p>如此，对于A2，我们只需在协议cpp文件添加：</p>
<pre><code>AUTOCUSTOMMSG2(A2, name, data);
</code></pre><p>即可。</p>
<h3 id="七-回到ProtocolReader"><a href="#七-回到ProtocolReader" class="headerlink" title="七. 回到ProtocolReader"></a>七. 回到ProtocolReader</h3><p>ProtocolReader通过Decode函数转向全局模板推导，最后再回到ProtocolReader进行缓冲读取，由于ProtocolReader缓冲区对应于一条消息，因此解码的缓冲区offset偏移初始化为4(前四个字节为消息头部)。它提供基本类型和string的读取，最后附上主要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">class ProtocolReader : public ProtocolStream</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ProtocolReader(char* buf, uint32_t len) :</div><div class="line">        ProtocolStream(buf, len)&#123;&#125;</div><div class="line"></div><div class="line">    template&lt;typename T&gt;</div><div class="line">    bool Decode(T&amp; t)</div><div class="line">    &#123;</div><div class="line">        return AutoDecode(*this, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 读取二进制数据</div><div class="line">    bool Read(void* ptr, uint32_t len)</div><div class="line">    &#123;</div><div class="line">        if (Remain() &gt;= len)</div><div class="line">        &#123;</div><div class="line">            memcpy(ptr, _buf + _offset, len);</div><div class="line">            _offset += len;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 读取基本类型的数据</div><div class="line">    inline bool Read(char&amp; v)    &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int8_t&amp; v)  &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint8_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int16_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint16_t&amp; v)&#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int32_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint32_t&amp; v)&#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int64_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint64_t&amp; v)&#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(float&amp; v)   &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(double&amp; v)  &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line"></div><div class="line">    // 对string解码</div><div class="line">    inline bool Read(std::string&amp; v)     &#123; return ReadString(v); &#125;</div><div class="line">    inline bool Read(std::wstring&amp; v)    &#123; return ReadString(v); &#125;</div><div class="line"></div><div class="line">    // 读取头部和消息ID</div><div class="line">    inline uint16_t ReadHead()</div><div class="line">    &#123;</div><div class="line">        uint16_t* h = (uint16_t*)_buf;</div><div class="line">        return *h;</div><div class="line">    &#125;</div><div class="line">    inline uint16_t ReadMsgId()</div><div class="line">    &#123;</div><div class="line">        uint16_t* h = (uint16_t*)_buf;</div><div class="line">        return *(h + 1);</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    bool ReadString(std::string&amp; v)</div><div class="line">    &#123;</div><div class="line">        uint16_t len;</div><div class="line">        if (Read(len))</div><div class="line">        &#123;</div><div class="line">            v.clear();</div><div class="line">            if (len &gt; 0)</div><div class="line">            &#123;</div><div class="line">                assert(Remain() &gt;= len*sizeof(char));</div><div class="line">                v.append((const char*)(_buf + _offset), len);</div><div class="line">                _offset += len;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool ReadString(std::wstring&amp; v)</div><div class="line">    &#123;</div><div class="line">        uint16_t len;</div><div class="line">        if (Read(len))</div><div class="line">        &#123;</div><div class="line">            v.clear();</div><div class="line">            if (len &gt; 0)</div><div class="line">            &#123;</div><div class="line">                assert(Remain() &gt;= len*sizeof(wchar_t));</div><div class="line">                v.append((const wchar_t*)(_buf + _offset), len);</div><div class="line">                _offset += len*sizeof(wchar_t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2016-09-24T08:56:43.000Z" itemprop="dateUpdated">2016-09-24 16:56:43</time>
</span><br>


        
        博客均为原创，转载请征得作者同意并注明出处，本文永久链接：<a href="/2014/11/ngserver-message-encoder/" target="_blank" rel="external">http://wudaijun.com/2014/11/ngserver-message-encoder/</a>
        
    </div>
    <footer>
        <a href="http://wudaijun.com">
            <img src="/favicon.png" alt="wudaijun">
            wudaijun
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngserver/">ngserver</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://wudaijun.com/2014/11/ngserver-message-encoder/&title=《NGServer 消息的编解码》 — wudaijun's blog&pic=http://wudaijun.com/favicon.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://wudaijun.com/2014/11/ngserver-message-encoder/&title=《NGServer 消息的编解码》 — wudaijun's blog&source=消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://wudaijun.com/2014/11/ngserver-message-encoder/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《NGServer 消息的编解码》 — wudaijun's blog&url=http://wudaijun.com/2014/11/ngserver-message-encoder/&via=http://wudaijun.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://wudaijun.com/2014/11/ngserver-message-encoder/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2014/11/ngserver-message-callback/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">NGServer 消息的注册与回调</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2014/10/ngserver-service/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">NGServer Service框架</h4>
      </a>
    </div>
  
</nav>



    










    <div id="cloud-tie-wrapper" class="comments cloud-tie-wrapper"></div>
    <script>
    var cloudTieConfig = {
        url: 'http://wudaijun.com/2014/11/ngserver-message-encoder/index.html',
        sourceId: 'ngserver-message-encoder',
        productKey: '02b378614d264e81bca14ffaadf03446',
        target: 'cloud-tie-wrapper',
        pcFiles: [
            '//unpkg.com/hexo-theme-material-indigo@latest/css/cloudTie/pc.css',
            '//unpkg.com/hexo-theme-material-indigo@latest/js/cloudTie/pc.min.js',
        ],
        mobileFiles: [
            '//unpkg.com/hexo-theme-material-indigo@latest/css/cloudTie/mobile.css',
            '//unpkg.com/hexo-theme-material-indigo@latest/js/cloudTie/mobile.min.js'
        ]
    };
    </script>
    <script src="//unpkg.com/hexo-theme-material-indigo@latest/js/cloudTie/loader.min.js"></script>







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>wudaijun &copy; 2015 - 2017</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://wudaijun.com/2014/11/ngserver-message-encoder/&title=《NGServer 消息的编解码》 — wudaijun's blog&pic=http://wudaijun.com/favicon.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://wudaijun.com/2014/11/ngserver-message-encoder/&title=《NGServer 消息的编解码》 — wudaijun's blog&source=消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://wudaijun.com/2014/11/ngserver-message-encoder/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《NGServer 消息的编解码》 — wudaijun's blog&url=http://wudaijun.com/2014/11/ngserver-message-encoder/&via=http://wudaijun.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://wudaijun.com/2014/11/ngserver-message-encoder/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://wudaijun.com/2014/11/ngserver-message-encoder/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };



lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1254033667&web_id=1254033667')

</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
