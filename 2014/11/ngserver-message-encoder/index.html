<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>NGServer 消息的编解码 | wudaijun's blog</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NGServer 消息的编解码</h1><a id="logo" href="/.">wudaijun's blog</a><p class="description">Coding is Funny</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">NGServer 消息的编解码</h1><div class="post-meta"><a href="/2014/11/ngserver-message-encoder/#comments" class="comment-count"><i data-disqus-identifier="2014/11/ngserver-message-encoder/" class="disqus-comment-count"></i>留言</a><p><span class="date">Nov 05, 2014</span><span><a href="/categories/gameserver/" class="category">gameserver</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据“压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。</p>
<a id="more"></a>
<h3 id="一.-消息编码格式">一. 消息编码格式</h3>
<p>NGServer的消息分为首部和消息体，首部共四个字节，包括消息长度(包括首部)和消息ID，各占两个字节。消息体为消息编码后的二进制数据。</p>
<p>在消息体中，针对于不同的数据类型而不同编码。对于POD类型，直接进行内存拷贝，对于非POD类型，如标准库容器，则需要自定义编码格式，以下是几种最常见的数据类型编码：</p>
<p>std::string 先写入字符串长度，占两个字节，再写入字符串内容。 std::vector 先写入vector的元素个数(占两个字节)，在对其元素逐个递归编码(如果元素类型为string，则使用string的编码方式)。 std::list 编码方式与vector类似 T arr[N] 对于这种类型，不需要写入元素个数，因为在消息结构体中指出了固定长度N，因此可以通过模板推导得到N。所以递归写入N个元素T即可。对于简单数据类型T，如T为char时，可以通过模板特例化对其优化。</p>
<h3 id="二.-protocolstream">二. ProtocolStream</h3>
<p>NGServer的消息编解码依靠两个类：ProtocolReader和ProtocolWriter。这两个类派生于ProtocolStream，ProtocolStream简单维护一个用于编码或解码的线性缓冲区，并记录缓冲区的当前状态，如总大小，当前偏移，等等。一个ProtocolStream的缓冲区即代表一条消息，因此它ProtocolReader/ProtocolWriter总是在缓冲区头四个字节中读出或写入消息长度和消息ID。</p>
<p>ProtocolReader从缓冲区中读出消息，也就是解码，由于缓冲区的数据是二进制的，因此我们需要提供需要读出的数据类型。因此ProtocolReader提供的接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::AutoDecode(T&amp; t);</div></pre></td></tr></table></figure>
<p>Decode在缓冲区的当前偏移处，读出数据t，并返回操作结果。而根据T的类型不同，读取方式也不一样，这需要通过模板推导来完成。</p>
<h3 id="三.-数据类型">三. 数据类型</h3>
<p>T的类型概括有四种：</p>
<ul>
<li>基本POD类型，如 int, double, char 等<br>
</li>
<li>标准库非POD类型，如 std::string, std::vector, std::list 等</li>
<li>自定义POD类型，如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct A1</div><div class="line">&#123;</div><div class="line">	char name[36];</div><div class="line">	char pwd[36];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>自定义非POD类型，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct A2</div><div class="line">&#123;</div><div class="line">	string name;</div><div class="line">	vector&lt;int&gt; data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>C数组类型 由于其推导方式不同 因此单独归为一类</li>
</ul>
<p>关于c++ POD类型和std::is_pod，std::is_standard_layout，std::is_trivial等函数，可参见下面两篇博客：</p>
<ol type="1">
<li>http://m.oschina.net/blog/156796</li>
<li>http://www.cnblogs.com/hancm/p/3665998.html</li>
</ol>
<p>这里说的POD指的是 std::is_trivial&lt;T&gt;::value &amp;&amp; std::is_standard_layout&lt;T&gt;::value</p>
<h3 id="四.-protocolreader解码推导流程">四. ProtocolReader解码推导流程</h3>
<p>推导流程如下：</p>
<p><strong>1.如果T是C数组类型 (std::is_array<t>::value == true)</t></strong>，那么下一个推导模型应该为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, size_t arraySize&gt;</div><div class="line">bool ProtocolReader::DecodeArray(const T (&amp;arr)[arraySize]);</div></pre></td></tr></table></figure>
<p>如此便能推导出数组的元素类型，以及数组的大小</p>
<p>注：std::is_array&lt;T&gt;用于判别一个类型是否为<strong>C风格数组类型</strong>，对于c++的容器vector，std::is_array&lt;vector&lt;int&gt;&gt;::value的值为false，因为vector本身也是一个类。</p>
<p>根据我们对C数组的编码方式，下一步我们需要递归通过ProtocolReader::AutoDecode(arr[i])来依次递归对数组元素进行解码。</p>
<p><strong>2.如果T不是C型数组</strong>，那么T是一个类(或基本类型)。此时通过Decode来对该类进行编解码，Decode读取缓冲区数据，对POD类型和预定义的特例化类型(一般是标准库容器)进行读取并解码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::Decode(T&amp; t);</div></pre></td></tr></table></figure>
<p>对于POD类型，无论是基本数据类型或者自定义类型，均无需特例化，直接内存拷贝即可。这也是Decode()的默认实现。而对于标准库中的容器，则可以针对性的模板特例化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::Decode(std::vector&lt;T&gt;&amp; vec);</div></pre></td></tr></table></figure>
<p>而对于最后一种类型，自定义非POD类型，模板自动推导则爱莫能助了，比如对于结构体A2，它的推导流程是: AutoDecode(A2&amp;) -&gt; Decode(A2&amp;) 到了这里，框架无法再推导出A2内部的乾坤了。这就需要A2的定义者提供一个特例化的解码函数AutoDecode(A2&amp;)，为什么不特例化Decode(A2&amp;)呢？因为AutoDecode()是解码的最外层接口，使用者通过自定义的AutoDecode能够获得最大的灵活性。</p>
<p>那么问题来了，由于上面提到的AutoDecode Decode等函数均是ProtocolReader的成员函数，那么AutoDecode(A2&amp;)也应该定义在ProtocolReader中，这样做有两点不足之处：</p>
<ol type="1">
<li>大量的模板特例化会使ProtocolReader变得异常臃肿难读，并且消息的定义和特例化在不同的文件。容易在定义之后忘记特例化。</li>
<li>编译依赖性增大，添加任意一条非POD消息，都需要重新编译整个ProtocolReader.h以及包含它的所有模块。</li>
</ol>
<p>而解决方案就是将类中的模板推导转为全局模板推导AutoDecode，然后自定义类的特例化均在全局中，最后再通过Decode调用ProtocolReader接口进行已知类型的推导。</p>
<p>具体流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/******************* STEP 1 内部自动解码接口 转向全局自动模板推导 **************************/ </div><div class="line">template&lt;typename T&gt;</div><div class="line">bool ProtocolReader::Decode(T&amp; t)</div><div class="line">&#123;</div><div class="line">	// 转向全局推导</div><div class="line">	return AutoDecode(*this, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/****************** STEP 2 通过是否是C数组分发到不同推导接口 ******************************/</div><div class="line">// 全局自动推导 这是全局入口 也是自定义的非POD消息的重载入口</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool AutoDecode(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">	/* </div><div class="line">	*	Serializer是辅助类 它通过 std::is_array&lt;T&gt;::value 的不同值来转调到不同的模板推导接口</div><div class="line">   	*	即 Serializer&lt;true&gt;::DeSerialize(s,t) 和 Serializer&lt;false&gt;::DeSerialize(s,t)</div><div class="line">	*/</div><div class="line">	return Serializer&lt;std::is_array&lt;T&gt;::value&gt;::DeSerialize(s, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/***************** STEP 3 Serializer 完成对C数组和非C数组的分发 *************************/</div><div class="line">/* Serializer对C数组的分发接口</div><div class="line">*	推导出数组元素类型和元素个数</div><div class="line">*	通过DecodeArray进行解码</div><div class="line">*/</div><div class="line">template&lt;typename S, typename T, size_t arraySize&gt;</div><div class="line">bool Serializer&lt;true&gt;::DeSerialize(S&amp; s, T (&amp;t)[arraySize])</div><div class="line">&#123;</div><div class="line">	return DecodeArray(s, t, arraySize);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Serializer对非C数组的分发接口</div><div class="line">*  通过Decode尝试直接解码</div><div class="line">*/</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Serializer&lt;false&gt;::DeSerialize(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">	return Decode(s, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/****************** STEP 4.A 对C数组 T[arraySize] 进行解码 *****************************/</div><div class="line">/*</div><div class="line">*	DecodeArray </div><div class="line">*	对固定长度的数组进行解码</div><div class="line">*/</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool DecodeArray(S&amp; s, T* t, size_t arraySize)</div><div class="line">&#123;</div><div class="line">	uint16_t size = static_cast&lt;uint16_t&gt;(arraySize);</div><div class="line">	for(uint16_t i=0; i&lt;size; i++)</div><div class="line">	&#123;</div><div class="line">		// 递归对元素进行自动解码</div><div class="line">		if(!AutoDecode(s, t[i]))</div><div class="line">			return false;</div><div class="line">	&#125;</div><div class="line">	return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 对基本类型的C数组特例化 直接内存拷贝</div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, int* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(int)); &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, float* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(float)); &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, double* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(double)); &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool DecodeArray(S&amp; s, int64_t* arr, size_t arraySize)&#123; return s.Read((void*)arr, arraySize*sizeof(int64_t)); &#125;</div><div class="line"></div><div class="line">/*********************** STEP 4.B 对非C数组 进行直接解码 *******************************/</div><div class="line">// 默认解码 对于POD类型 直接内存拷贝</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Decode(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">    static_assert(std::is_trivial&lt;T&gt;::value, &quot;is not trivial. need to customize&quot;);</div><div class="line">    static_assert(std::is_standard_layout&lt;T&gt;::value, &quot;is not standard_layout. need to customize&quot;);</div><div class="line">    return s.Read((void*)&amp;t, sizeof(t));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 预定义特例化</div><div class="line">// 对string的解码 在ProtocolReader中完成 此时类型已确定</div><div class="line">template&lt;typename S&gt;</div><div class="line">bool Decode(S&amp; s, std::string&amp; t)&#123; return s.Read(t);  &#125;</div><div class="line"></div><div class="line">template&lt;typename S&gt;</div><div class="line">bool Decode(S&amp; s, std::wstring&amp; t)&#123; return s.Read(t);	&#125;</div><div class="line"></div><div class="line">// 对标准库容器的解码 由于标准容器元素类型可能仍为自定义类型，因此需要继续递归解码</div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Decode(S&amp; s, std::vector&lt;T&gt;&amp; t)&#123; return DecodeArray(s, t); &#125;</div><div class="line"></div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool Decode(S&amp; s, std::list&lt;T&gt;&amp; t)&#123; return DecodeArray(s, t); &#125;</div><div class="line"></div><div class="line">// 解码动态长度容器 </div><div class="line">template&lt;typename S, typename T&gt;</div><div class="line">bool DecodeArray(S&amp; s, T&amp; t)</div><div class="line">&#123;</div><div class="line">    uint16_t size;</div><div class="line">    if (s.Read(size))</div><div class="line">    &#123;</div><div class="line">        for (uint16_t i = 0; i &lt; size; i++)</div><div class="line">        &#123;</div><div class="line">            T::value_type v;</div><div class="line">			// 逐个对元素进行自动解码</div><div class="line">            if (!AutoDecode(s, v))</div><div class="line">                return false;</div><div class="line">            t.push_back(v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，对数组元素或标准库容器元素解码时，都调用AutoDecode，这是因为如果容器元素是用户自定义的非POD类型，那么可以通过用户重载的AutoDecode进行正确解码。总之，对于未知类型，都应该通过AutoDecode确保用户自定义类型得到正确解码。而Decode只针对于两种类型：POD类型和标准库容器类型，对于前者默认内存拷贝，对于后者通过AutoDecode对元素逐个解码。如果用户没有提供自定义类型的AutoDecode特例化，那么Decode判断其POD类型并执行内存拷贝，如果该类型不是POD类型，那么static_assert将在编译器给出错误：“is not trivial. need to customize” 或 “is not standard layout. need to customize”。 而C数组通过在AutoDecode转向分支DecodeArray，DecodeArray完成元素个数解析之后，也通过AutoDecode对元素递归解码。</p>
<h3 id="五.-自定义消息类型的特例化">五. 自定义消息类型的特例化</h3>
<p>自定义的非POD消息类型A2的特例化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bool AutoDecode(ProtocolReader&amp; s, A2&amp; t)</div><div class="line">&#123;</div><div class="line">	return AutoDecode(s, t.name) &amp;&amp; AutoDecode(s, t.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是全部特例化，它特例化了解码类ProtocolReader和解码类型A2。而自动化模板推导中使用typename S来模板化编解码类，这是为了提高灵活性，让全局自动模板推导框架可以用于多种编解码类。</p>
<p>如果自定义消息类更复杂一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct A3</div><div class="line">&#123;</div><div class="line">	std::string str;</div><div class="line">	A2 a2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此时A3为复合的自定义非POD类型，如果只为A3提供特例化而忘了给A2特例化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bool AutoDecode(ProtocolReader&amp; s, A3&amp; t)</div><div class="line">&#123;</div><div class="line">	return AutoDecode(s, t.str) &amp;&amp; AutoDecode(s, t.a2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么 <code>AutoDecode(s, t.str)</code>能够解码成功，而<code>AutoDecode(s, t.a2)</code>，则会失败。因此最好在定义任何一个与客户端交互的非POD结构体时，都需要提供对应编解码规则。而不是在特例化消息的时候才去注意其成员有无非POD类型需要特例化。</p>
<h3 id="六.-特例化宏">六. 特例化宏</h3>
<p>编码的推导过程和解码大同小异，只不过最终是写入缓冲区而不是读取缓冲区。NGServer还有一个ProtocolSize类，用于获取消息编码之后的大小，推导流程也和编解码流程一致。目前没有什么太大的作用。因此实际上在特例化自定义类的编解码规则时，需要同时提供AutoEncode，AutoDecode，AutoMsgSize三个全局函数。这样在消息比较多时，编写对应编解码规则是一件比较麻烦的事情，并且容易出错。</p>
<p>因此可以对这些编解码特例化提供一个宏，方便定义其编解码规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#define AUTOCUSTOMMSG1(T, v1) \</div><div class="line">    bool Encode(ProtocolWriter&amp; s, const T&amp; t)&#123; \</div><div class="line">        return AutoEncode(s, t.v1); &#125; \</div><div class="line">    \</div><div class="line">    bool Decode(ProtocolReader&amp; s,  T&amp; t)&#123; \</div><div class="line">        return AutoDecode(s, t.v1); &#125; \</div><div class="line">    \</div><div class="line">    uint32_t GetMsgSize(ProtocolSize&amp; s, const T&amp; t )&#123; \</div><div class="line">        return AutoMsgSize(s, t.v1); &#125; </div><div class="line"></div><div class="line">#define AUTOCUSTOMMSG2(T, v1, v2) \</div><div class="line">    bool Encode(ProtocolWriter&amp; s, const T&amp; t)&#123; \</div><div class="line">        return AutoEncode(s, t.v1) &amp;&amp; AutoEncode(s, t.v2); &#125; \</div><div class="line">    \</div><div class="line">    bool Decode(ProtocolReader&amp; s,  T&amp; t)&#123; \</div><div class="line">        return AutoDecode(s, t.v1) &amp;&amp; AutoDecode(s, t.v2); &#125; \</div><div class="line">    \</div><div class="line">    uint32_t GetMsgSize(ProtocolSize&amp; s, const T&amp; t )&#123; \</div><div class="line">        return AutoMsgSize(s, t.v1) + AutoMsgSize(s, t.v2); &#125; </div><div class="line"></div><div class="line">#define AUTOCUSTOMMSG3(T, v1, v2, v3) \ </div><div class="line">......</div></pre></td></tr></table></figure>
<p>如此，对于A2，我们只需在协议cpp文件添加：</p>
<pre><code>AUTOCUSTOMMSG2(A2, name, data);</code></pre>
<p>即可。</p>
<h3 id="七.-回到protocolreader">七. 回到ProtocolReader</h3>
<p>ProtocolReader通过Decode函数转向全局模板推导，最后再回到ProtocolReader进行缓冲读取，由于ProtocolReader缓冲区对应于一条消息，因此解码的缓冲区offset偏移初始化为4(前四个字节为消息头部)。它提供基本类型和string的读取，最后附上主要代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">class ProtocolReader : public ProtocolStream</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ProtocolReader(char* buf, uint32_t len) :</div><div class="line">        ProtocolStream(buf, len)&#123;&#125;</div><div class="line"></div><div class="line">    template&lt;typename T&gt;</div><div class="line">    bool Decode(T&amp; t)</div><div class="line">    &#123;</div><div class="line">        return AutoDecode(*this, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 读取二进制数据</div><div class="line">    bool Read(void* ptr, uint32_t len)</div><div class="line">    &#123;</div><div class="line">        if (Remain() &gt;= len)</div><div class="line">        &#123;</div><div class="line">            memcpy(ptr, _buf + _offset, len);</div><div class="line">            _offset += len;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 读取基本类型的数据</div><div class="line">    inline bool Read(char&amp; v)    &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int8_t&amp; v)  &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint8_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int16_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint16_t&amp; v)&#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int32_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint32_t&amp; v)&#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(int64_t&amp; v) &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(uint64_t&amp; v)&#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(float&amp; v)   &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line">    inline bool Read(double&amp; v)  &#123; return Read((void*)(&amp;v), sizeof(v)); &#125;</div><div class="line"></div><div class="line">    // 对string解码</div><div class="line">    inline bool Read(std::string&amp; v)     &#123; return ReadString(v); &#125;</div><div class="line">    inline bool Read(std::wstring&amp; v)    &#123; return ReadString(v); &#125;</div><div class="line"></div><div class="line">    // 读取头部和消息ID</div><div class="line">    inline uint16_t ReadHead()</div><div class="line">    &#123;</div><div class="line">        uint16_t* h = (uint16_t*)_buf;</div><div class="line">        return *h;</div><div class="line">    &#125;</div><div class="line">    inline uint16_t ReadMsgId()</div><div class="line">    &#123;</div><div class="line">        uint16_t* h = (uint16_t*)_buf;</div><div class="line">        return *(h + 1);</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    bool ReadString(std::string&amp; v)</div><div class="line">    &#123;</div><div class="line">        uint16_t len;</div><div class="line">        if (Read(len))</div><div class="line">        &#123;</div><div class="line">            v.clear();</div><div class="line">            if (len &gt; 0)</div><div class="line">            &#123;</div><div class="line">                assert(Remain() &gt;= len*sizeof(char));</div><div class="line">                v.append((const char*)(_buf + _offset), len);</div><div class="line">                _offset += len;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool ReadString(std::wstring&amp; v)</div><div class="line">    &#123;</div><div class="line">        uint16_t len;</div><div class="line">        if (Read(len))</div><div class="line">        &#123;</div><div class="line">            v.clear();</div><div class="line">            if (len &gt; 0)</div><div class="line">            &#123;</div><div class="line">                assert(Remain() &gt;= len*sizeof(wchar_t));</div><div class="line">                v.append((const wchar_t*)(_buf + _offset), len);</div><div class="line">                _offset += len*sizeof(wchar_t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/ngserver/">ngserver</a></div><div class="post-share"></div><div class="post-nav"><a href="/2014/11/cpp-constructor/" class="pre">C++ 构造语义</a><a href="/2014/11/ngserver-message-callback/" class="next">NGServer 消息的注册与回调</a></div><div id="comments"><div id="disqus_thread"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一.-消息编码格式"><span class="toc-text">一. 消息编码格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二.-protocolstream"><span class="toc-text">二. ProtocolStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三.-数据类型"><span class="toc-text">三. 数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四.-protocolreader解码推导流程"><span class="toc-text">四. ProtocolReader解码推导流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五.-自定义消息类型的特例化"><span class="toc-text">五. 自定义消息类型的特例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六.-特例化宏"><span class="toc-text">六. 特例化宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七.-回到protocolreader"><span class="toc-text">七. 回到ProtocolReader</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/hexo-with-mathjax/">Hexo使用mathjax渲染公式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/docker-network/">docker 网络模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/ngs-battle/">探讨服务端回合制战斗系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/go-conetxt-usage/">用context库规范化Go的异步调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/go-vs-erlang/">Go vs Erlang</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/erlang-lua-reconstruction/">Erlang+Lua的一次重构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/lua-notes/">Lua 闭包 环境 包管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/max-osx-ulimit/">Mac OS X下的资源限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/go-command-notes/">Go 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/css-notes/">CSS 笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">database</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gameserver/">gameserver</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">os</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/system/">system</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/ngserver/" style="font-size: 15px;">ngserver</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/skynet/" style="font-size: 15px;">skynet</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/firefly/" style="font-size: 15px;">firefly</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/kbengine/" style="font-size: 15px;">kbengine</a> <a href="/tags/distribution/" style="font-size: 15px;">distribution</a> <a href="/tags/unity/" style="font-size: 15px;">unity</a> <a href="/tags/c-c/" style="font-size: 15px;">c/c++</a> <a href="/tags/other/" style="font-size: 15px;">other</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/gameserver/" style="font-size: 15px;">gameserver</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/goa/" style="font-size: 15px;">goa</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/macosx/" style="font-size: 15px;">macosx</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wudaijun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>var disqus_shortname = 'wudaijun';
var disqus_identifier = '2014/11/ngserver-message-encoder/';
var disqus_title = 'NGServer 消息的编解码';
var disqus_url = 'http://wudaijun.com/2014/11/ngserver-message-encoder/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wudaijun.disqus.com/count.js" async></script><script type="text/javascript" src="//wudaijun.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></body></html>