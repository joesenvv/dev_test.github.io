<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
  <title>NGServer 消息的编解码 | wudaijun&#39;s blog | Coding is Funny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="ngserver">
  <meta name="description" content="消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。">
<meta property="og:type" content="article">
<meta property="og:title" content="NGServer 消息的编解码">
<meta property="og:url" content="http://wudaijun.com/2014/11/ngserver-message-encoder/index.html">
<meta property="og:site_name" content="wudaijun's blog">
<meta property="og:description" content="消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。">
<meta property="og:updated_time" content="2016-09-24T08:56:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NGServer 消息的编解码">
<meta name="twitter:description" content="消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。">
  
    <link rel="alternative" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  
  <meta name="summary" content="&lt;p&gt;消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。&lt;/p&gt;">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css?v=1.1.4">
</head>

<body>
  <div id="loading" class="active"></div>

  <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar"><img src="/favicon.png"></a>
        <hgroup class="introduce">
          <h5 class="nickname">wudaijun</h5>
          <a href="mailto:wdjlost@gmail.com" title="wdjlost@gmail.com" class="mail">wdjlost@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://blog.csdn.net/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-contao"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>

      <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>wudaijun&#39;s blog &copy; 2017</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

    </div>
  </div>
</aside>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">NGServer 消息的编解码</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container">
        <h1 class="title">NGServer 消息的编解码</h1>
        
        

    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一-_消息编码格式"><span class="post-toc-text">一. 消息编码格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二-_ProtocolStream"><span class="post-toc-text">二. ProtocolStream</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三-_数据类型"><span class="post-toc-text">三. 数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四-_ProtocolReader解码推导流程"><span class="post-toc-text">四. ProtocolReader解码推导流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五-_自定义消息类型的特例化"><span class="post-toc-text">五. 自定义消息类型的特例化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#六-_特例化宏"><span class="post-toc-text">六. 特例化宏</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#七-_回到ProtocolReader"><span class="post-toc-text">七. 回到ProtocolReader</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-ngserver-message-encoder" 
  class="post-article article-type-post" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">NGServer 消息的编解码</h1>
        <div class="post-meta">
            <time datetime="2014-11-04T16:00:00.000Z" itemprop="datePublished" class="post-time">
  2014-11-05
</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/gameserver/">gameserver</a></li></ul>



        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>消息编解码(或序列化)主要是将消息体由一些标准库容器或自定义的类型，转化成二进制流，方便网络传输。为了减少网络IO，编解码中也可能在存在数据”压缩和解压”，但这种压缩是针对于特定的数据类型，并不是针对于二进制流的。在NGServer的消息编解码中，并不涉及数据压缩。</p>
<a id="more"></a>
<h3 id="一-_消息编码格式">一. 消息编码格式</h3><p>NGServer的消息分为首部和消息体，首部共四个字节，包括消息长度(包括首部)和消息ID，各占两个字节。消息体为消息编码后的二进制数据。</p>
<p>在消息体中，针对于不同的数据类型而不同编码。对于POD类型，直接进行内存拷贝，对于非POD类型，如标准库容器，则需要自定义编码格式，以下是几种最常见的数据类型编码：</p>
<p>std::string 先写入字符串长度，占两个字节，再写入字符串内容。<br>std::vector 先写入vector的元素个数(占两个字节)，在对其元素逐个递归编码(如果元素类型为string，则使用string的编码方式)。<br>std::list    编码方式与vector类似<br>T arr[N]    对于这种类型，不需要写入元素个数，因为在消息结构体中指出了固定长度N，因此可以通过模板推导得到N。所以递归写入N个元素T即可。对于简单数据类型T，如T为char时，可以通过模板特例化对其优化。</p>
<h3 id="二-_ProtocolStream">二. ProtocolStream</h3><p>NGServer的消息编解码依靠两个类：ProtocolReader和ProtocolWriter。这两个类派生于ProtocolStream，ProtocolStream简单维护一个用于编码或解码的线性缓冲区，并记录缓冲区的当前状态，如总大小，当前偏移，等等。一个ProtocolStream的缓冲区即代表一条消息，因此它ProtocolReader/ProtocolWriter总是在缓冲区头四个字节中读出或写入消息长度和消息ID。</p>
<p>ProtocolReader从缓冲区中读出消息，也就是解码，由于缓冲区的数据是二进制的，因此我们需要提供需要读出的数据类型。因此ProtocolReader提供的接口如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> ProtocolReader::AutoDecode(T&amp; t);</span><br></pre></td></tr></table></figure>
<p>Decode在缓冲区的当前偏移处，读出数据t，并返回操作结果。而根据T的类型不同，读取方式也不一样，这需要通过模板推导来完成。</p>
<h3 id="三-_数据类型">三. 数据类型</h3><p>T的类型概括有四种：</p>
<ul>
<li>基本POD类型，如 int, double, char 等  </li>
<li>标准库非POD类型，如 std::string, std::vector, std::list 等</li>
<li>自定义POD类型，如:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">36</span>];</span><br><span class="line">	<span class="keyword">char</span> pwd[<span class="number">36</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义非POD类型，如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A2</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>C数组类型 由于其推导方式不同 因此单独归为一类</li>
</ul>
<p>关于c++ POD类型和std::is_pod，std::is_standard_layout，std::is_trivial等函数，可参见下面两篇博客：</p>
<ol>
<li><a href="http://m.oschina.net/blog/156796" target="_blank" rel="external">http://m.oschina.net/blog/156796</a></li>
<li><a href="http://www.cnblogs.com/hancm/p/3665998.html" target="_blank" rel="external">http://www.cnblogs.com/hancm/p/3665998.html</a></li>
</ol>
<p>这里说的POD指的是 std::is_trivial<t\>::value &amp;&amp; std::is_standard_layout<t\>::value</t\></t\></p>
<h3 id="四-_ProtocolReader解码推导流程">四. ProtocolReader解码推导流程</h3><p>推导流程如下：</p>
<p><strong>1.如果T是C数组类型 (std::is_array<t>::value == true)</t></strong>，那么下一个推导模型应该为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">template</span>&lt;<span class="tag">typename</span> <span class="tag">T</span>, <span class="tag">size_t</span> <span class="tag">arraySize</span>&gt;</span><br><span class="line"><span class="tag">bool</span> <span class="rule"><span class="attribute">ProtocolReader</span>:<span class="value">:<span class="function">DecodeArray</span>(const T (&amp;arr)[arraySize])</span></span>;</span><br></pre></td></tr></table></figure>
<p>如此便能推导出数组的元素类型，以及数组的大小</p>
<p>注：std::is_array<t\>用于判别一个类型是否为<strong>C风格数组类型</strong>，对于c++的容器vector，std::is_array<vector<int\>&gt;::value的值为false，因为vector本身也是一个类。</vector<int\></t\></p>
<p>根据我们对C数组的编码方式，下一步我们需要递归通过ProtocolReader::AutoDecode(arr[i])来依次递归对数组元素进行解码。</p>
<p><strong>2.如果T不是C型数组</strong>，那么T是一个类(或基本类型)。此时通过Decode来对该类进行编解码，Decode读取缓冲区数据，对POD类型和预定义的特例化类型(一般是标准库容器)进行读取并解码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> ProtocolReader::Decode(T&amp; t);</span><br></pre></td></tr></table></figure>
<p>对于POD类型，无论是基本数据类型或者自定义类型，均无需特例化，直接内存拷贝即可。这也是Decode()的默认实现。而对于标准库中的容器，则可以针对性的模板特例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> ProtocolReader::Decode(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; vec);</span><br></pre></td></tr></table></figure>
<p>而对于最后一种类型，自定义非POD类型，模板自动推导则爱莫能助了，比如对于结构体A2，它的推导流程是: AutoDecode(A2&amp;) -&gt; Decode(A2&amp;) 到了这里，框架无法再推导出A2内部的乾坤了。这就需要A2的定义者提供一个特例化的解码函数AutoDecode(A2&amp;)，为什么不特例化Decode(A2&amp;)呢？因为AutoDecode()是解码的最外层接口，使用者通过自定义的AutoDecode能够获得最大的灵活性。</p>
<p>那么问题来了，由于上面提到的AutoDecode Decode等函数均是ProtocolReader的成员函数，那么AutoDecode(A2&amp;)也应该定义在ProtocolReader中，这样做有两点不足之处：</p>
<ol>
<li>大量的模板特例化会使ProtocolReader变得异常臃肿难读，并且消息的定义和特例化在不同的文件。容易在定义之后忘记特例化。</li>
<li>编译依赖性增大，添加任意一条非POD消息，都需要重新编译整个ProtocolReader.h以及包含它的所有模块。</li>
</ol>
<p>而解决方案就是将类中的模板推导转为全局模板推导AutoDecode，然后自定义类的特例化均在全局中，最后再通过Decode调用ProtocolReader接口进行已知类型的推导。</p>
<p>具体流程：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> STEP 1 内部自动解码接口 转向全局自动模板推导 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/ </span><br><span class="line">template<span class="variable">&lt;typename T&gt;</span></span><br><span class="line">bool ProtocolReader::Decode(T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	// 转向全局推导</span><br><span class="line">	return AutoDecode(<span class="keyword">*</span>this, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> STEP 2 通过是否是C数组分发到不同推导接口 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">// 全局自动推导 这是全局入口 也是自定义的非POD消息的重载入口</span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool AutoDecode(S&amp; s, T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	/<span class="keyword">*</span> </span><br><span class="line">	<span class="keyword">*</span>	Serializer是辅助类 它通过 std::is_array<span class="variable">&lt;T&gt;</span>::value 的不同值来转调到不同的模板推导接口</span><br><span class="line">   	<span class="keyword">*</span>	即 Serializer<span class="variable">&lt;true&gt;</span>::DeSerialize(s,t) 和 Serializer<span class="variable">&lt;false&gt;</span>::DeSerialize(s,t)</span><br><span class="line">	<span class="keyword">*</span>/</span><br><span class="line">	return Serializer<span class="variable">&lt;std::is_array&lt;T&gt;</span>::value&gt;::DeSerialize(s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> STEP 3 Serializer 完成对C数组和非C数组的分发 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span> Serializer对C数组的分发接口</span><br><span class="line"><span class="keyword">*</span>	推导出数组元素类型和元素个数</span><br><span class="line"><span class="keyword">*</span>	通过DecodeArray进行解码</span><br><span class="line"><span class="keyword">*</span>/</span><br><span class="line">template<span class="variable">&lt;typename S, typename T, size_t arraySize&gt;</span></span><br><span class="line">bool Serializer<span class="variable">&lt;true&gt;</span>::DeSerialize(S&amp; s, T (&amp;t)[arraySize])</span><br><span class="line">&#123;</span><br><span class="line">	return DecodeArray(s, t, arraySize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span> Serializer对非C数组的分发接口</span><br><span class="line"><span class="keyword">*</span>  通过Decode尝试直接解码</span><br><span class="line"><span class="keyword">*</span>/</span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool Serializer<span class="variable">&lt;false&gt;</span>::DeSerialize(S&amp; s, T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	return Decode(s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> STEP 4.A 对C数组 T[arraySize] 进行解码 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span>	DecodeArray </span><br><span class="line"><span class="keyword">*</span>	对固定长度的数组进行解码</span><br><span class="line"><span class="keyword">*</span>/</span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool DecodeArray(S&amp; s, T<span class="keyword">*</span> t, size_t arraySize)</span><br><span class="line">&#123;</span><br><span class="line">	uint16_t size = static_cast<span class="variable">&lt;uint16_t&gt;</span>(arraySize);</span><br><span class="line">	for(uint16_t i=0; i<span class="variable">&lt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		// 递归对元素进行自动解码</span><br><span class="line">		if(!AutoDecode(s, t[i]))</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对基本类型的C数组特例化 直接内存拷贝</span><br><span class="line">template&lt;typename S&gt;</span></span><br><span class="line">bool DecodeArray(S&amp; s, int<span class="keyword">*</span> arr, size_t arraySize)&#123; return s.Read((void<span class="keyword">*</span>)arr, arraySize<span class="keyword">*</span>sizeof(int)); &#125;</span><br><span class="line"></span><br><span class="line">template<span class="variable">&lt;typename S&gt;</span></span><br><span class="line">bool DecodeArray(S&amp; s, float<span class="keyword">*</span> arr, size_t arraySize)&#123; return s.Read((void<span class="keyword">*</span>)arr, arraySize<span class="keyword">*</span>sizeof(float)); &#125;</span><br><span class="line"></span><br><span class="line">template<span class="variable">&lt;typename S&gt;</span></span><br><span class="line">bool DecodeArray(S&amp; s, double<span class="keyword">*</span> arr, size_t arraySize)&#123; return s.Read((void<span class="keyword">*</span>)arr, arraySize<span class="keyword">*</span>sizeof(double)); &#125;</span><br><span class="line"></span><br><span class="line">template<span class="variable">&lt;typename S&gt;</span></span><br><span class="line">bool DecodeArray(S&amp; s, int64_t<span class="keyword">*</span> arr, size_t arraySize)&#123; return s.Read((void<span class="keyword">*</span>)arr, arraySize<span class="keyword">*</span>sizeof(int64_t)); &#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> STEP 4.B 对非C数组 进行直接解码 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">// 默认解码 对于POD类型 直接内存拷贝</span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool Decode(S&amp; s, T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    static_assert(std::is_trivial<span class="variable">&lt;T&gt;</span>::value, <span class="string">"is not trivial. need to customize"</span>);</span><br><span class="line">    static_assert(std::is_standard_layout<span class="variable">&lt;T&gt;</span>::value, <span class="string">"is not standard_layout. need to customize"</span>);</span><br><span class="line">    return s.Read((void<span class="keyword">*</span>)&amp;t, sizeof(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 预定义特例化</span><br><span class="line">// 对string的解码 在ProtocolReader中完成 此时类型已确定</span><br><span class="line">template<span class="variable">&lt;typename S&gt;</span></span><br><span class="line">bool Decode(S&amp; s, std::string&amp; t)&#123; return s.Read(t);  &#125;</span><br><span class="line"></span><br><span class="line">template<span class="variable">&lt;typename S&gt;</span></span><br><span class="line">bool Decode(S&amp; s, std::wstring&amp; t)&#123; return s.Read(t);	&#125;</span><br><span class="line"></span><br><span class="line">// 对标准库容器的解码 由于标准容器元素类型可能仍为自定义类型，因此需要继续递归解码</span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool Decode(S&amp; s, std::vector<span class="variable">&lt;T&gt;</span>&amp; t)&#123; return DecodeArray(s, t); &#125;</span><br><span class="line"></span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool Decode(S&amp; s, std::list<span class="variable">&lt;T&gt;</span>&amp; t)&#123; return DecodeArray(s, t); &#125;</span><br><span class="line"></span><br><span class="line">// 解码动态长度容器 </span><br><span class="line">template<span class="variable">&lt;typename S, typename T&gt;</span></span><br><span class="line">bool DecodeArray(S&amp; s, T&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    uint16_t size;</span><br><span class="line">    if (s.Read(size))</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint16_t i = 0; i <span class="variable">&lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            T::value_type v;</span><br><span class="line">			// 逐个对元素进行自动解码</span><br><span class="line">            if (!AutoDecode(s, v))</span><br><span class="line">                return false;</span><br><span class="line">            t.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，对数组元素或标准库容器元素解码时，都调用AutoDecode，这是因为如果容器元素是用户自定义的非POD类型，那么可以通过用户重载的AutoDecode进行正确解码。总之，对于未知类型，都应该通过AutoDecode确保用户自定义类型得到正确解码。而Decode只针对于两种类型：POD类型和标准库容器类型，对于前者默认内存拷贝，对于后者通过AutoDecode对元素逐个解码。如果用户没有提供自定义类型的AutoDecode特例化，那么Decode判断其POD类型并执行内存拷贝，如果该类型不是POD类型，那么static_assert将在编译器给出错误：”is not trivial. need to customize” 或 “is not standard layout. need to customize”。<br>而C数组通过在AutoDecode转向分支DecodeArray，DecodeArray完成元素个数解析之后，也通过AutoDecode对元素递归解码。</p>
<h3 id="五-_自定义消息类型的特例化">五. 自定义消息类型的特例化</h3><p>自定义的非POD消息类型A2的特例化如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>AutoDecode(ProtocolReader&amp; s, <span class="literal">A2</span>&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	return AutoDecode(s, t.name) &amp;&amp; AutoDecode(s, t<span class="preprocessor">.data</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是全部特例化，它特例化了解码类ProtocolReader和解码类型A2。而自动化模板推导中使用typename S来模板化编解码类，这是为了提高灵活性，让全局自动模板推导框架可以用于多种编解码类。</p>
<p>如果自定义消息类更复杂一些：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct </span><span class="literal">A3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="label">	std:</span>:<span class="keyword">string </span><span class="keyword">str;</span><br><span class="line"></span>	<span class="literal">A2</span> <span class="literal">a2</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>此时A3为复合的自定义非POD类型，如果只为A3提供特例化而忘了给A2特例化：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>AutoDecode(ProtocolReader&amp; s, <span class="literal">A3</span>&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	return AutoDecode(s, t.<span class="keyword">str) </span>&amp;&amp; AutoDecode(s, t.a2)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <code>AutoDecode(s, t.str)</code>能够解码成功，而<code>AutoDecode(s, t.a2)</code>，则会失败。因此最好在定义任何一个与客户端交互的非POD结构体时，都需要提供对应编解码规则。而不是在特例化消息的时候才去注意其成员有无非POD类型需要特例化。</p>
<h3 id="六-_特例化宏">六. 特例化宏</h3><p>编码的推导过程和解码大同小异，只不过最终是写入缓冲区而不是读取缓冲区。NGServer还有一个ProtocolSize类，用于获取消息编码之后的大小，推导流程也和编解码流程一致。目前没有什么太大的作用。因此实际上在特例化自定义类的编解码规则时，需要同时提供AutoEncode，AutoDecode，AutoMsgSize三个全局函数。这样在消息比较多时，编写对应编解码规则是一件比较麻烦的事情，并且容易出错。</p>
<p>因此可以对这些编解码特例化提供一个宏，方便定义其编解码规则：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define AUTOCUSTOMMSG1(T, v1) \</span></span><br><span class="line">    bool Encode(ProtocolWriter&amp; s, <span class="keyword">const</span> T&amp; t)&#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> AutoEncode(s, t.v1); &#125; <span class="string">\</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">    bool Decode(ProtocolReader&amp; s,  T&amp; t)&#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> AutoDecode(s, t.v1); &#125; <span class="string">\</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">    uint32_t GetMsgSize(ProtocolSize&amp; s, <span class="keyword">const</span> T&amp; t )&#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> AutoMsgSize(s, t.v1); &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">#define AUTOCUSTOMMSG2(T, v1, v2) \</span></span><br><span class="line">    bool Encode(ProtocolWriter&amp; s, <span class="keyword">const</span> T&amp; t)&#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> AutoEncode(s, t.v1) &amp;&amp; AutoEncode(s, t.v2); &#125; <span class="string">\</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">    bool Decode(ProtocolReader&amp; s,  T&amp; t)&#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> AutoDecode(s, t.v1) &amp;&amp; AutoDecode(s, t.v2); &#125; <span class="string">\</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">    uint32_t GetMsgSize(ProtocolSize&amp; s, <span class="keyword">const</span> T&amp; t )&#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> AutoMsgSize(s, t.v1) + AutoMsgSize(s, t.v2); &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">#define AUTOCUSTOMMSG3(T, v1, v2, v3) \ </span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>如此，对于A2，我们只需在协议cpp文件添加：</p>
<pre><code><span class="label">AUTOCUSTOMMSG2</span>(<span class="literal">A2</span>, name, <span class="preprocessor">data</span>)<span class="comment">;</span>
</code></pre><p>即可。</p>
<h3 id="七-_回到ProtocolReader">七. 回到ProtocolReader</h3><p>ProtocolReader通过Decode函数转向全局模板推导，最后再回到ProtocolReader进行缓冲读取，由于ProtocolReader缓冲区对应于一条消息，因此解码的缓冲区offset偏移初始化为4(前四个字节为消息头部)。它提供基本类型和string的读取，最后附上主要代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ProtocolReader</span> : <span class="title">public</span> <span class="title">ProtocolStream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProtocolReader(<span class="keyword">char</span>* buf, uint32_t len) :</span><br><span class="line">        ProtocolStream(buf, len)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Decode</span>(<span class="params">T&amp; t</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AutoDecode(*<span class="keyword">this</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取二进制数据</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Read</span>(<span class="params"><span class="keyword">void</span>* ptr, uint32_t len</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Remain() &gt;= len)</span><br><span class="line">        &#123;</span><br><span class="line">            memcpy(ptr, _buf + _offset, len);</span><br><span class="line">            _offset += len;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取基本类型的数据</span></span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params"><span class="keyword">char</span>&amp; v</span>)    </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">int8_t&amp; v</span>)  </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">uint8_t&amp; v</span>) </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">int16_t&amp; v</span>) </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">uint16_t&amp; v</span>)</span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">int32_t&amp; v</span>) </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">uint32_t&amp; v</span>)</span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">int64_t&amp; v</span>) </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">uint64_t&amp; v</span>)</span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params"><span class="keyword">float</span>&amp; v</span>)   </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params"><span class="keyword">double</span>&amp; v</span>)  </span>&#123; <span class="keyword">return</span> Read((<span class="keyword">void</span>*)(&amp;v), <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对string解码</span></span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">std::<span class="keyword">string</span>&amp; v</span>)     </span>&#123; <span class="keyword">return</span> ReadString(v); &#125;</span><br><span class="line">    <span class="function">inline <span class="keyword">bool</span> <span class="title">Read</span>(<span class="params">std::wstring&amp; v</span>)    </span>&#123; <span class="keyword">return</span> ReadString(v); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取头部和消息ID</span></span><br><span class="line">    <span class="function">inline uint16_t <span class="title">ReadHead</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        uint16_t* h = (uint16_t*)_buf;</span><br><span class="line">        <span class="keyword">return</span> *h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">inline uint16_t <span class="title">ReadMsgId</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        uint16_t* h = (uint16_t*)_buf;</span><br><span class="line">        <span class="keyword">return</span> *(h + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ReadString</span>(<span class="params">std::<span class="keyword">string</span>&amp; v</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        uint16_t len;</span><br><span class="line">        <span class="keyword">if</span> (Read(len))</span><br><span class="line">        &#123;</span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                assert(Remain() &gt;= len*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">                v.append((<span class="keyword">const</span> <span class="keyword">char</span>*)(_buf + _offset), len);</span><br><span class="line">                _offset += len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ReadString</span>(<span class="params">std::wstring&amp; v</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        uint16_t len;</span><br><span class="line">        <span class="keyword">if</span> (Read(len))</span><br><span class="line">        &#123;</span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                assert(Remain() &gt;= len*<span class="keyword">sizeof</span>(wchar_t));</span><br><span class="line">                v.append((<span class="keyword">const</span> wchar_t*)(_buf + _offset), len);</span><br><span class="line">                _offset += len*<span class="keyword">sizeof</span>(wchar_t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        </div>
        
        <blockquote class="post-copyright">
            <div class="content">
               这里写留言或版权声明：<a href="/2014/11/ngserver-message-encoder/" target="_blank" rel="external">http://wudaijun.com/2014/11/ngserver-message-encoder/</a>
            </div>
            <footer>
                <a href="http://wudaijun.com">
                    <img src="/favicon.png" alt="wudaijun">
                    wudaijun
                </a>
            </footer>
        </blockquote>

        

        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngserver/">ngserver</a></li></ul>


            
            <div class="post-share-wrap">
                <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

                <a href="javascript:;" id="share-fab" class="post-share-fab waves-effect waves-circle">
                    <i class="icon icon-share-alt icon-lg"></i>
                </a>
            </div>
            

        </div>
    </div>   

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2014/11/cpp-constructor/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">C++ 构造语义</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2014/11/ngserver-message-callback/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">NGServer 消息的注册与回调</h4>
      </a>
    </div>
  
</nav>


            
    


<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'wudaijun'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


</article>


</div>
  </main>
  <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "NGServer 消息的编解码",
    pic: "/favicon.png",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://wudaijun.com/2014/11/ngserver-message-encoder/"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


  <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script src="/js/main.min.js?v=1.1.4"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.1.4"></script>





<script src="//s95.cnzz.com/z_stat.php?id=1254033667&web_id=1254033667"></script>





</body>
</html>
