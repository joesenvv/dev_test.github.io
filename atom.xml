<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wudaijun&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/eb575f4256a9fe4728b794090470955c</icon>
  <subtitle>Coding is Funny</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wudaijun.com/"/>
  <updated>2018-01-29T13:14:56.000Z</updated>
  <id>http://wudaijun.com/</id>
  
  <author>
    <name>wudaijun</name>
    <email>wdjlost@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go Interface实现</title>
    <link href="http://wudaijun.com/2018/01/go-interface-implement/"/>
    <id>http://wudaijun.com/2018/01/go-interface-implement/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-01-29T13:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文从源码的角度学习下Go接口的底层实现，以及接口赋值，反射，断言的实现原理。作为对比，用到了go1.8.6和go1.9.1两个版本。</p><h3 id="1-eface"><a href="#1-eface" class="headerlink" title="1. eface"></a>1. eface</h3><p>空接口通过eface结构体实现，位于runtime/runtime2.go: </p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/runtime/runtime2.go</span></div><div class="line"><span class="comment">// 空接口</span></div><div class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</div><div class="line">    _type *_type</div><div class="line">    data  unsafe.Pointer</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空接口(eface)有两个域，所指向对象的类型信息(_type)和数据指针(data)。先看看<code>_type</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 所有类型信息结构体的公共部分</div><div class="line">// src/rumtime/runtime2.go</div><div class="line">type _type struct &#123;</div><div class="line">    size       uintptr         // 类型的大小</div><div class="line">    ptrdata    uintptr      // size of memory prefix holding all pointers</div><div class="line">    hash       uint32          // 类型的Hash值</div><div class="line">    tflag      tflag              // 类型的Tags </div><div class="line">    align      uint8       // 结构体内对齐</div><div class="line">    fieldalign uint8       // 结构体作为field时的对齐</div><div class="line">    kind       uint8       // 类型编号 定义于runtime/typekind.go</div><div class="line">    alg        *typeAlg    // 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值</div><div class="line">    gcdata    *byte            // GC相关信息</div><div class="line">    str       nameOff   // 类型名字的偏移    </div><div class="line">    ptrToThis typeOff    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>_type是go所有类型的公共描述，里面包含GC，反射等需要的细节，它决定data应该如何解释和操作，这也是它和C void*不同之处。<br>各个类型所需要的类型描述是不一样的，比如chan，除了chan本身外，还需要描述其元素类型，而map则需要key类型信息和value类型信息等:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/runtime/type.go</span></div><div class="line"><span class="comment">// ptrType represents a pointer type.</span></div><div class="line"><span class="keyword">type</span> ptrType <span class="keyword">struct</span> &#123;</div><div class="line">   typ     _type   <span class="comment">// 指针类型 </span></div><div class="line">   elem  *_type <span class="comment">// 指针所指向的元素类型</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</div><div class="line">    typ  _type        <span class="comment">// channel类型</span></div><div class="line">    elem *_type     <span class="comment">// channel元素类型</span></div><div class="line">    dir  <span class="keyword">uintptr</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</div><div class="line">    typ           _type</div><div class="line">    key           *_type</div><div class="line">    elem          *_type</div><div class="line">    bucket        *_type <span class="comment">// internal type representing a hash bucket</span></div><div class="line">    hmap          *_type <span class="comment">// internal type representing a hmap</span></div><div class="line">    keysize       <span class="keyword">uint8</span>  <span class="comment">// size of key slot</span></div><div class="line">    indirectkey   <span class="keyword">bool</span>   <span class="comment">// store ptr to key instead of key itself</span></div><div class="line">    valuesize     <span class="keyword">uint8</span>  <span class="comment">// size of value slot</span></div><div class="line">    indirectvalue <span class="keyword">bool</span>   <span class="comment">// store ptr to value instead of value itself</span></div><div class="line">    bucketsize    <span class="keyword">uint16</span> <span class="comment">// size of bucket</span></div><div class="line">    reflexivekey  <span class="keyword">bool</span>   <span class="comment">// true if k==k for all keys</span></div><div class="line">    needkeyupdate <span class="keyword">bool</span>   <span class="comment">// true if we need to update key on an overwrite</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些类型信息的第一个字段都是<code>_type</code>(类型本身的信息)，接下来是一堆类型需要的其它详细信息(如子类型信息)，这样在进行类型相关操作时，可通过一个字(<code>typ *_type</code>)即可表述所有类型，然后再通过<code>_type.kind</code>可解析出其具体类型，最后通过地址转换即可得到类型完整的”_type树”，参考reflect.Type.Elem()函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reflect/type.go</span></div><div class="line"><span class="comment">// reflect.rtype结构体定义和runtime._type一致  type.kind定义也一致(为了分包而重复定义)</span></div><div class="line"><span class="comment">// Elem()获取rtype中的元素类型，只针对复合类型(Array, Chan, Map, Ptr, Slice)有效</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Type</span></span> &#123;</div><div class="line">   <span class="keyword">switch</span> t.Kind() &#123;</div><div class="line">   <span class="keyword">case</span> Array:</div><div class="line">      tt := (*arrayType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Chan:</div><div class="line">      tt := (*chanType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Map:</div><div class="line">      <span class="comment">// 对Map来讲，Elem()得到的是其Value类型</span></div><div class="line">      <span class="comment">// 可通过rtype.Key()得到Key类型</span></div><div class="line">      tt := (*mapType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Ptr:</div><div class="line">      tt := (*ptrType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Slice:</div><div class="line">      tt := (*sliceType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">panic</span>(<span class="string">"reflect: Elem of invalid type"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-iface"><a href="#2-iface" class="headerlink" title="2. iface"></a>2. iface</h3><p>iface结构体表示非空接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// runtime/runtime2.go</span></div><div class="line"><span class="comment">// 非空接口</span></div><div class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</div><div class="line">    tab  *itab</div><div class="line">    data unsafe.Pointer</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 非空接口的类型信息</span></div><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">    inter  *interfacetype    <span class="comment">// 接口定义的类型信息</span></div><div class="line">    _type  *_type                <span class="comment">// 接口实际指向值的类型信息</span></div><div class="line">    link   *itab  </div><div class="line">    bad    <span class="keyword">int32</span></div><div class="line">    inhash <span class="keyword">int32</span></div><div class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span>             <span class="comment">// 接口方法实现列表，即函数地址列表，按字典序排序</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// runtime/type.go</span></div><div class="line"><span class="comment">// 非空接口类型，接口定义，包路径等。</span></div><div class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</div><div class="line">   typ     _type</div><div class="line">   pkgpath name</div><div class="line">   mhdr    []imethod      <span class="comment">// 接口方法声明列表，按字典序排序</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 接口的方法声明 </span></div><div class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</div><div class="line">   name nameOff          <span class="comment">// 方法名</span></div><div class="line">   ityp typeOff                <span class="comment">// 描述方法参数返回值等细节</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非空接口(iface)本身除了可以容纳满足其接口的对象之外，还需要保存其接口的方法，因此除了data字段，iface通过tab字段描述非空接口的细节，包括接口方法定义，接口方法实现地址，接口所指类型等。iface是非空接口的实现，而不是类型定义，iface的真正类型为interfacetype，其第一个字段仍然为描述其自身类型的_type字段。</p><p>为了提高查找效率，runtime中实现(interface_type, concrete_type) -&gt; itab(包含具体方法实现地址等信息)的hash表:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// runtime/iface.go</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">   hashSize = <span class="number">1009</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">   ifaceLock mutex <span class="comment">// lock for accessing hash</span></div><div class="line">   hash      [hashSize]*itab</div><div class="line">)</div><div class="line"><span class="comment">// 简单的Hash算法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</div><div class="line">   h := inter.typ.hash</div><div class="line">   h += <span class="number">17</span> * typ.hash</div><div class="line">   <span class="keyword">return</span> h % hashSize</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 根据interface_type和concrete_type获取或生成itab信息</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</div><div class="line">   ...</div><div class="line"><span class="comment">// 算出hash key</span></div><div class="line">   h := itabhash(inter, typ)</div><div class="line"></div><div class="line"></div><div class="line">   <span class="keyword">var</span> m *itab</div><div class="line">   ...</div><div class="line">   <span class="comment">// 遍历hash slot链表</span></div><div class="line">      <span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</div><div class="line">         <span class="comment">// 如果在hash表中找到则返回</span></div><div class="line">         <span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</div><div class="line">            <span class="keyword">if</span> m.bad &#123;</div><div class="line">               <span class="keyword">if</span> !canfail &#123;</div><div class="line">                  additab(m, locked != <span class="number">0</span>, <span class="literal">false</span>)</div><div class="line">               &#125;</div><div class="line">               m = <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">            <span class="keyword">return</span> m</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">    <span class="comment">// 如果没有找到，则尝试生成itab(会检查是否满足接口)</span></div><div class="line">   m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</div><div class="line">   m.inter = inter</div><div class="line">   m._type = typ</div><div class="line">   additab(m, <span class="literal">true</span>, canfail)</div><div class="line">   <span class="keyword">if</span> m.bad &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> m</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 检查concrete_type是否符合interface_type 并且创建对应的itab结构体 将其放到hash表中</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">   inter := m.inter</div><div class="line">   typ := m._type</div><div class="line">   x := typ.uncommon()</div><div class="line"></div><div class="line">   ni := <span class="built_in">len</span>(inter.mhdr)</div><div class="line">   nt := <span class="keyword">int</span>(x.mcount)</div><div class="line">   xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</div><div class="line">   j := <span class="number">0</span></div><div class="line">   <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</div><div class="line">      i := &amp;inter.mhdr[k]</div><div class="line">      itype := inter.typ.typeOff(i.ityp)</div><div class="line">      name := inter.typ.nameOff(i.name)</div><div class="line">      iname := name.name()</div><div class="line">      ipkg := name.pkgPath()</div><div class="line">      <span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</div><div class="line">         ipkg = inter.pkgpath.name()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</div><div class="line">         t := &amp;xmhdr[j]</div><div class="line">         tname := typ.nameOff(t.name)</div><div class="line">         <span class="comment">// 检查方法名字是否一致</span></div><div class="line">         <span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</div><div class="line">            pkgPath := tname.pkgPath()</div><div class="line">            <span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</div><div class="line">               pkgPath = typ.nameOff(x.pkgpath).name()</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 是否导出或在同一个包</span></div><div class="line">            <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</div><div class="line">               <span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</div><div class="line">                    <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></div><div class="line">                  ifn := typ.textOff(t.ifn)</div><div class="line">                  *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">goto</span> nextimethod</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// didn't find method</span></div><div class="line">      <span class="keyword">if</span> !canfail &#123;</div><div class="line">         <span class="keyword">if</span> locked &#123;</div><div class="line">            unlock(&amp;ifaceLock)</div><div class="line">         &#125;</div><div class="line">         <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="string">""</span>, typ.<span class="keyword">string</span>(), inter.typ.<span class="keyword">string</span>(), iname&#125;)</div><div class="line">      &#125;</div><div class="line">      m.bad = <span class="literal">true</span></div><div class="line">      <span class="keyword">break</span></div><div class="line">   nextimethod:</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> !locked &#123;</div><div class="line">      throw(<span class="string">"invalid itab locking"</span>)</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 加到Hash Slot链表中</span></div><div class="line">   h := itabhash(inter, typ)</div><div class="line">   m.link = hash[h]</div><div class="line">   m.inhash = <span class="literal">true</span></div><div class="line">   atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，并不是每次接口赋值都要去检查一次对象是否符合接口要求，而是只在第一次生成itab信息，之后通过hash表即可找到itab信息。</p><h3 id="3-接口赋值"><a href="#3-接口赋值" class="headerlink" title="3. 接口赋值"></a>3. 接口赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</div><div class="line">   Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms MyStruct)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   a := <span class="number">1</span></div><div class="line">   b := <span class="string">"str"</span></div><div class="line">   c := MyStruct&#123;&#125;</div><div class="line">   <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125; = a</div><div class="line">   <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = b</div><div class="line">   <span class="keyword">var</span> i3 MyInterface = c</div><div class="line">   <span class="keyword">var</span> i4 <span class="keyword">interface</span>&#123;&#125; = i3</div><div class="line">   <span class="keyword">var</span> i5 = i4.(MyInterface)</div><div class="line">   fmt.Println(i1, i2, i3, i4, i5)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用go1.8编译并反汇编:</p><pre><code>$GO1.8PATH/bin/go build -gcflags &#39;-N -l&#39; -o tmp tmp.go$GO1.8PATH/bin/go tool objdump -s &quot;main\.main&quot; tmp</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">tmp.go:18 0x1087165 e84645f8ff CALL runtime.convT2E(SB)    // var i1 interface&#123;&#125; = a</div><div class="line">...</div><div class="line">tmp.go:19 0x10871bc e8ef44f8ff CALL runtime.convT2E(SB)    // var i2 interface&#123;&#125; = b</div><div class="line">...</div><div class="line">tmp.go:20 0x10871f0 e86b45f8ff CALL runtime.convT2I(SB)    // var i3 MyInterface = c</div><div class="line">tmp.go:20       0x10871f5       488b442410                      MOVQ 0x10(SP), AX    // 返回的iface.itab地址</div><div class="line">tmp.go:20       0x10871fa       488b4c2418                      MOVQ 0x18(SP), CX   // 返回的iface.data地址</div><div class="line">tmp.go:20       0x10871ff       4889842480000000                MOVQ AX, 0x80(SP)  // i3.tab = iface.itab</div><div class="line">tmp.go:20       0x1087207       48898c2488000000                MOVQ CX, 0x88(SP)  // i3.data = iface.data</div><div class="line">tmp.go:21       0x108720f       488b842488000000                MOVQ 0x88(SP), AX</div><div class="line">tmp.go:21       0x1087217       488b8c2480000000                MOVQ 0x80(SP), CX</div><div class="line">tmp.go:21       0x108721f       48898c24e0000000                MOVQ CX, 0xe0(SP) // 0xe0(SP) = i3.tab</div><div class="line">tmp.go:21       0x1087227       48898424e8000000                MOVQ AX, 0xe8(SP) // 0xe8(SP) = i3.data</div><div class="line">tmp.go:21       0x108722f       48894c2448                      MOVQ CX, 0x48(SP)</div><div class="line">...</div><div class="line">// var i4 interface&#123;&#125; = i3</div><div class="line">tmp.go:21       0x108724b       488b8424e8000000                MOVQ 0xe8(SP), AX    // 加载i3的data</div><div class="line">tmp.go:21       0x1087253       488b4c2448                      MOVQ 0x48(SP), CX    // 加载i3的tab(即interfacetype地址)</div><div class="line">tmp.go:21       0x1087258       48894c2470                      MOVQ CX, 0x70(SP)    // i4._type = i3.interfacetype</div><div class="line">tmp.go:21       0x108725d       4889442478                      MOVQ AX, 0x78(SP)   // i4.data = i3.data</div><div class="line">...</div><div class="line">// var i5 = i4.(MyInterface)﻿​</div><div class="line">tmp.go:22       0x1087299       e87245f8ff                      CALL runtime.assertE2I(SB)</div><div class="line">...</div></pre></td></tr></table></figure><p>可以看到编译器通过convT2E和convT2I将编译器已知的类型赋给接口(其中E代表eface，I代表iface，T代表编译器已知类型，即静态类型)，编译器知晓itab的布局，会在编译期检查接口是否适配，并且生成itab信息，因此编译器生成的convT2X调用是必然成功的。</p><p>对于接口间的赋值，将iface赋给eface比较简单，直接提取eface的interfacetype和data赋给iface即可。而反过来，则需要使用接口断言，接口断言通过assertE2I, assertI2I等函数来完成，这类assert函数根据使用方调用方式有两个版本:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i5 := i4.(MyInterface)         <span class="comment">// call conv.assertE2I</span></div><div class="line">i5, ok := i4.(MyInterface)  <span class="comment">//  call conv.AssertE2I2</span></div></pre></td></tr></table></figure><p>下面看一下几个常用的conv和assert函数实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go1.8/src/runtime/iface.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E</span><span class="params">(t *_type, elem unsafe.Pointer)</span> <span class="params">(e eface)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> raceenabled &#123;</div><div class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;t)), funcPC(convT2E))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> msanenabled &#123;</div><div class="line">        msanread(elem, t.size)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> isDirectIface(t) &#123;</div><div class="line">        <span class="comment">// This case is implemented directly by the compiler.</span></div><div class="line">        throw(<span class="string">"direct convT2E"</span>)</div><div class="line">    &#125;</div><div class="line">    x := newobject(t)</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> We allocate a zeroed object only to overwrite it with</span></div><div class="line">    <span class="comment">// actual data. Figure out how to avoid zeroing. Also below in convT2I.</span></div><div class="line">    typedmemmove(t, x, elem)</div><div class="line">    e._type = t</div><div class="line">    e.data = x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</div><div class="line">    t := tab._type</div><div class="line">    <span class="keyword">if</span> raceenabled &#123;</div><div class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> msanenabled &#123;</div><div class="line">        msanread(elem, t.size)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> isDirectIface(t) &#123;</div><div class="line">        <span class="comment">// This case is implemented directly by the compiler.</span></div><div class="line">        throw(<span class="string">"direct convT2I"</span>)</div><div class="line">    &#125;</div><div class="line">    x := newobject(t)</div><div class="line">    typedmemmove(t, x, elem)</div><div class="line">    i.tab = tab</div><div class="line">    i.data = x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I</span><span class="params">(inter *interfacetype, e eface)</span> <span class="params">(r iface)</span></span> &#123;</div><div class="line">    t := e._type</div><div class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">        <span class="comment">// explicit conversions require non-nil interface value.</span></div><div class="line">        <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="string">""</span>, <span class="string">""</span>, inter.typ.<span class="keyword">string</span>(), <span class="string">""</span>&#125;)</div><div class="line">    &#125;</div><div class="line">    r.tab = getitab(inter, t, <span class="literal">false</span>)</div><div class="line">    r.data = e.data</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在assertE2I中，我们看到了getitab函数，即<code>i5=i4.(MyInterface)</code>中，会去判断i4的concretetype(MyStruct)是否满足MyInterface的interfacetype，由于前面我们执行过<code>var i3 MyInterface = c</code>，因此hash[itabhash(MyInterface, MyStruct)]已经存在itab，所以无需再次检查接口是否满足，从hash表中取出itab即可(里面针对接口的各个方法实现地址都已经初始化完成)。</p><p>而在go1.9中，有一些优化:</p><p>1.对convT2x针对简单类型(如int32,string,slice)进行特例化优化(避免typedmemmove):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">convT2E16, convT2I16</div><div class="line">convT2E32, convT2I32</div><div class="line">convT2E64, convT2I64</div><div class="line">convT2Estring, convT2Istring</div><div class="line">convT2Eslice, convT2Islice</div><div class="line">convT2Enoptr, convT2Inoptr</div></pre></td></tr></table></figure><p>据统计，在编译make.bash的时候，有93%的convT2x调用都可通过以上特例化优化。参考<a href="https://go-review.googlesource.com/c/go/+/36476" target="_blank" rel="external">这里</a>。</p><p>2.优化了剩余对convT2I的调用</p><p>由于itab由编译器生成(参考上面go1.8生成的汇编代码和convT2I函数)，可以直接由编译器将itab和elem直接赋给iface的tab和data字段，避免函数调用和typedmemmove。关于此优化可参考<a href="https://go-review.googlesource.com/c/go/+/20901/9" target="_blank" rel="external">1</a>和<a href="https://go-review.googlesource.com/c/go/+/20902" target="_blank" rel="external">2</a>。</p><p>具体汇编代码不再列出，感兴趣的同学可以自己尝试。</p><h3 id="4-类型反射"><a href="#4-类型反射" class="headerlink" title="4. 类型反射"></a>4. 类型反射</h3><p>类型反射无非就是将eface{}的_type和data字段取出进行解析，针对TypeOf的实现很简单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// 代码位于relect/type.go</div><div class="line"></div><div class="line">// reflect.Type接口的实现为: reflect.rtype</div><div class="line">// reflect.rtype结构体定义和runtime._type一样，只是实现了reflect.Type接口，实现了一些诸如Elem()，Name()之类的方法:</div><div class="line"></div><div class="line">func TypeOf(i interface&#123;&#125;) Type &#123;</div><div class="line">    // emptyInterface结构体定义与eface一样，都是两个word(type和data)</div><div class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</div><div class="line">    return toType(eface.typ)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// reflect.Type.Elem()仅对复合类型有效(Array,Ptr,Map,Chan,Slice)，取出其中的子类型</div><div class="line">func (t *rtype) Elem() Type &#123;</div><div class="line">    switch t.Kind() &#123;</div><div class="line">    case Array:</div><div class="line">        tt := (*arrayType)(unsafe.Pointer(t))</div><div class="line">        return toType(tt.elem)</div><div class="line">    case Chan:</div><div class="line">        tt := (*chanType)(unsafe.Pointer(t))</div><div class="line">        return toType(tt.elem)</div><div class="line">    case Map:</div><div class="line">        tt := (*mapType)(unsafe.Pointer(t))</div><div class="line">        // 对mapType来说，tt.elem实际上是value的类型，可通过t.Key()来获取key类型</div><div class="line">        return toType(tt.elem)</div><div class="line">    case Ptr:</div><div class="line">        tt := (*ptrType)(unsafe.Pointer(t))</div><div class="line">        return toType(tt.elem)</div><div class="line">    case Slice:</div><div class="line">        tt := (*sliceType)(unsafe.Pointer(t))</div><div class="line">        return toType(tt.elem)</div><div class="line">    &#125;</div><div class="line">    panic(&quot;reflect: Elem of invalid type&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>reflect.ValueOf则要复杂一些，因为它需要根据type来决定数据应该如何被解释，因此实际上reflect.Value也包含类型信息，并且通过一个flag字段来标识只读属性，是否为指针等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">type Value struct &#123;</div><div class="line">    // 值的类型</div><div class="line">    typ *rtype</div><div class="line">    // 立即数或指向数据的指针</div><div class="line">    ptr unsafe.Pointer</div><div class="line">    // type flag uintptr</div><div class="line">    // 指明值的类型，是否只读，ptr字段是否是指针等</div><div class="line">    flag</div><div class="line">&#125;</div><div class="line"></div><div class="line">func ValueOf(i interface&#123;&#125;) Value &#123;</div><div class="line">    if i == nil &#123;</div><div class="line">        return Value&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    escapes(i)</div><div class="line"></div><div class="line">    return unpackEface(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将数据从interface&#123;&#125;解包为reflec.Value</div><div class="line">func unpackEface(i interface&#123;&#125;) Value &#123;</div><div class="line">    e := (*emptyInterface)(unsafe.Pointer(&amp;i))</div><div class="line">    // NOTE: don&apos;t read e.word until we know whether it is really a pointer or not.</div><div class="line">    t := e.typ</div><div class="line">    if t == nil &#123;</div><div class="line">        return Value&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    f := flag(t.Kind())</div><div class="line">    if ifaceIndir(t) &#123;</div><div class="line">        f |= flagIndir</div><div class="line">    &#125;</div><div class="line">    return Value&#123;t, e.word, f&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将数据由reflect.Value打包为interface&#123;&#125;</div><div class="line">func packEface(v Value) interface&#123;&#125; &#123;</div><div class="line">    t := v.typ</div><div class="line">    var i interface&#123;&#125;</div><div class="line">    e := (*emptyInterface)(unsafe.Pointer(&amp;i))</div><div class="line">    // First, fill in the data portion of the interface.</div><div class="line">    switch &#123;</div><div class="line">    case ifaceIndir(t):</div><div class="line">        if v.flag&amp;flagIndir == 0 &#123;</div><div class="line">            panic(&quot;bad indir&quot;)</div><div class="line">        &#125;</div><div class="line">        ptr := v.ptr</div><div class="line">        if v.flag&amp;flagAddr != 0 &#123;</div><div class="line">            c := unsafe_New(t)</div><div class="line">            typedmemmove(t, c, ptr)</div><div class="line">            ptr = c</div><div class="line">        &#125;</div><div class="line">        e.word = ptr</div><div class="line">    case v.flag&amp;flagIndir != 0:</div><div class="line">        e.word = *(*unsafe.Pointer)(v.ptr)</div><div class="line">    default:</div><div class="line">        e.word = v.ptr</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    e.typ = t</div><div class="line">    return i</div><div class="line"></div><div class="line">// reflect.Value的Elem()方法仅对引用类型(Ptr和Interface&#123;&#125;)有效，返回其引用的值</div><div class="line">func (v Value) Elem() Value &#123;</div><div class="line">    k := v.kind()</div><div class="line">    switch k &#123;</div><div class="line">    case Interface:</div><div class="line">        var eface interface&#123;&#125;</div><div class="line">        if v.typ.NumMethod() == 0 &#123;</div><div class="line">            eface = *(*interface&#123;&#125;)(v.ptr)</div><div class="line">        &#125; else &#123;</div><div class="line">            eface = (interface&#123;&#125;)(*(*interface &#123;</div><div class="line">                M()</div><div class="line">            &#125;)(v.ptr))</div><div class="line">        &#125;</div><div class="line">        x := unpackEface(eface)</div><div class="line">        if x.flag != 0 &#123;</div><div class="line">            x.flag |= v.flag &amp; flagRO</div><div class="line">        &#125;</div><div class="line">        return x</div><div class="line">    case Ptr:</div><div class="line">        ptr := v.ptr</div><div class="line">        if v.flag&amp;flagIndir != 0 &#123;</div><div class="line">            ptr = *(*unsafe.Pointer)(ptr)</div><div class="line">        &#125;</div><div class="line">        // The returned value&apos;s address is v&apos;s value.</div><div class="line">        if ptr == nil &#123;</div><div class="line">            return Value&#123;&#125;</div><div class="line">        &#125;</div><div class="line">        tt := (*ptrType)(unsafe.Pointer(v.typ))</div><div class="line">        typ := tt.elem</div><div class="line">        fl := v.flag&amp;flagRO | flagIndir | flagAddr</div><div class="line">        fl |= flag(typ.Kind())</div><div class="line">        return Value&#123;typ, ptr, fl&#125;</div><div class="line">    &#125;</div><div class="line">    panic(&amp;ValueError&#123;&quot;reflect.Value.Elem&quot;, v.kind()&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考:</p><ol><li><a href="https://studygolang.com/articles/2917" target="_blank" rel="external">Golang汇编快速指南</a></li><li><a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="external">Go Interface源码剖析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从源码的角度学习下Go接口的底层实现，以及接口赋值，反射，断言的实现原理。作为对比，用到了go1.8.6和go1.9.1两个版本。&lt;/p&gt;
&lt;h3 id=&quot;1-eface&quot;&gt;&lt;a href=&quot;#1-eface&quot; class=&quot;headerlink&quot; title=&quot;1. eface&quot;&gt;&lt;/a&gt;1. eface&lt;/h3&gt;&lt;p&gt;空接口通过eface结构体实现，位于runtime/runtime2.go: &lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go 调度模型</title>
    <link href="http://wudaijun.com/2018/01/go-scheduler/"/>
    <id>http://wudaijun.com/2018/01/go-scheduler/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-23T02:03:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="G-P-M-模型"><a href="#G-P-M-模型" class="headerlink" title="G P M 模型"></a>G P M 模型</h3><p>定义于src/runtime/runtime2.go:</p><ul><li>G: Gourtines, 每个Goroutine对应一个G结构体，G保存Goroutine的运行堆栈，即并发任务状态。G并非执行体，每个G需要绑定到P才能被调度执行。</li><li>P: Processors, 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等</li><li>M: Machine, OS线程抽象，负责调度任务，和某个P绑定，从P的runq中不断取出G，切换堆栈并执行，M本身不具备执行状态，在需要任务切换时，M将堆栈状态写回G，任何其它M都能据此恢复执行。</li></ul><a id="more"></a><p>Go1.1之前只有G-M模型，没有P，Dmitry Vyukov在<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw" target="_blank" rel="external">Scalable Go Scheduler Design Doc</a>提出该模型在并发伸缩性方面的问题，并通过加入P(Processors)来改进该问题。</p><p>G-P-M模型示意图:</p><p><img src="/assets/image/go/go-schedule.png" alt=""></p><p>补充说明:</p><ol><li>P的个数由GOMAXPROCS指定，是固定的，因此限制最大并发数</li><li>M的个数是不定的，由Go Runtime调整，默认最大限制为10000个</li></ol><h3 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h3><p>在M与P绑定后，M会不断从P的Local队列(runq)中取出G(无锁操作)，切换到G的堆栈并执行，当P的Local队列中没有G时，再从Global队列中返回一个G(有锁操作，因此实际还会从Global队列批量转移一批G到P Local队列)，当Global队列中也没有待运行的G时，则尝试从其它的P窃取(steal)部分G来执行，源代码如下:</p><pre><code>// go1.9.1  src/runtime/proc.go// 省略了GC检查等其它细节，只保留了主要流程// g:       G结构体定义// sched:   Global队列// 获取一个待执行的Gfunc findrunnable() (gp *g, inheritTime bool) {    // 获取当前的G对象    _g_ := getg()top:    // 获取当前P对象    _p_ := _g_.m.p.ptr()    // 1. 尝试从P的Local队列中取得G 优先_p_.runnext 然后再从Local队列中取    if gp, inheritTime := runqget(_p_); gp != nil {        return gp, inheritTime    }    // 2. 尝试从Global队列中取得G    if sched.runqsize != 0 {        lock(&amp;sched.lock)        // globrunqget从Global队列中获取G 并转移一批G到_p_的Local队列        gp := globrunqget(_p_, 0)        unlock(&amp;sched.lock)        if gp != nil {            return gp, false        }    }    // 3. 检查netpoll任务    if netpollinited() &amp;&amp; sched.lastpoll != 0 {        if gp := netpoll(false); gp != nil { // non-blocking            // netpoll返回的是G链表，将其它G放回Global队列            injectglist(gp.schedlink.ptr())            casgstatus(gp, _Gwaiting, _Grunnable)            if trace.enabled {                traceGoUnpark(gp, 0)            }            return gp, false        }    }    // 4. 尝试从其它P窃取任务    procs := uint32(gomaxprocs)    if atomic.Load(&amp;sched.npidle) == procs-1 {        goto stop    }    if !_g_.m.spinning {        _g_.m.spinning = true        atomic.Xadd(&amp;sched.nmspinning, 1)    }    for i := 0; i &lt; 4; i++ {        // 随机P的遍历顺序        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {            if sched.gcwaiting != 0 {                goto top            }            stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g            // runqsteal执行实际的steal工作，从目标P的Local队列转移一般的G过来            // stealRunNextG指是否steal目标P的p.runnext G            if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {                return gp, false            }        }    }    ...}</code></pre><p>当没有G可被执行时，M会与P解绑，然后进入休眠(idle)状态。</p><h3 id="用户态阻塞-唤醒"><a href="#用户态阻塞-唤醒" class="headerlink" title="用户态阻塞/唤醒"></a>用户态阻塞/唤醒</h3><p>当Goroutine因为Channel操作而阻塞(通过gopark)时，对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而M会跳过该G尝试获取并执行下一个G。</p><p>当阻塞的G被G2唤醒(通过goready)时(比如channel可读/写)，G会尝试加入G2所在P的runnext，然后再是P Local队列和Global队列。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当G被阻塞在某个系统调用上时，此时G会阻塞在<code>_Gsyscall</code>状态，M也处于block on syscall状态，此时仍然可被抢占调度: 执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但队列中仍然有G需要执行，则创建一个新的M。</p><p>当系统调用完成后，G会重新尝试获取一个idle的P，并恢复执行，如果没有idle的P，G将加入到Global队列。</p><p>系统调用能被调度的关键有两点:</p><p>runtime/syscall包中，将系统调用分为SysCall和RawSysCall，前者和后者的区别是前者会在系统调用前后分别调用entersyscall和exitsyscall(位于src/runtime/proc.go)，做一些现场保存和恢复操作，这样才能使P安全地与M解绑，并在其它M上继续执行其它G。某些系统调用本身可以确定会长时间阻塞(比如锁)，会调用entersyscallblock在发起系统调用前直接让P和M解绑(handoffp)。</p><p>另一个关键点是sysmon，它负责检查所有系统调用的执行时间，判断是否需要handoffp。</p><h3 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h3><p>sysmon是一个由runtime启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次，主要执行:</p><ol><li>释放闲置超过5分钟的span物理内存； </li><li>如果超过2分钟没有垃圾回收，强制执行；</li><li>将长时间未处理的netpoll结果添加到任务队列；</li><li>向长时间运行的G任务发出抢占调度； </li><li>收回因syscall长时间阻塞的P；</li></ol><p>入口在src/runtime/proc.go:sysmon函数，它通过retake实现对syscall和长时间运行的G进行调度:</p><pre><code>func retake(now int64) uint32 {    n := 0    for i := int32(0); i &lt; gomaxprocs; i++ {        _p_ := allp[i]        if _p_ == nil {            continue        }        pd := &amp;_p_.sysmontick        s := _p_.status        if s == _Psyscall {            // Retake P from syscall if it&#39;s there for more than 1 sysmon tick (at least 20us).            t := int64(_p_.syscalltick)            if int64(pd.syscalltick) != t {                pd.syscalltick = uint32(t)                pd.syscallwhen = now                continue            }            // 如果当前P Local队列没有其它G，当前有其它P处于Idle状态，并且syscall执行事件不超过10ms，则不用解绑当前P(handoffp)            if runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; 0 &amp;&amp; pd.syscallwhen+10*1000*1000 &gt; now {                continue            }            // handoffp            incidlelocked(-1)            if atomic.Cas(&amp;_p_.status, s, _Pidle) {                if trace.enabled {                    traceGoSysBlock(_p_)                    traceProcStop(_p_)                }                n++                _p_.syscalltick++                handoffp(_p_)            }            incidlelocked(1)        } else if s == _Prunning {            // Preempt G if it&#39;s running for too long.            t := int64(_p_.schedtick)            if int64(pd.schedtick) != t {                pd.schedtick = uint32(t)                pd.schedwhen = now                continue            }            // 如果当前G执行时间超过10ms，则抢占(preemptone)            if pd.schedwhen+forcePreemptNS &gt; now {                continue            }            // 执行抢占            preemptone(_p_)        }    }    return uint32(n)}</code></pre><h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p>当某个goroutine执行超过10ms，sysmon会向其发起抢占调度请求，由于Go调度不像OS调度那样有时间片的概念，因此实际抢占机制要弱很多: Go中的抢占实际上是为G设置抢占标记(g.stackguard0)，当G调用某函数时(更确切说，在通过newstack分配函数栈时)，被编译器安插的指令会检查这个标记，并且将当前G以runtime.Goched的方式暂停，并加入到全局队列。源代码如下:</p><pre><code>// src/runtime/stack.go// Called from runtime·morestack when more stack is needed.// Allocate larger stack and relocate to new stack.// Stack growth is multiplicative, for constant amortized cost.func newstack(ctxt unsafe.Pointer) {    ...    // gp为当前G    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt    if preempt {        ...        // Act like goroutine called runtime.Gosched.        // G状态由_Gwaiting变为 _Grunning 这是为了能以Gosched的方式暂停Go        casgstatus(gp, _Gwaiting, _Grunning)        gopreempt_m(gp) // never return    }}// 以goched的方式将G重新放入func goschedImpl(gp *g) {    status := readgstatus(gp)    // 由Running变为Runnable    casgstatus(gp, _Grunning, _Grunnable)    // 与M解除绑定    dropg()    lock(&amp;sched.lock)    // 将G放入Global队列    globrunqput(gp)    unlock(&amp;sched.lock)    // 重新调度    schedule()}func gopreempt_m(gp *g) {    if trace.enabled {        traceGoPreempt()    }    goschedImpl(gp)}</code></pre><h3 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h3><p>前面的findrunnable，G的获取除了p.runnext，p.runq和sched.runq外，还有一中G从netpoll中获取，<a href="http://morsmachine.dk/netpoller" target="_blank" rel="external">netpoll</a>是Go针对网络IO的一种优化，本质上为了避免网络IO陷入系统调用之中，这样使得即便G发起网络I/O操作也不会导致M被阻塞（仅阻塞G），从而不会导致大量M被创建出来。</p><h3 id="G创建流程"><a href="#G创建流程" class="headerlink" title="G创建流程"></a>G创建流程</h3><p>G结构体会复用，对可复用的G管理类似于待运行的G管理，也有Local队列(p.gfree)和Global队列(sched.gfree)之分，获取算法差不多，优先从p.gfree中获取(无锁操作)，否则从sched.gfree中获取并批量转移一部分(有锁操作)，源代码参考src/runtime/proc.go:gfget函数。</p><p>从Goroutine的角度来看，通过<code>go func()</code>创建时，会从当前闲置的G队列取得可复用的G，如果没有则通过malg新建一个G，然后:</p><ol><li>尝试将G添加到当前P的runnext中，作为下一个执行的G</li><li>否则放到Local队列runq中(无锁)</li><li>如果以上操作都失败，则添加到Global队列sched.runq中(有锁操作，因此也会顺便将当P.runq中一半的G转移到sched.runq)</li></ol><h3 id="G的几种暂停方式"><a href="#G的几种暂停方式" class="headerlink" title="G的几种暂停方式:"></a>G的几种暂停方式:</h3><ol><li>goched: 将当前的G暂停，保存堆栈状态，以Runnable状态放入Global队列中，让当前M继续执行其它任务。无需对G进行唤醒操作，因为总会有M从Global队列取得并执行该M。抢占调度即使用该方式。</li><li>gopark: 与goched的最大区别在于gopark没有将G放回执行队列，而是位于某个等待队列中(如channel的waitq，此时G状态为<code>_Gwaitting</code>)，因此G必须被手动唤醒(通过goready)，否则会丢失任务。应用层阻塞通常使用这种方式。</li><li>notesleep: 既不让出M，也不让G重回任务队列，直接让线程休眠直到被唤醒，该方式更快，通常用于gcMark，stopm这类自旋场景</li><li>goexit: 立即终止G任务，不管其处于调用堆栈的哪个层次，在终止前，确保所有defer正确执行。</li></ol><h3 id="Go调度器的查看方法"><a href="#Go调度器的查看方法" class="headerlink" title="Go调度器的查看方法"></a>Go调度器的查看方法</h3><p>示例程序，对比cgo sleep和time.sleep系统调用情况:</p><pre><code>// #include &lt;unistd.h&gt;import &quot;C&quot;func main() {    var wg sync.WaitGroup    wg.Add(1000)    for i := 0; i &lt; 1000; i++ {        go func() {            C.sleep(1)                     // 测试1            // time.Sleep(time.Second)     // 测试2            wg.Done()        }()    }    wg.Wait()    println(&quot;done!&quot;)    time.Sleep(time.Second * 3)}</code></pre><p>通过GODEBUG运行时环境变量的schedtrace=1000参数，可以每隔1000ms查看一次调度器状态:</p><pre><code>$ GODEBUG=schedtrace=1000 ./test// 测试1输出结果SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=1003 spinningthreads=2 idlethreads=32 runqueue=0 [0 0 0 0]done!SCHED 1001ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]SCHED 2001ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]SCHED 3010ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]// 测试2输出结果SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=1 idlethreads=2 runqueue=129 [0 128 0 0]done!SCHED 1009ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]SCHED 2010ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]SCHED 3019ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</code></pre><p>其中schedtrace日志每一行的字段意义:</p><pre><code>SCHED：调试信息输出标志字符串，代表本行是goroutine scheduler的输出；1001ms：即从程序启动到输出这行日志的时间；gomaxprocs: P的数量；idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；threads: os threads的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；spinningthreads: 处于自旋状态的os thread数量；idlethread: 处于idle状态的os thread的数量；runqueue： go scheduler全局队列中G的数量；[0 0 0 0]: 分别为4个P的local queue中的G的数量。</code></pre><p>可以看出，time.Sleep并没有使用系统调用，而是进行了类似netpoll类似的优化，使得仅仅是G阻塞，M不会阻塞，而在使用cgo sleep的情况下，可以看到大量的闲置M。</p><p>通过运行时环境变量GODEBUG的schedtrace参数可定时查看调度器状态:</p><pre><code>// 每1000ms打印一次$GODEBUG=schedtrace=1000 godoc -http=:6060SCHED 0ms: gomaxprocs=4 idleprocs=3 threads=3 spinningthreads=0 idlethreads=0 runqueue=0 [0 0 0 0]SCHED 1001ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=0 idlethreads=3 runqueue=2 [8 14 5 2]SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=25 spinningthreads=0 idlethreads=19 runqueue=12 [0 0 4 0]SCHED 3006ms: gomaxprocs=4 idleprocs=0 threads=26 spinningthreads=0 idlethreads=8 runqueue=2 [0 1 1 0]...</code></pre><p> GODEBUG还可使用<code>GODEBUG=&quot;schedtrace=1000,scheddetail=1&quot;</code>选项来查看每个G,P,M的调度状态，打出的信息非常详尽复杂，平时应该是用不到。关于Go调试可参考Dmitry Vyukov大牛的<a href="https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs" target="_blank" rel="external">Debugging performance issues in Go programs</a>。</p><p>参考资料:</p><ol><li><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="external">scheduler-tracing-in-go</a></li><li><a href="http://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="external">也谈goroutine调度器—TonyBai</a></li><li><a href="https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf" target="_blank" rel="external">Go学习笔记—雨痕</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;G-P-M-模型&quot;&gt;&lt;a href=&quot;#G-P-M-模型&quot; class=&quot;headerlink&quot; title=&quot;G P M 模型&quot;&gt;&lt;/a&gt;G P M 模型&lt;/h3&gt;&lt;p&gt;定义于src/runtime/runtime2.go:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G: Gourtines, 每个Goroutine对应一个G结构体，G保存Goroutine的运行堆栈，即并发任务状态。G并非执行体，每个G需要绑定到P才能被调度执行。&lt;/li&gt;
&lt;li&gt;P: Processors, 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等&lt;/li&gt;
&lt;li&gt;M: Machine, OS线程抽象，负责调度任务，和某个P绑定，从P的runq中不断取出G，切换堆栈并执行，M本身不具备执行状态，在需要任务切换时，M将堆栈状态写回G，任何其它M都能据此恢复执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>常见GC算法</title>
    <link href="http://wudaijun.com/2017/12/gc-study/"/>
    <id>http://wudaijun.com/2017/12/gc-study/</id>
    <published>2017-12-02T16:00:00.000Z</published>
    <updated>2017-12-20T08:12:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看GC(自动垃圾回收)的主要问题:</p><ol><li>额外的开销(内存/CPU)</li><li>执行GC的时机无法预测，在实时性要求高的场景或事务处理来说可能是不可容忍的</li><li>部分GC算法会Stop-the-world</li></ol><p>各语言运行时在选取GC算法时，都要从这几个方面进行衡量与取舍，下面是一些常见的GC算法。</p><a id="more"></a><h3 id="引用计数-Reference-counting"><a href="#引用计数-Reference-counting" class="headerlink" title="引用计数(Reference counting):"></a>引用计数(Reference counting):</h3><p>为每个对象维护一个计数，保存其它对象指向它的引用数量。当一个引用被覆盖或销毁，该引用对象的引用计数-1，当一个引用被建立或拷贝，引用对象的引用计数+1，如果对象的引用计数为0，则表明该对象不再被访问(inaccessible)，将被回收。引用计数有如下优缺点:</p><p>优点:</p><ol><li>GC开销将被均摊到程序运行期，不会有长时间的回收周期。</li><li>每个对象的生命周期被明确定义，可用于某些编译器的runtime优化。</li><li>算法简单，易于实现。</li><li>即时回收，不会等内存状态到达某个阀值再执行回收。</li></ol><p>缺点:</p><ol><li>引用计数会频繁更新，带来效率开销</li><li>原生的引用计数算法无法回收循环引用的对象链(如<a href="http://wudaijun.com/2014/12/shared_ptr-reference/">C++ shared_ptr引用链</a>)</li></ol><p>针对第一个频繁更新的缺点，可以使用延迟更新和合并更新等技术，这通常能够很好优化局部频繁的引用更新(如for循环)，虽然这也增加了算法实现复杂度。</p><p>针对循环引用的问题，一种解决方案是弱引用(<a href="https://en.wikipedia.org/wiki/Weak_reference" target="_blank" rel="external">weak reference</a>)，弱引用不影响GC，通常的实践是owner持有child的强引用，child持有owner的弱引用，在事件注册器或其它容器中，如果你只希望保存这个引用，但不希望这个引用影响GC时，也可弱引用。弱引用在使用时，需要先判断对象是否还存在，如C++的weak_ptr需要先转换为shared_ptr。但这不能完全避免无意的循环墙引用，一些GC算法可以检测循环引用，例如以追踪式GC的思路，从根出发，回收那些不可达的对象。</p><h3 id="标记-清扫-Mark-and-Sweep"><a href="#标记-清扫-Mark-and-Sweep" class="headerlink" title="标记-清扫(Mark-and-Sweep):"></a>标记-清扫(Mark-and-Sweep):</h3><p>标记-清扫算法为每个对象预留一个Flag位，分为两个阶段，标记阶段会从Root向下递归遍历所有对象，并将所有可达对象的Flag位设为”正在使用”。第二阶段，清扫阶段，遍历所有内存，回收那些所有未被标记为”正在使用”的对象。整个算法的思路很简单，也基本上避免了引用计数法的缺点，但最大的缺点在于回收期间整个系统必须暂停(Stop-the-world)。</p><p><img src="/assets/image/os/mark-and-sweep.gif" alt=""></p><h3 id="三色标记法-Tri-color-marking"><a href="#三色标记法-Tri-color-marking" class="headerlink" title="三色标记法(Tri-color marking):"></a>三色标记法(Tri-color marking):</h3><p>针对原生标记-清扫算法标记过程会STW的缺点，三色标记法改进了标记方案。三色标记法将所有对象分为三类:</p><ul><li>白色: GC的候选对象集合(待处理)</li><li>灰色: 可从根访问，并且还未扫描对白色集合对象的引用(处理中,不会被GC,但引用待确认)</li><li>黑色: 可从根访问，并且不存在对白色集合的引用(处理完成)</li></ul><p>步骤如下:</p><ol><li>初始化，所有对象都是白色</li><li>从根遍历，所有可达对象标记为灰色</li><li>从灰色对象队列中取出对象，将其引用的对象标记为灰色，并将自己标记为黑色</li><li>重复第三步，直到灰色队列为空，此时白色对象即为孤儿对象，进行回收</li></ol><p>三色标记法有个重要的不变量: <strong>黑色对象不会引用任何白色对象</strong>，因此白色对象可以在灰色对象处理完成之后立即回收。此算法最大的特点在于将标记过程拆分和量化，使得用户程序和标记过程可并行执行(需要其它技术追踪标记过程中的对象引用变更)，不用Stop-the-world，算法可按照各个集合的大小阶段性执行GC，并且不用遍历整个内存空间。</p><p><img src="/assets/image/os/tri-color-marking.gif" alt=""></p><h3 id="半空间回收器-semi-space-collector"><a href="#半空间回收器-semi-space-collector" class="headerlink" title="半空间回收器(semi-space collector)"></a>半空间回收器(semi-space collector)</h3><p>半空间收集器将内存分为两半，分别叫<strong>from space</strong>和<strong>to space</strong>，初始时，所有的对象都在<strong>to space</strong>中分配直到空间用完，触发一次回收周期，此时<strong>to space</strong>和<strong>from space</strong>互换，然后将所有根可访问的对象从<strong>from space</strong>拷贝到<strong>to space</strong>，之后程序可以继续执行。新的对象继续在新的<strong>to space</strong>中分配，直到再次空间用完触发回收。该算法的优点是所有存活的数据结构都紧凑排列在<strong>to space</strong>，内存分配也可通过简单的分配指针自增来实现，缺点是浪费了一半的内存空间。这种GC方案也叫<strong>stop-and-copy</strong>。</p><h3 id="三色标记法的一些变形"><a href="#三色标记法的一些变形" class="headerlink" title="三色标记法的一些变形"></a>三色标记法的一些变形</h3><h4 id="moving-or-non-moving"><a href="#moving-or-non-moving" class="headerlink" title="moving or non-moving"></a>moving or non-moving</h4><p>三色标记法执行标记流程后(灰色队列为空)，所有的白色对象可被回收，那么这些白色对象是直接被回收，其它不变还是执行内存拷贝(non-moving)，将黑色对象移动并覆盖不再使用的白色对象内存(moving)。相当于执行内存块调整(compact)，可以让内存结构更有序，下次分配更快。这部分算法独立于三色标记，可以由GC算法在运行时选择。</p><h4 id="mark-and-non-sweep"><a href="#mark-and-non-sweep" class="headerlink" title="mark and non-sweep"></a>mark and non-sweep</h4><p>基于半空间收集器的copy思路，可以运用到三色标记法中，通过颜色互换来模拟space互换，该算法对三色标记的颜色定义有所不同，步骤如下:</p><ol><li>对象只有黑色与白色两种颜色，并且黑色与白色是可以互换的(可通过修改黑白的位映射来实现，无需修改对象)</li><li>所有可被访问的对象都是黑色，所有可被回收的对象为白色</li><li>对象从白色对象空间分配，被分配后即标记为黑色</li><li>当内存空间不足(不再有白色对象)，触发GC，此时所有黑色对象变为白色对象，从根遍历所有可访问的对象，将其由白色变为黑色，此时剩下的白色即为可被回收对象，程序可继续运行</li><li>程序继续从白色空间分配，直到白色空间用完，再次触发GC</li></ol><h3 id="分代GC-Generational-GC"><a href="#分代GC-Generational-GC" class="headerlink" title="分代GC(Generational GC)"></a>分代GC(Generational GC)</h3><p>前面的各种标记扫描算法，都有一个缺点，每次需要遍历标记所有可达对象，包括一些长期存活的对象，或者说，GC也具有局部性: 最近被分配的对象越容易不再使用。分代GC即基于这一启发，它将内存空间按”代(Generation)”分为几个部分(通常是两代，即Young Generation和Old Generation)，并尽可能频繁地在年轻的一代执行GC，当年轻一代的内存空间不够时，将可达对象全部移到上一代，此时年轻代的内存全部闲置，可用于分配新对象，这样更快并且通常也更有效率。当老一代GC不够用时，才执行Full Sweep。</p><p>通常大部分语言的运行时都会混合多种GC算法，比如Erlang的GC(参考<a href="https://segmentfault.com/a/1190000003758525" target="_blank" rel="external">1</a>,<a href="http://blog.csdn.net/mycwq/article/details/26613275" target="_blank" rel="external">2</a>)就混合了分代GC和引用计数(高效)，在进程堆内使用分代GC，对全局数据使用引用计数(即时释放内存)。</p><p>参考:</p><ol><li><a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="external">Reference counting - wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="external">Tracing garbage collection - wikipedia</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看看GC(自动垃圾回收)的主要问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;额外的开销(内存/CPU)&lt;/li&gt;
&lt;li&gt;执行GC的时机无法预测，在实时性要求高的场景或事务处理来说可能是不可容忍的&lt;/li&gt;
&lt;li&gt;部分GC算法会Stop-the-world&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各语言运行时在选取GC算法时，都要从这几个方面进行衡量与取舍，下面是一些常见的GC算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="gc" scheme="http://wudaijun.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用mathjax渲染公式</title>
    <link href="http://wudaijun.com/2017/12/hexo-with-mathjax/"/>
    <id>http://wudaijun.com/2017/12/hexo-with-mathjax/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2017-12-02T15:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在博客中嵌入公式的需求，目前主要有两个数学公式渲染引擎mathjax和KaTeX，前者应用更广泛，支持的语法更全面，因此这里简述将mathjax整合到hexo。</p><h4 id="1-替换Markdown渲染器"><a href="#1-替换Markdown渲染器" class="headerlink" title="1. 替换Markdown渲染器"></a>1. 替换Markdown渲染器</h4><pre><code>npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save</code></pre><p>hexo-renderer-karmed渲染器fork自hexo-renderer-marked，对mathjax的支持更友好，特别是下划线处理(marked会优先将<code>_</code>之间的内容斜体转义)</p><h4 id="2-挂载mathjax脚本"><a href="#2-挂载mathjax脚本" class="headerlink" title="2. 挂载mathjax脚本"></a>2. 挂载mathjax脚本</h4><p>在主题<code>layout/_partial/</code>目录下添加mathjax.ejs:</p><pre><code>&lt;!-- mathjax config similar to math.stackexchange --&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;  MathJax.Hub.Config({    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      processEscapes: true    }  });&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;    MathJax.Hub.Config({      tex2jax: {        skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]      }    });&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;    MathJax.Hub.Queue(function() {        var all = MathJax.Hub.getAllJax(), i;        for(i=0; i &lt; all.length; i += 1) {            all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;        }    });&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=theme.cdn.mathjax + &quot;/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;</code></pre><p>如果用的是jade模板，则添加mathjax.jade:</p><pre><code>//mathjax config similar to math.stackexchangescript(type=&quot;text/x-mathjax-config&quot;).  MathJax.Hub.Config({    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      displayMath: [ [&#39;$$&#39;,&#39;$$&#39;], [&quot;\\[&quot;,&quot;\\]&quot;] ],      processEscapes: true    }  });script(type=&quot;text/x-mathjax-config&quot;).  MathJax.Hub.Config({    tex2jax: {      skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]    }  });script(async, type=&quot;text/javascript&quot;, src=theme.cdn.mathjax + &#39;/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#39;)</code></pre><p>在<code>_partial/after_footer.ejs</code>中添加:</p><pre><code>&lt;% if (page.mathjax){ %&gt;&lt;%- partial(&#39;mathjax&#39;) %&gt;&lt;% } %&gt;</code></pre><p>如果是jade模板，则在<code>_partial/after_footer.jade</code>中添加:</p><pre><code>if page.mathjax == true  include mathjax</code></pre><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h4><p>在主题_config.yml中配置mathjax cdn:</p><pre><code>cdn:    mathjax: https://cdn.mathjax.org</code></pre><p>当需要用到mathjax渲染器时，在文章头部添加<code>mathjax:true</code>:</p><pre><code>layout: postmathjax: true...</code></pre><p>只有添加该选项的文章才会加载mathjax渲染器。</p><h4 id="4-支持mathjax的Markdown编辑器"><a href="#4-支持mathjax的Markdown编辑器" class="headerlink" title="4. 支持mathjax的Markdown编辑器:"></a>4. 支持mathjax的Markdown编辑器:</h4><ul><li><a href="www.inkcode.net/qute">Qute</a> 原生支持mathjax，界面有点Geek。</li><li><p><a href="https://macdown.uranusjr.com/" target="_blank" rel="external">Macdown</a>: Macdown原生不支持mathjax，在md文件中添加(注意https，Macdown为了安全，只会加载https的远程脚本):</p><pre><code>  &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;  MathJax.Hub.Config({      tex2jax: {          inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],          displayMath: [ [&#39;$$&#39;,&#39;$$&#39;], [&quot;\\[&quot;,&quot;\\]&quot;] ],},      TeX: {equationNumbers: {          autoNumber: &quot;AMS&quot;        },Augment: {  Definitions: {         macros: {           overbracket:  [&#39;UnderOver&#39;,&#39;23B4&#39;,1],           underbracket: [&#39;UnderOver&#39;,&#39;23B5&#39;,1],         }       }}},  });  &lt;/script&gt;</code></pre></li></ul><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例:"></a>5. 示例:</h4><pre><code>行内公式: $$ a+b=c $$行间公式:$$\left( \begin{array}{ccc}a &amp; b &amp; c \\d &amp; e &amp; f \\g &amp; h &amp; i\end{array} \right)$$</code></pre><p>得到:</p><p>行内公式: $ a+b=c $</p><p>行间公式:</p><script type="math/tex; mode=display">\left( \begin{array}{ccc}a & b & c \\d & e & f \\g & h & i\end{array} \right)</script><p>具体mathjax语法，这里有一篇不错的<a href="http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="external">博客</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有在博客中嵌入公式的需求，目前主要有两个数学公式渲染引擎mathjax和KaTeX，前者应用更广泛，支持的语法更全面，因此这里简述将mathjax整合到hexo。&lt;/p&gt;
&lt;h4 id=&quot;1-替换Markdown渲染器&quot;&gt;&lt;a href=&quot;#1-替换Markdown渲染
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="hexo" scheme="http://wudaijun.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>docker 网络模式</title>
    <link href="http://wudaijun.com/2017/11/docker-network/"/>
    <id>http://wudaijun.com/2017/11/docker-network/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-12-02T06:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>以Docker为平台部署服务器时，最应该理解透彻的便是网络配置。离上次学习，Docker网络又更新了不少内容，重新温习一下。</p><p>通过<code>docker run</code>的<code>--network</code>选项可配置容器的网络模式，Docker提供了多种网络工作模式，通过<code>docker network ls</code>可查看默认提供的三种网络模式: none, host, bridge</p><h3 id="none-模式"><a href="#none-模式" class="headerlink" title="none 模式"></a>none 模式</h3><p>不为Docker容器进行任何网络配置，容器将不能访问任何外部的路由(容器内部仍然有loopback接口)，需要手动为其配置网卡，指定IP等，否则与外部只能通过文件IO和标准输入输出交互，或通过<code>docker attach 容器ID</code>进入容器。</p><h3 id="host-模式"><a href="#host-模式" class="headerlink" title="host 模式"></a>host 模式</h3><p>与宿主机共用网络栈，IP和端口，容器本身看起来就像是个普通的进程，它暴露的端口可直接通过宿主机访问。相比于bridge模式，host模式有显著的性能优势(因为走的是宿主机的网络栈，而不是docker deamon为容器虚拟的网络栈)。</p><h3 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h3><p>默认网络模式，此模式下，容器有自己的独立的Network Namespace。简单来说，Docker在宿主机上虚拟了一个子网络，宿主机上所有容器均在这个子网络中获取IP，这个子网通过网桥挂在宿主机网络上。Docker通过NAT技术确保容器可与宿主机外部网络交互。</p><p><img src="/assets/image/tool/docker-bridge.png" alt=""></p><p>Docker服务默认会创建一个docker0网桥，并为网桥指定IP和子网掩码(通常为172.17.0.1/16)。当启动bridge模式的容器时，Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备。veth pair技术保证无论哪一个veth收到报文，都将转发给另一方。veth pair的一端默认挂在docker0网桥上，另一端添加到容器的namespace下，并重命名为eth0，保证容器独享eth0，做到网络隔离。连接在同一个Docker网桥上的容器可以通过IP相互访问。如此实现了宿主机到容器，容器与容器之间的联通性。</p><p>关于网桥:</p><ul><li><p>网桥(Bridges):<br>  工作在数据链路层，连接多个端口，负责转发数据帧。网桥知道它的各个端口的数据链路协议(目前几乎都是以太网)，将来自一个端口的数据帧转发到其它所有端口。有多个端口的网桥又叫做交换机，目前这两个概念没有本质区别。</p><p>  网桥可以用来连接不同的局域网(LAN)，按照最简单的方法，网桥会将某个端口收到的数据无脑转发给其它所有端口，这种泛洪(Flooding)算法效率过低，网桥依靠转发表来转发数据帧，通过自学习算法，记录各个Mac地址在对应哪个端口(转发表数据库)，辅之超时遗忘(Aging)和无环拓扑算法(Loop-Free Topology，典型地如Spanning Tree Protocol, STP)。</p></li><li><p>Linux网桥:</p><p>  Linux下网桥是一个虚拟设备，你可以通过命令创建它，并且为其挂载设备(物理或虚拟网卡)。可通过<code>brctl</code>命令来创建和Linux网桥。管理Linux bridge的具体用法参考: <a href="https://wiki.linuxfoundation.org/networking/bridge。" target="_blank" rel="external">https://wiki.linuxfoundation.org/networking/bridge。</a></p></li><li><p>Docker网桥:</p><p>  Docker网桥通过Linux网桥实现，加上NAT, veth pair, 网络命名空间等技术，实现网络隔离和容器互联。可通过<code>sudo docker network inspect bridge</code>查看Docker网桥配置以及状态。</p></li></ul><p>当容器需要和宿主机外部网络交互时，会在宿主机上分配一个可用端口，通过这个端口做SNAT转换(将容器IP:Port换为宿主机IP:Port)，再向外部网络发出请求。当外部响应到达时，Docker再根据这一层端口映射关系，将响应路由给容器IP:Port。</p><p>外部网络要访问容器Port0，需要先将Port0与宿主机Port1绑定(外部网络无法直接访问宿主机二级网络)，将宿主机IP:Port1暴露给外部网络，外部网络请求到达宿主机时，会进行DNAT转换(将宿主机IP:Port1换为容器IP:Port0)。</p><p>从实现上来讲，Docker的这种NAT(实际上是NATP，包含IP,Port的转换)规则，是Docker Daemon通过修改ipatables规则来实现的，ubuntu下可通过<code>sudo ipatbles -t nat -L</code>来查看和NAT相关的规则。</p><p>总之，Docker容器在bridge模式下不具有一个公有IP，即和宿主机的eth0不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。虽然NAT模式经过中间处理实现了这一点，但是NAT模式仍然存在问题与不便，如：容器均需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等。另外NAT模式会一定程度的影响网络传输效率。</p><p>默认设置下，Docker允许容器之间的互联，可通过<code>--icc=false</code>关闭容器互联(通过iptables DROP实现)，此时容器间相互访问只能通过<code>--link</code>选项链接容器来实现容器访问。<code>—link</code> 选项实际在链接容器的/etc/hosts中添加了一行被链接容器名和其IP的映射，并且会在被链接容器重启后更新该行(这样即使IP有变动也可以通过容器名正确连接)，此外还会添加一条针对两个容器允许连接的iptables规则。但Docker官方文档说<code>--link</code>已经是遗留的选项，更推荐自定义网络模式。</p><h3 id="自定义模式"><a href="#自定义模式" class="headerlink" title="自定义模式"></a>自定义模式</h3><h4 id="自定义bridge网络"><a href="#自定义bridge网络" class="headerlink" title="自定义bridge网络"></a>自定义bridge网络</h4><p>即创建一个新的bridge网络，它的行为和默认的bridge网络类似，可通过<code>docker network</code>创建一个docker网桥:</p><pre><code># 创建一个Docker网桥 命名为my_bridgedocker network create --driver bridge my_bridge# 查看当前Docker支持的所有网络模式 (会多出一个bridge网络模式，名为my_bridge)docker network ls# 将容器挂在my_bridge网桥上docker run --network=my_bridge -it --rm ubuntu# 查看 my_bridge网桥配置和状态docker network inspect my_bridge# 移除 my_bridge网桥docker network rm my_bridge</code></pre><p>自定义网桥通常用于创建一个小的容器网络，在自定义网桥中，<code>--link</code>选项不被支持。</p><h4 id="自定义overlay网络"><a href="#自定义overlay网络" class="headerlink" title="自定义overlay网络"></a>自定义overlay网络</h4><p>前面提到的网络模式，主要解决同一个主机上容器与容器，容器与主机，容器与外界的连接方案，如果要实现跨主机的容器与容器之间的通信方案，可以:</p><ol><li>端口映射</li><li>将物理网卡挂在Docker网桥上，将容器和宿主机配置在同一网段下，见参考3</li><li>使用<a href="http://docs.openvswitch.org/en/latest/howto/docker/" target="_blank" rel="external">OpenvSwich网桥</a>，如通过配置工具pipework，见参考4</li><li>在Docker1.9之后，可以使用原生解决方案Docker overlay</li></ol><p><img src="/assets/image/tool/docker-overlay.png" alt=""></p><p><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">图片出处</a></p><p>overlay网络可以实现跨主机的容器VLAN，具体使用可以参考<a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a>。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在使用Docker时，要注意平台之间实现的差异性，如[Docker For Mac]的实现和标准Docker规范有区别，Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的(而不是像Linux上那样作为进程运行于宿主机)，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。文档在这一点上并没有充分说明，容易踩坑。参考<a href="https://docs.docker.com/docker-for-mac/networking/" target="_blank" rel="external">Docker文档</a> 和 <a href="https://forums.docker.com/t/should-docker-run-net-host-work/14215" target="_blank" rel="external">这篇帖子</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>bridge模式的详细实现可参考[Docker源码分析(七)：Docker Container网络(上)][]</p><ol><li><a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part7" target="_blank" rel="external">Docker源码分析(七)：Docker Container网络(上)</a></li><li><a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="external">Docker networking</a></li><li><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a></li><li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="external">Docker网络详解及pipework源码解读与实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以Docker为平台部署服务器时，最应该理解透彻的便是网络配置。离上次学习，Docker网络又更新了不少内容，重新温习一下。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;docker run&lt;/code&gt;的&lt;code&gt;--network&lt;/code&gt;选项可配置容器的网络模式，Docker
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>探讨服务端回合制战斗系统</title>
    <link href="http://wudaijun.com/2017/09/ngs-battle/"/>
    <id>http://wudaijun.com/2017/09/ngs-battle/</id>
    <published>2017-09-25T16:00:00.000Z</published>
    <updated>2017-12-26T02:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与大部分回合制游戏一样，需要服务器计算战斗，客户端以战报的方式回放。这里探讨一下服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。</p><h2 id="战斗流程"><a href="#战斗流程" class="headerlink" title="战斗流程"></a>战斗流程</h2><p>战斗地图是一个X*Y的矩阵，每个参与者(Fighter)初始位于其中一个格子上。战斗开始后，按照回合迭代，达到胜负条件或最大回合数则战斗结束。回合内，英雄按照出手顺序先后行动(Action)，英雄的Action包括移动，释放技能和普攻。</p><p>战斗流程是比较简明易懂的，整个战斗系统的难点在于多样的技能实现。每个英雄有N个技能，每个英雄可通过学习其它技能来实现不同的战斗效果，技能的效果和作用比较繁杂，例如：</p><ul><li>SkillA: 英雄每回合前3次伤害有50%机率使伤害翻倍(最多生效2次)</li><li>SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1，持续两回合</li><li>SkillC: 分裂箭，英雄普攻可对多个敌人造成伤害</li><li>…</li></ul><p>以下我们主要围绕灵活的技能系统为主要需求，讨论如何实现一个稳定，可扩展的战斗系统。</p><h2 id="Event系统"><a href="#Event系统" class="headerlink" title="Event系统"></a>Event系统</h2><p>Event事件管理是实现复杂技能效果的基石，通过Event可以将复杂，易变的技能效果和核心流程解耦。对回合制游戏，典型地Event有回合开始/结束，英雄移动/普攻/受击/死亡等，EventMgr管理这些Event和它们的Handler，主要提供如下接口:</p><pre><code>// Go Codetype EventArgs map[string]interface{}type EventHandler func(EventArgs)// 触发Event， 由战斗流程调用 如回合开始，英雄移动等FireEvent(EventType, EventId, EventArgs)// 监听Event， ListenerId通常为Buff的唯一ID AddEventListener(EventType, EventId, ListenerId, EventHandler)// 注销ListenerId监听的所有Event，通常在Buff结束时调用DelEventListener(ListenerId)</code></pre><p>EventMgr实际上是一个订阅者模式，战斗流程通过FireEvent发布事件，Buff订阅关心的事件并更新自己状态，在Buff结束时注销所有相关的事件监听。两者通过订阅者模式完成解耦，便于扩展。</p><h2 id="技能系统"><a href="#技能系统" class="headerlink" title="技能系统"></a>技能系统</h2><p>技能分为主动技能(概率触发)和被动技能(相当于战斗开始立即触发)。技能的效果分为瞬时性和持续性两种，前者即像普通一样立即造成伤害(其实普攻也可以看做技能的一种)，后者指技能效果包含状态性，有自己的生命周期和状态更新，如Dot伤害，无法移动，沉默等，这个状态通常叫做Buff，关于技能和Buff的区别我的理解是，技能是Buff的静态容器，是永久的，Buff是技能触发后的实现效果，是动态的。瞬时伤害的技能也可以通过Buff实现，只不过这个Buff生命周期很短，在造成伤害后就消失了。关于Buff的详细实现我们放到后面，我们先看技能系统本身。</p><p>考虑到技能以后的扩展性和可维护性，对其尽可能做抽象是有必要的，抽象出公共的流程，将可变量配置化，可以提升系统稳定性和扩展性，也方便后期做测试。技能本身包含几个阶段：技能触发(概率触发，战斗开始触发)，目标选取(敌军/友军，一个/多个)，技能作用(造成伤害，挂接Buff)，前两个是可抽离到配置的，通过通用的技能触发器和目标选取脚本得到技能所需要的信息传给技能作用模块，由于技能作用效果的多样性，目前我们没有对技能作用进行抽象，是通过脚本各个实现的。</p><h2 id="Buff系统"><a href="#Buff系统" class="headerlink" title="Buff系统"></a>Buff系统</h2><p>技能的各种复杂效果都通过BUFF实现，每个Buff都挂于战场某个参与者(Fighter)上，当Fighter阵亡，其上所有的Buff都会被移除(包括Event关联)。BUFF系统是由一个基于战场事件(Event)的回调系统驱动，整个战场在战斗流程中不断抛出各种Event(如回合开始/结束，Fighter普攻/受击/释放技能，伤害结算等)，BUFF注册这些Event并更新自己Owner(Fighter)的状态，来实现灵活强大的技能效果。</p><h3 id="1-Buff抽象"><a href="#1-Buff抽象" class="headerlink" title="1.Buff抽象"></a>1.Buff抽象</h3><ul><li>Start():Buff开始，即Buff启动脚本，负责初始化状态，注册BUFF的生命周期和相关Event等。</li><li>Update():Buff状态更新，实现Buff作用并更新Buff的状态，对于次数性BUFF(如前N次免伤)，可能调用N次Update，复杂的技能也可能有多个Update函数(关心不同的Event)</li><li>Finish():Buff的正常结束，当BUff结束条件满足(比如Update了N次，或者持续了N回合)调用</li><li>Cancel():Buff被冲突(中断)时的处理</li></ul><p>以上阐述的是Buff的行为抽象，而不是具体实现，在设计Buff时从这四个触法点思考，加上EventMgr注册回调机制，基本可以实现绝大部分各式的Buff效果。例如最开始提到的SkillA: 英雄每回合前3次伤害有50%机率使伤害翻倍(最多生效2次)，这是一个持续整场战斗的Buff(BuffA)，它注册两个Update Event:</p><ul><li><code>BEFORE_DAMAGE</code>(英雄攻击伤害结算前): Update1 中判断如果本回合已触发次数小于2并且满足触发条件(50%概率)，则更新自己的状态(计数器+1)，并产生<strong>伤害翻倍子Buff</strong>(后面讨论)。</li><li><code>ROUND_START</code>(每回合开始): Update2 中重置Buff状态(计数器)。</li></ul><p>目前我们所讨论的Buff都是独立的，有自己生命周期的个体，通过Event注册回调与战斗主流程解耦。但实际上Buff之间是有相互关联的，主要分为三种：Buff属性作用，Buff冲突免疫关系和Buff生命周期，下面分别介绍。</p><h3 id="2-Buff属性作用"><a href="#2-Buff属性作用" class="headerlink" title="2. Buff属性作用"></a>2. Buff属性作用</h3><p>仍然是我们前面的SkillA技能，我们现在来看如何实现伤害翻倍这个Buff，该Buff是SkillA对应的Buff生成的子Buff，它应该被设计为可公用的伤害增加Buff，这个Buff的作用是影响伤害结算流程，按照我们之前的事件注册回调思路，我们可以注册伤害结算这个Event，接收当前算出的伤害，然后*200%并返回新伤害值。如BuffA提升10%伤害，BuffB增加20点真实伤害，BuffC降低20%的伤害，那么最终得到伤害为: <code>(基础伤害*110%+20)*80%</code>，这种方案默认公式计算的顺序与Buff挂载顺序一致，，而正确的伤害值应该为<code>(基础伤害+20)*(1+10%-20%)</code>，如果要处理这种优先级关系，需要遍历所有注册伤害结算Event的Handler，按照类型排序，再依次处理，如果一旦有同类Buff添加或移除，又要重新计算。这样公式与事件管理做到了一起，是不稳定的。</p><p>BuffA,BuffB,BuffC之所以会有复杂的公式计算，在于它们作用于同一属性的不同维度，BuffA,BuffC作用于伤害值的比例增加这一维度，而BuffB作用于伤害值的绝对值增长这一维度，我们可以将它们分开，作为Fighter两个独虚拟属性ATTR_DAMAGE_ADD, ATTR_DAMAGE_MUL来维护，允许Buff对其修改，但此时的修改是只有加减关系的，避免了优先级的问题，在伤害结算时，通过公式计算: (基础伤害+ATTR_DMAGE_ADD)*ATTR_DAMAGE_MUL即可。</p><p>整个作用链为: </p><ul><li>战斗流程抛出事件 -&gt; 事件系统 -&gt;Buff系统 -&gt; Fighter属性维度</li><li>战斗流程获取属性 -&gt; 属性系统 -&gt; 公式计算  -&gt; Fighter属性维度</li></ul><p>通过属性系统和事件系统，将战斗流程和Buff系统解耦，将组件职责降到最小，方便测试和扩展。</p><p>比如沉默，眩晕等效果，如果没有虚拟属性，沉默Buff会注册EVENT_BEFORE_SKILL(Fighter释放技能前)这个Event，并且返回false来告知战斗系统它当前不能释放技能。同样，眩晕Buff会注册Fighter EVENT_BEFORE_MOVE, EVENT_BEFORE_ATTACK, EVENT_BEFORE_SKILL三个Event来实现眩晕效果，一来整个战斗流程每次都要合并各类Event的各种返回值(并且EventHandler得不到统一的接口抽象)，效率低下，二来战斗流程不应该依赖外部EventHandler的实现，它只关心值本身(能否移动，能否施法等)，因此虚拟属性本身实际上起一个依赖倒置的作用。如果使用虚拟属性，那么沉默Buff会在ATTR_FORBIDEN_SKILL这个属性上+1，眩晕同理，这样战斗流程在Fighter尝试施放技能时，获取Fighter的ATTR_FORBIDEN_SKILL属性，如果&gt;0，则不能施法。一句话，Buff通过属性来影响战斗流程。</p><h3 id="3-Buff相互关系"><a href="#3-Buff相互关系" class="headerlink" title="3.Buff相互关系"></a>3.Buff相互关系</h3><p>-Buff 冲突:  即该BUFF生效时，已有的哪些Buff会失效，如一些清除负面状态的Buff<br>-Buff 免疫:     即该BUFF生效时，后面来的哪些BUFF不能生效，如BKB免疫眩晕<br>-Buff 叠加:  两种同类增益或减益BUFF同时生效时，按照某个规则进行BUFF效果重新计算生成</p><p>Buff的冲突免疫关系实际上是Buff作用效果的一部分，但是一个可抽象和配置化的流程，在挂载Buff时统一处理。至于Buff叠加，在Buff B的Start节点中，判断是否有指定Buff A存在，如果存在，修正BuffB的效果(或移除已有BuffA)，是个特例流程，做到Buff脚本里面就行了。</p><p>至此，我们通过属性维度和公式计算来避免了作用于同一个属性的Buff的顺序依赖，通过公用流程来处理Buff的免疫和冲突，仅针对Buff叠加这类少见的特殊作用进行特例化处理，这样最大程度的提升了Buff的扩展性，Buff可以独立实现，Buff的关系可通过配置表配置，新加一个Buff无需修改已有的Buff系统，对其它模块的影响也降到最小。</p><h3 id="4-Buff生命周期"><a href="#4-Buff生命周期" class="headerlink" title="4.Buff生命周期"></a>4.Buff生命周期</h3><p>为了达成复用，我们会通过子Buff的概念来实现一些复杂的Buff，SkillA的BuffA，它维护自己的状态，并在条件满足时，产生伤害翻倍这个子Buff，父子Buff的生命周期关系大致有三种:</p><ol><li>完全独立，创建完成之后即不再相互引用</li><li>父Buff结束时，子Buff随之结束</li><li>父Buff通过内部状态控制子Buff的生命周期</li></ol><p>对战斗系统来说，理想情况下，每个Buff应该自己管理自己的生命周期，这样状态内聚在Buff本身，更好地满足正交性和复用性。并且Buff的生命周期耦合容易引发状态错误，如子Buff由于Buff冲突被移除时，父Buff可能并不知晓，当父Buff结束子Buff时会再次触发Buff Finish或Cancel操作。</p><p>因此我们应该尽可能将父子Buff关系弱化(向第一种关系靠齐)，将Buff生命周期独立:</p><ul><li>将Buff的生命周期作为创建子Buff的参数传入，如一个持续两回合的属性Buff，则将”持续两回合”这个周期以事件类型(回合结束), 事件ID(0), 触发次数(2)传入</li><li>用子Buff监听”父Buff移除”事件的方式来将关系2转换为关系1</li><li>用唯一事件ID来完成父子Buff的特例的事件交互，将部分关系3转换为关系1</li></ul><p>由于更复杂的状态控制，比如Buff的结束机制可能不止一种，所以想要完全只保留关系1的父子Buff是比较难的。对于这类少数父子Buff，可考虑特例化实现这个子Buff，比如吸血Buff独立实现可能会比复用恢复Buff更好，如果以上方案都不能很好解决，最后再考虑将其生命周期完全交由父Buff控制(子Buff本身无Event状态)。</p><h2 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h2><p>属性系统针对Fighter的各种属性进行管理，属性系统包括K-V Map和公式计算两部分，前面我们讲到通过虚拟属性来完成Buff与战斗流程间的解耦，那么K-V Map的Key有如下几种:</p><ul><li>固定属性: 当前不受Buff影响的属性，无需公式计算直接获取即可。如Fighter当前血量，位置信息等</li><li>基础属性: 受Buff影响的属性的基础值，如Fighter进入战斗时的初始攻击力，防御力等，基础属性在战斗过程中不变</li><li>Buff属性: 基础属性的可变维度，由各类Buff修改，如攻击力增加值(绝对值)，防御力加成(百分比)</li><li>虚拟属性: 如禁足，沉默，伤害加成等，这些属性原本Fighter上面没有，属于战斗系统需要，也由Buff修改</li></ul><p>我将属性管理器K-V Map保存的”属性”称为属性维度，它们是Buff操作属性的最小粒度，每个属性维度都是纯加减运算，不受Buff先后顺序的影响。对最终属性的计算，由公式计算系统，比如: 最终攻击力 = (攻击力基础值+攻击力增加值)*(1+攻击力加成值)，战斗流程关心Fighter最终攻击力，Buff系统关心其影响的某个属性维度(如攻击力增加值或攻击力加成值)，中间的这一块就是公式计算，将公式计算抽象出来的好处是公式系统可独立变化，甚至可以将公式配置化。属性的计算过程对战斗流程来说是透明的，这给属性维度和公式计算的变更带来的很大的灵活度。</p><h2 id="配置框架"><a href="#配置框架" class="headerlink" title="配置框架"></a>配置框架</h2><p>评估一套配置框架好坏不能简单从可配置性这一点来看，一个完全可配置技能效果，做到通过配置即可添加一些简单技能的配置框架不是不能实现，但开发和维护成本过高，对策划的要求，出错的可能性也更高。因此在设计配置框架时，要结合项目需求，在开发效率，可维护性，可扩展性等方面作出权衡。</p><p>简单提一下我们目前用的配置方案:</p><p>技能基础表:</p><div class="table-container"><table><thead><tr><th>技能ID</th><th>技能类型</th><th>技能距离</th><th>技能目标选取器</th><th>目标数量</th><th>技能BuffIds</th><th>技能描述</th></tr></thead><tbody><tr><td>1</td><td>主动</td><td>同攻击距离</td><td>敌人</td><td>1</td><td>[1001]</td><td>对目标造成Args[0]的伤害，并眩晕Args[1]回合(Buff[0])</td></tr></tbody></table></div><p>技能成长表，即技能的Args表: </p><div class="table-container"><table><thead><tr><th>技能ID</th><th>技能等级</th><th>技能参数</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>[0.8,1]</td></tr><tr><td>1</td><td>2</td><td>[0.9,1]</td></tr></tbody></table></div><p>Buff表:</p><div class="table-container"><table><thead><tr><th>BuffId</th><th>描述</th><th>所属Tags</th><th>冲突Tags</th><th>免疫Tags</th><th>冲突自身</th><th>免疫自身</th></tr></thead><tbody><tr><td>1001</td><td>眩晕</td><td>[控制]</td><td>[]</td><td>[]</td><td>false</td><td>false</td></tr></tbody></table></div><p>技能根据技能类型，距离和目标选取器以及目标数量，通过通用目标选取流程得到目标，然后传入技能作用脚本，技能作用脚本由程序维护，通过技能描述使用技能参数(来自技能成长表)和技能BuffIds(传入Buff作用脚本)，由于多个Buff可能由同一个Buff脚本实现(如攻击力提高，防御力降低)，因此Buff脚本需要外部传入BuffId来获取冲突免疫关系，对程序来说，BuffId是透明的，它只代表一类冲突免疫关系，对策划来讲，Buff脚本是透明的，他只关心Buff相互关系(如A技能的攻击力提升与B技能的攻击力提升不能同时存在)，至于技能和技能参数以及BuffID的关联本身，是不常变的，因此直接硬编码映射。</p><p>Buff的配置方案有两种，一是通过BuffID来配置冲突免疫关系，这种方案灵活性高，但扩展性和维护性差。另一种方案是通过BuffTag，每个Buff可配置自己的Tag(如增益，减益，控制)，根据这些Tag来控制冲突免疫关系，免疫负面状态的Buff对应的配置中免疫Tag为[减益，控制]。这种方案与BuffId无关(免疫自身和冲突自身需单独配置)，维护性和扩展性更高。</p><h2 id="战报系统"><a href="#战报系统" class="headerlink" title="战报系统"></a>战报系统</h2><p>战斗跑在服务器，客户端需要通过战报进行战斗回放，那么战报就要包含整个战斗的详细过程，每回合那个英雄放了什么技能，攻击了谁，等等，客户端根据这些信息”拼凑”出战斗动画。战报的每一”桢”应该为一个最小粒度的事件，如A对B发起了普通攻击应该是: 1. A对B发起普攻，2. B损失了50HP，中间还可能穿插反击和其它Buff效果，客户端在”按桢表现”的时候，还需要一些关联，如B是因为A的普攻而掉血，因此实际上更好的格式为: B由于A的普攻损失了50HP，为了协议扩展性，我们会将这些事件格式统筹起来:</p><div class="table-container"><table><thead><tr><th>事件类型</th><th>FighterId</th><th>事件参数</th><th>解释</th></tr></thead><tbody><tr><td>回合开始</td><td>0</td><td>[1]</td><td>第一回合开始</td></tr><tr><td>发起普攻</td><td>1</td><td>[2]</td><td>Fighter1向Fighter2发起普攻</td></tr><tr><td>受到伤害</td><td>2</td><td>[1,0,50]</td><td>Fighter2由于Fighter1的普攻(BuffId0)损失了50HP</td></tr></tbody></table></div><p>每个事件都有自己的参数意义，这部分和客户端约定即可。这里的事件类型和之前提到的战斗系统的EventMgr很相似，很多触发点也一样，只是是针对各种Buff，一个是针对客户端表现。</p><p>至于事件参数的类型，最常见的可能有整型，浮点数，字符串，在protobuf协议里面可以直接通过复合结构定义:</p><pre><code>message Elem {    sint32  type = 1; // 1: intv 2: fltv 3: strv    sint32  intv = 2;    float   fltv = 3;    string  strv = 4;}</code></pre><p>这种方案很丑陋，但在protobuf3中，由于optional字段默认值不发送和sint32的变长编码，实际发送一个type=1,intv=20的Elem只会占用四个字节(两个字段的内容和编号各占 一个字节)，因此还是比较实用的。参考过<a href="https://developers.google.com/protocol-buffers/docs/proto3#oneof" target="_blank" rel="external">protobuf的oneof</a>，不是很好用，对repeat和map等复合结构的支持不好。</p><h2 id="技能效果扩展"><a href="#技能效果扩展" class="headerlink" title="技能效果扩展"></a>技能效果扩展</h2><h3 id="1-召唤物"><a href="#1-召唤物" class="headerlink" title="1. 召唤物"></a>1. 召唤物</h3><p>SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1持续两回合</p><p>该技能可用前面介绍的已有机制实现: 技能目标选取规则中，配置攻击范围内一个敌人，技能作用脚本中，获取到该目标周围九宫格所有的敌人，对它们施加持续两回合的属性子Buff(攻击距离-1，由子Buff自身管理生命周期)。</p><p>现在考虑SkillB的诅咒区域如果有状态和AI(如存在两回合，每回合跟随施法者移动)，则实现上更为复杂:</p><ul><li>监控所有敌人的移动，当其进入区域时，添加Buff，出去时，移除Buff</li><li>当自己移动时，根据前后状态更新敌人身上的Buff</li><li>两回合后，结束自身</li></ul><p>那如果是召唤一个宠物，并且宠物有血量，可移动，攻击和被攻击呢，是的，答案是以”Fighter”来实现召唤物，这里的Fighter是一个更广泛的概念，它只是一系列接口，如移动/攻击/属性变更等，这样所有能够通过Fighter实现的，技能都可以实现，也算是终极方案了。</p><h3 id="2-行为属性"><a href="#2-行为属性" class="headerlink" title="2. 行为属性"></a>2. 行为属性</h3><p>SkillC: 分裂箭，英雄普攻可对多个敌人造成伤害</p><p>这类技能的特性是会影响已有技能或其它行为，比如改变普攻流程，移动方式等，这种通常很难用属性系统去做，解决方案是将Fighter的行为(普攻/技能/移动等)抽离为可插拨模块(也可理解为行为属性)，初始每个英雄的行为属性被赋默认值，技能可以更改这些行为(如分裂箭可更换普攻行为)，实现更高级别的抽象，战斗流程根据行为类型和次序(如移动/技能/普攻)取出并执行这些行为，行为属性也是召唤物Fighter实现的基础。</p><h3 id="3-全局Buff"><a href="#3-全局Buff" class="headerlink" title="3. 全局Buff"></a>3. 全局Buff</h3><p>SkillD: 腐蚀一片区域，进入区域的敌人受到持续伤害，区域存在2回合，并且不会随施法者死亡消失</p><p>由于其简单，用Fighter实现过于重度，由于其独立的生命周期，不能以普通Buff的形式存在(会随Fighter死亡消失)，那么可以考虑用全局Buff，全局Buff挂在战场上，介于Fighter和普通Buff之间，适合实现一些简单，全局的效果，如天气效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，战斗系统的主要组件就已经介绍得差不多了，总结起来，核心思路是将相对稳定的核心战斗流程和相对动态的技能Buff扩展隔离开来，战斗流程通过事件系统来解耦外部Buff脚本，Buff通过属性系统(包括行为属性)来反馈到战斗流程。在构建的过程中，还要时刻关注到哪些是易变的，比如计算公式(如伤害计算公式)，将这一块单独抽出来，封装成模块甚至抽离到配置，尽量将功能做到模块化，离线化，方便模块的扩展和测试。</p><p>将战斗流程”固化”下来，不要交给Buff系统去任意递归迭代，这种思路适用于回合制这类战斗流程相对固定的情形。另一种思路，是”去流程化”，将流程做到Buff中，比如将移动作为一个Buff，那么”禁足”的效果可以直接通过Buff免疫来实现: 如果Fighter已经有禁足Buff，则移动Buff不能挂上去，达成不能移动的效果。沉默和缴械效果也类似。这种思路更为灵活，但相对更复杂和难以调试。通常我们将通用/固定的行为作为流程，特例/定制的流程作为Buff。</p><p>在战斗系统设计中，很多方案都不是绝对的左或者是右，比如普攻是否应该当做特殊技能处理(这样能很方便实现特殊的普攻效果，如分裂箭)？哪些属于流程，哪些属于Buff？哪些效果以Buff实现，哪些效果以Fighter实现？哪些可抽到配置文件，哪些直接写在代码里等等，在实际决策中，往往都是根据实际情况(开发效率，GD需求，扩展性，维护性等)在中间选一个合适点，并且尽可能在细节上封装解耦，以便之后能根据变化进行调整。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与大部分回合制游戏一样，需要服务器计算战斗，客户端以战报的方式回放。这里探讨一下服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。&lt;/p&gt;
&lt;h2 id=&quot;战斗流程&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
      <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>用context库规范化Go的异步调用</title>
    <link href="http://wudaijun.com/2017/08/go-conetxt-usage/"/>
    <id>http://wudaijun.com/2017/08/go-conetxt-usage/</id>
    <published>2017-08-18T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见并发模型"><a href="#常见并发模型" class="headerlink" title="常见并发模型"></a>常见并发模型</h3><p>之前对比过<a href="http://wudaijun.com/2017/05/go-vs-erlang/">Go和Erlang的并发模型</a>，提到了Go的优势在于流控，下面列举几种常见的流控:</p><h4 id="Ping-Pong"><a href="#Ping-Pong" class="headerlink" title="Ping-Pong"></a>Ping-Pong</h4><p>这通常针对于两个goroutine之间进行简单的数据交互和协作，我们常用的RPC也属于此类，通过channel的类型可以灵活实现交互方式:</p><ul><li>同步单工: 单个双向非缓冲channel</li><li>同步双工: 多个单向非缓冲channel</li><li>异步双工: 多个单向缓冲channel</li></ul><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>流水线如其词语，goroutine是”流水线工人”，channel则为”流水线”，衔接不同的goroutine的输入输出，每个goroutine有一个输入(inbound)channel和输出(outbound)channel:</p><pre><code>// 以下定义一个流水线工人 用于将inbound channel中数字求平方并放入outbound channelfunc sq(in &lt;-chan int) &lt;-chan int {    out := make(chan int)    go func() {        for n := range in {            out &lt;- n * n        }        close(out)    }()    return out}</code></pre><p>流水线goroutine有一些特质：它负责创建并关闭channel(在完成自己的工作后)，这样外部调用无需关心channel的创建和关闭，当channel被关闭，它的下游goroutine会读出零值的数据。我们还可以用链式调用来组装流水线：</p><pre><code>sq(sq(sq(ch)))</code></pre><p>在实际应用中，如DB读写，网络读写等外部阻塞操作通常都放到单独的流水线去做，下游主goroutine可以灵活处理IO结果(如通过select完成IO复用)。</p><h4 id="扇入扇出"><a href="#扇入扇出" class="headerlink" title="扇入扇出"></a>扇入扇出</h4><p>流水线工作通常是一对一的”工作对接”，通过select可以达成IO复用，比如GS同时处理网络消息，RPC调用，Timer消息等，这其实就是简单的扇入模型，扇出模型也比较常见，比如在对一些无状态的任务做分发时，可以让多个goroutine处理一个channel任务队列上的数据，最大程度地提升处理效率。</p><p>上面三个模式是应用最常用到的，因此不再举例具体说明，<a href="http://strucoder.com/2016/03/15/gozhong-de-bing-fa-ke-shi-hua/" target="_blank" rel="external">Go并发可视化</a>这篇文章很好地归纳和总结了这些模型，推荐一读。</p><h3 id="交互规范"><a href="#交互规范" class="headerlink" title="交互规范"></a>交互规范</h3><p>上面只所以提出这三种模型主要是为了导出接下来的问题，当用到多个goroutine时，如何协调它们的工作：</p><h4 id="如何正确关闭其它goroutine"><a href="#如何正确关闭其它goroutine" class="headerlink" title="如何正确关闭其它goroutine"></a>如何正确关闭其它goroutine</h4><p>这类问题的通常情形是：当某个goroutine遇到异常或错误，需要退出时，如何通知其它goroutine，或者当服务器需要停止时，如何正常终止整个并发结构，为了简化处理问题模型，以流水线模型为例，在正常情况下，它们会按照正常的流程结束并关闭channel(上游关闭channel，下游range停止迭代，如此反复)，但当某个下游的goroutine遇到错误需要退出，上游是不知道的，它会将channel写满阻塞，channel内存和函数栈内存将导致内存泄露，在常规处理方案中，我们会使用一个done channel来灵活地通知和协调其它goroutine，通过向done channel写入数据(需要知道要关闭多少个goroutine)或关闭channel(所有的读取者都会收到零值，range会停止迭代)。</p><h4 id="如何处理请求超时"><a href="#如何处理请求超时" class="headerlink" title="如何处理请求超时"></a>如何处理请求超时</h4><p>至于超时和请求放弃，通常我们可以通过select来实现单次请求的超时，比如 A -&gt; B -&gt; C 的Ping-Pong异步调用链，我们可以在A中select设置超时，然后在B调用C时也设置超时，这种机制存在如下问题:</p><ol><li>每次请求链中的单次调用都要启一个timer goroutine</li><li>调用链中的某个环节，并不知道上层设置的超时还有多少，比如B调用C时，如果发现A设置的超时剩余时间不足1ms，可以放弃调用C，直接返回</li><li>A-&gt;B的超时可能先于B-&gt;C的超时发生，从而导致其它问题</li></ol><h4 id="如何安全放弃异步请求"><a href="#如何安全放弃异步请求" class="headerlink" title="如何安全放弃异步请求"></a>如何安全放弃异步请求</h4><p>这个问题可以理解为如何提前结束某次异步调用，接上面提到的A-&gt;B-&gt;C调用链，如果A此时遇到了其它问题，需要提前结束整个调用链(如)，B是不知道的，A和B之间数据交互channel和done channel，没有针对某个请求的取消channel，尽管大部分时候不会遇到这种需求，但针对某个请求的协同机制是缺失的，还需要另行设计。</p><h4 id="如何保存异步调用上下文"><a href="#如何保存异步调用上下文" class="headerlink" title="如何保存异步调用上下文"></a>如何保存异步调用上下文</h4><p>异步调用通常会有上下文，这个上下文不只指调用参数，还包括回调处理参数(非处理结果)，请求相关上下文(如当前时间)等，这类数据从设计上可以通过包含在请求中，或者extern local value，或者每次请求的session mgr来解决，但并不通用，需要开发者自行维护。</p><h3 id="使用context"><a href="#使用context" class="headerlink" title="使用context"></a>使用context</h3><p>以上几个问题并不限于Go，而是异步交互会遇到的普遍问题，只是在Go应用和各类库会大量用到goroutine，所以这类问题比较突出。针对这些问题，Go的内部库(尤其是net,grpc等内部有流水线操作的库)作者开发了context(golang.org/x/net/context)包，用于简化单个请求在多个goroutie的请求域(request-scoped)数据，它提供了:</p><ol><li>请求的超时机制</li><li>请求的取消机制</li><li>请求的上下文存取接口</li><li>goroutine并发访问安全性</li></ol><p>context以组件的方式提供超时(WithTimeout/WithDeadline)，取消(WithCancel)和K-V(WithValue)存取功能，每次调用WithXXX都将基于当前的context(Background为根Context)继承一个Context,一旦父Context被取消，其子Context都会被取消，应用可通过&lt;-context.Done()和<br>context.Err()来判断当前context是否结束和结束的原因(超时/取消)。</p><p>比如针对我们前面的”sq流水线工人”，我们可以通过context让它知道当前流水线的状态，并及时终止:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">out</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</div><div class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</div><div class="line">        <span class="keyword">select</span>&#123;</div><div class="line">        <span class="keyword">case</span> &lt;-ctx.Done():<span class="comment">// 当前流水线被终止</span></div><div class="line">        <span class="built_in">close</span>(out)</div><div class="line">        <span class="keyword">return</span> ctx.Err() <span class="comment">// 终止原因: DeadlineExceeded or Canceled</span></div><div class="line">        <span class="keyword">case</span> out &lt;- n * n:</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">close</span>(out)</div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> out</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以将context在goroutine之间传递，并且针对当前调用通过WithXXX创建子context，设置新的超时，请求上下文等，一旦请求链被取消或超时，context的done channel会被关闭，当前context的所有<code>&lt;-ctx.Done()</code>操作都会返回，并且所有当前context的子context会以相同原因终止。</p><p>比如在A-&gt;B-&gt;C中，B基于A的context通过WithTimeout或WithValue创建子context，子Context的超时和上下文都可以独立于父context(但如果子context设置超时大于父context剩余时间，将不会创建timer)，通过context库内部的继承体系来完成对应用层调用链的记录，并执行链式的超时和取消。</p><p>关于context的进一步了解可参考<a href="https://segmentfault.com/a/1190000006744213" target="_blank" rel="external">Go语言并发模型：使用 context</a>，也可直接阅读源码，实现也比较简单，单文件不到300行代码，但本身的意义却是重大的，go的很多异步库(如net,grpc,etcd等)都用到了这个模块，context正在逐渐成为异步库的API规范，我们也可以从context这个库中得到一些启发，适当地用在自己的项目中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常见并发模型&quot;&gt;&lt;a href=&quot;#常见并发模型&quot; class=&quot;headerlink&quot; title=&quot;常见并发模型&quot;&gt;&lt;/a&gt;常见并发模型&lt;/h3&gt;&lt;p&gt;之前对比过&lt;a href=&quot;http://wudaijun.com/2017/05/go-vs-erlang
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go vs Erlang</title>
    <link href="http://wudaijun.com/2017/05/go-vs-erlang/"/>
    <id>http://wudaijun.com/2017/05/go-vs-erlang/</id>
    <published>2017-05-30T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>源于从Erlang到Go的一些思维碰撞，就像当初从C++到Erlang一样，整理下来记于此。</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor模型，又叫参与者模型，其”一切皆参与者(actor)”的理念与面向对象编程的“一切皆是对象”类似，但是面向对象编程中对象的交互通常是顺序执行的(占用的是调用方的时间片，是否并发由调用方决定)，而Actor模型中actor的交互是并行执行的(不占用调用方的时间片，是否并发由自己决定)。</p><p>在Actor模型中，actor执行体是第一类对象，每个actor都有自己的ID(类比人的身份证)，可以被传递。actor的交互通过发送消息来完成，每个actor都有一个通信信箱(mailbox，本质上是FIFO消息队列)，用于保存已经收到但尚未被处理的消息。actorA要向actorB发消息，只需持有actorB ID，发送的消息将被立即Push到actorB的消息信箱尾部，然后返回。因此Actor的通信原语是异步的。</p><p>从actor自身来说，它的行为模式可简化为:</p><ul><li>发送消息给其它的actor</li><li>接收并处理消息，更新自己的状态</li><li>创建其它的actor</li></ul><p>一个好的Actor模型实现的设计目标:</p><ul><li>调度器: 实现actor的公平调度</li><li>容错性: 具备良好的容错性和完善错误处理机制</li><li>扩展性: 屏蔽actor通信细节，统一本地actor和远程actor的通信方式，进而提供分布式支持</li><li>热更新? (还没弄清楚热更新和Actor模型，函数式范式的关联性)</li></ul><p>在Actor模型上，Erlang已经耕耘三十余载，以上提到的各个方面都有非常出色的表现，其OTP整合了在Actor模型上的最佳实践，是Actor模型的标杆。</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>顺序通信进程(Communicating sequential processes，CSP)和Actor模型一样，都由独立的，并发的执行实体(process)构成，执行实体间通过消息进行通信。但CSP模型并不关注实体本身，而关注发送消息使用的通道(channel)，在CSP中，channel是第一类对象，process只管向channel写入或读取消息，并不知道也不关心channel的另一端是谁在处理。channel和process是解耦的，可以单独创建和读写，一个process可以读写(订阅)个channel，同样一个channel也可被多个process读写(订阅)。</p><p>对每个process来说：</p><ul><li>从命名channel取出并处理消息</li><li>向命名channel写入消息</li><li>创建新的process</li></ul><p>Go语言并没有完全实现CSP理论(参见<a href="https://www.zhihu.com/question/26192499" target="_blank" rel="external">知乎讨论</a>)，只提取了CSP的process和channel的概念为并发提供理论支持。目前Go已经是CSP的代表性语言。</p><h3 id="CSP-vs-Actor"><a href="#CSP-vs-Actor" class="headerlink" title="CSP vs Actor"></a>CSP vs Actor</h3><ul><li>相同的宗旨：”不要通过共享内存来通信，而应该通过通信来共享内存”</li><li>两者都有独立的，并发执行的通信实体</li><li>Actor第一类对象为执行实体(actor)，CSP第一类对象为通信介质(channel)</li><li>Actor中实体和通信介质是紧耦合的，一个Actor持有一个Mailbox，而CSP中process和channel是解耦的，没有从属关系。从这一层来说，CSP更加灵活</li><li>Actor模型中actor是主体，mailbox是匿名的，CSP模型中channel是主体，process是匿名的。从这一层来说，由于Actor不关心通信介质，底层通信对应用层是透明的。因此在分布式和容错方面更有优势</li></ul><h3 id="Go-vs-Erlang"><a href="#Go-vs-Erlang" class="headerlink" title="Go vs Erlang"></a>Go vs Erlang</h3><ul><li>以上 CSP vs Actor</li><li>均实现了语言级的coroutine，在阻塞时能自动让出调度资源，在可执行时重新接受调度</li><li>go的channel是有容量限制的，因此只能一定程度地异步(本质上仍然是同步的)，erlang的mailbox是无限制的(也带来了消息队列膨胀的风险)，并且erlang并不保证消息是否能到达和被正确处理(但保证消息顺序)，是纯粹的异步语义，actor之间做到完全解耦，奠定其在分布式和容错方面的基础</li><li>erlang/otp在actor上扩展了分布式(支持异质节点)，热更和高容错，go在这些方面还有一段路要走(受限于channel，想要在语言级别支持分布式是比较困难的)</li><li>go在消息流控上要做得更好，因为channel的两个特性: 有容量限制并独立于goroutine存在。前者可以控制消息流量并反馈消息处理进度，后者让goroutine本身有更高的处理灵活性。典型的应用场景是扇入扇出，Boss-Worker等。相比go，erlang进程总是被动低处理消息，如果要做流控，需要自己做消息进度反馈和队列控制，灵活性要差很多。另外一个例子就是erlang的receive操作需要遍历消息队列(<a href="http://www.jianshu.com/p/41f2e943c795" target="_blank" rel="external">参考</a>)，而如果用go做同步调用，通过单独的channel来做则更优雅高效</li></ul><h3 id="Actor-in-Go"><a href="#Actor-in-Go" class="headerlink" title="Actor in Go"></a>Actor in Go</h3><p>在用Go写GS框架时，不自觉地会将goroutine封装为actor来使用:</p><ul><li>GS的执行实体(如玩家，公会)的逻辑具备强状态和功能聚合性，不易拆分，因此通常是一个实体一个goroutine</li><li>实体接收的逻辑消息具备弱优先级，高顺序性的特点，因此通常实体只会暴露一个Channel与其它实体交互(结合go的interface{}很容易统一channel类型)，这个channel称为RPC channel，它就像这个goroutine的ID，几乎所有逻辑goroutine之间通过它进行交互</li><li>除此之外，实体还有一些特殊的channel，如定时器，外部命令等。实体goroutine对这些channel执行select操作，读出消息进行处理</li><li>加上goroutine的状态数据之后，此时的goroutine的行为与actor相似：接收消息(多个消息源)，处理消息，更新状态数据，向其它goroutine发送消息(通过RPC channel)</li></ul><p>到目前为止，goroutine和channel解耦的优势并未体现出来，我认为主要的原因仍然是GS执行实体的强状态性和对异步交互流程的顺序性导致的。</p><p>在研究这个问题的过程中，发现已经有人已经用go实现了Actor模型: <a href="https://github.com/AsynkronIT/protoactor-go。" target="_blank" rel="external">https://github.com/AsynkronIT/protoactor-go。</a> 支持分布式，甚至supervisor，整体思想和用法和erlang非常像，真是有种他山逢知音的感觉。:)</p><p>参考：</p><ol><li><a href="http://jolestar.com/parallel-programming-model-thread-goroutine-actor/" target="_blank" rel="external">http://jolestar.com/parallel-programming-model-thread-goroutine-actor/</a></li><li><a href="https://www.zhihu.com/question/26192499" target="_blank" rel="external">https://www.zhihu.com/question/26192499</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源于从Erlang到Go的一些思维碰撞，就像当初从C++到Erlang一样，整理下来记于此。&lt;/p&gt;
&lt;h3 id=&quot;Actor&quot;&gt;&lt;a href=&quot;#Actor&quot; class=&quot;headerlink&quot; title=&quot;Actor&quot;&gt;&lt;/a&gt;Actor&lt;/h3&gt;&lt;p&gt;Acto
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Erlang+Lua的一次重构</title>
    <link href="http://wudaijun.com/2017/03/erlang-lua-reconstruction/"/>
    <id>http://wudaijun.com/2017/03/erlang-lua-reconstruction/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-30T03:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前所在的项目基于<a href="http://wudaijun.com/2015/08/erlang-server-design1-cluster-server/">erlang cluster</a>搭建框架，再接入lua用于写逻辑。由于之前有一些erlang+lua的开发经验，因此着手项目的重构和优化，过程中一些体会，记录于此。</p><p>先简述一下项目架构，erlang做集群，网络层，节点交互，DB交互等，lua层只写逻辑。一个erlang的Actor持有一个luastate，为了加速erlang和lua之间的交互效率：</p><ol><li>将逻辑数据置于lua中而不是erlang中，在落地时，以二进制格式丢给erlang进行DB操作</li><li>以<code>lual_ref</code>和msgid等方式，尽量用整数代理字符串</li><li>erlang和lua异步运行，lua跑在原生线程池中，这在<a href="http://wudaijun.com/2015/09/erlang-server-design2-erlang-lua-battle/">这篇博文</a>中介绍过</li></ol><p>除了这些，还需要注意lua的沙盒环境管理，错误处理，热更新等，这里不再详述。就目前这种结构而言，还有一些缺陷：</p><ol><li>原子线程池忙碌可能导致的erlang虚拟机假死，需要保证原生线程池最多占用的核数不超过erlang虚拟机能使用的核数</li><li>lua state本身带来的不稳定性，特别是内存，在Actor过多时将会非常明显</li></ol><p>第二点，也是目前我们遇到的最棘手的问题，我们知道，在lua中，模块，函数，均是一个闭包，闭包包含函数和外部环境(UpValue，ENV等)，因此在lua中，每个lua state都完整包含加载的所有模块和函数，并且很难共享。我们项目通过一个share lua state完成了对配置表这类静态数据的共享(跨系统进程级的共享可参考<a href="http://blog.codingnow.com/2012/07/dev_note_24.html" target="_blank" rel="external">云风blog</a>)，但本身逻辑代码占用内存仍然很大，随着逻辑和功能模块的增加，基本一个lua state加载完模块什么也不做，会占用6-7M内存。意味着如果一个玩家一个lua state，那么一台16G内存的服务器，基本只能容纳2000个玩家，内存吃紧，而CPU过剩。因此本次重构也只要针对这个问题。</p><p>之前项目组曾针对玩家进行了优化，将主城位于一个岛的玩家归位一组，再将岛按照<code>%M</code>的方式放到M个lua state容器上，这样得到一个复杂的，三层逻辑的lua state。针对玩家这一块的内存占用确实大大减少了，但调试难度也提升了，并且扩展性不好，不能将这种容器扩展到其它service(如Union)上。</p><p>按照系统本身的理想设计，一个service(player, union)对应一个lua state，由一个erlang process代理这个lua state，并且通过cluster注册/共享这个service的状态信息。但由于lua state的内存占用，不能再奢侈地将service和lua state 1:1调配，多service在逻辑代码中共用一个lua state已经无可避免，我们可以简单将整个系统分为几个层级，</p><div class="table-container"><table><thead><tr><th>service</th><th>lua state</th><th>erlang process</th><th>cluster</th></tr></thead><tbody><tr><td>N</td><td>1</td><td>?</td><td>?</td></tr></tbody></table></div><p>因此有以下几种可能的方案：</p><ol><li><code>N 1 N N</code>：每个service对应一个erlang process，多个erlang process将代理同一个lua state，这就需要lua state可以”被并发”，也就是同一个lua state只能绑定一个原生线程池上执行，这一点是可以实现的。这种方案在erlang层会获得更好的并发性能，并且cluster层语义不变。</li><li><code>N 1 1 N</code>：一个erlang process作为container的概念代理一个lua state，容纳N个service，并且将service和erlang process的映射关系写入cluster，cluster层对外提供的语义不变，但service的actor属性被弱化，service的一致性状态是个问题。</li><li><code>N 1 1 1</code>：与上种方案类似，只不过将service到container的映射通过算法算出来，而不写入cluster，container本身被编号（编号时，可考虑将serverid编入，这样开新服有一定的扩展性，PS: <a href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">一致性哈希</a>方案不适用于游戏这类强状态逻辑），某个service将始终分配在指定container上。这种方案减少了cluster负担，并且减少了service不一致性的BUG。但由于container有状态，在每次系统启动后，service和container的映射关系就确定了，因此整个集群的可伸缩性降低了。</li></ol><p>经过几番讨论，我们最终选择了第三个方案，虽然个人认为这类固定分配的方案，与分布式的理念是相悖的，但目前稳定性和一致性才是首要目标。由于采用计算而不是通过mnesia保存映射关系，mnesia的性能和系统一致性得到了提升。本次重构在某些方面与我上一个项目<a href="http://wudaijun.com/2016/01/erlang-server-design5-server-node/">针对cluster的优化</a>有点相似，一个对系统服务进行横向切割，另一个则纵向切割，前者的初衷是为了更好地交互效率，后者则是处于对lua state资源的复用，两者都降低了系统的可伸缩性，得到了”一个更大粒度”的service。</p><p>整个重构过程中，有几点感触：</p><p>erlang和lua结合本身不是一种好的解决方案，或者说，erlang接入其它语言写逻辑都不合适，异质化的系统会打乱erlang本身的调度(不管通过nif还是线程池)，并且给整个系统带来不稳定性(CPU，内存)。另外，接入其它语言可能破坏erlang的原子语义和并发性。拿lua来说，原生线程池会和erlang调度线程抢占CPU并且很难管控，加之lua有自己的GC，因此在内存和CPU这两块关键资源上，erlang失去了控制权，给系统带来不稳定性。再加之lua state的内存占用以及lua state不支持并发，你可能要花更多的时间来调整系统结构，最终得到一个相对稳定的系统。如果处理得不好，用erlang做底层的可靠性和并发性将荡然无存。</p><p>系统设计，是一个不断根据当前情况取舍的过程，想要一步到位是不可能的。简单，可控，开发效率高才是主要指标，才能最大程度地适应各种变化，快速响应需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前所在的项目基于&lt;a href=&quot;http://wudaijun.com/2015/08/erlang-server-design1-cluster-server/&quot;&gt;erlang cluster&lt;/a&gt;搭建框架，再接入lua用于写逻辑。由于之前有一些erlang+lua
      
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="lua" scheme="http://wudaijun.com/tags/lua/"/>
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Lua 闭包 环境 包管理</title>
    <link href="http://wudaijun.com/2017/02/lua-notes/"/>
    <id>http://wudaijun.com/2017/02/lua-notes/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2017-10-31T06:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><ul><li>访问一个不存在的全局变量得到nil</li><li>释放一个全局变量只需将其赋值为nil，效果与未定义该变量一样</li><li>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量</li><li>局部变量比全局变量访问更快</li></ul><a id="more"></a><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ol><li>多参数/返回值匹配：多余忽略，缺少用nil补足</li><li>可变参数：arg，table.pack，table.unpack</li><li>命名参数：参数的非顺序填充方式</li><li>正确处理尾调用：Lua能够高效正确处理尾调用，而不会导致栈溢出</li></ol><h3 id="2-第一类函数"><a href="#2-第一类函数" class="headerlink" title="2. 第一类函数"></a>2. 第一类函数</h3><p>函数是第一类值，函数可以像其它值（string, number）样用于赋给变量，作为函数参数或返回值。函数定义实际上是一个赋值语句，将类型为function的变量赋给一个变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.bar</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></div><div class="line"><span class="comment">-- 等价于</span></div><div class="line">foo.bar = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></div></pre></td></tr></table></figure><p>从这个角度来看，自然，与变量一样，Lua有全局函数和局部函数之分。</p><h3 id="3-词法闭包"><a href="#3-词法闭包" class="headerlink" title="3. 词法闭包"></a>3. 词法闭包</h3><p>词法闭包是指当在一个函数内部嵌套定义另一个函数时，内部函数体可以访问到外部函数的局部变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> i = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>     <span class="comment">-- anonymous function</span></div><div class="line">        i = i + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> i</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">c1 = newCounter()</div><div class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 1</span></div><div class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 2</span></div><div class="line">c2 = newCounter()</div><div class="line"><span class="built_in">print</span>(c2())  <span class="comment">--&gt; 1</span></div><div class="line"></div><div class="line"><span class="comment">-- 打印c1所有的upvalue 输出: i</span></div><div class="line"><span class="keyword">local</span> i=<span class="number">1</span></div><div class="line"><span class="keyword">local</span> up = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(c1, i)</div><div class="line"><span class="keyword">while</span>(up ~= <span class="literal">nil</span>) <span class="keyword">do</span></div><div class="line">    <span class="built_in">print</span>(up, <span class="string">"  "</span>)</div><div class="line">    i = i+<span class="number">1</span></div><div class="line">    up = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(c1, i)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="built_in">print</span>(c1, c2) <span class="comment">-- function: 0x7f8df1d02100        function: 0x7f8df1d02160</span></div></pre></td></tr></table></figure><p>这种情况下，我们称i为匿名函数的外部局部变量(external local variable)或upvalue。在这里，newCounter函数返回了一个闭包(closure)。闭包是指一个函数和它的upvalues，闭包机制保证了即使upvalue已经超出了其作用域(newCounter返回)，仍然能正确被闭包函数引用而不会释放(由Lua GC管理)。在上例中，我们说c1和c2是建立在同一个函数上，但作用于同一个局部变量(i)不同实例的两个不同的闭包。</p><p>通过打印的upvalues可以看到，只有被闭包函数引用的外部局部变量，才算作该闭包函数的upvalue，Lua会按照闭包函数引用的顺序为upvalue编号，该编号与upvalue定义顺序无关。</p><p>最后一点是，闭包函数都是动态生成的，这和<a href="http://wudaijun.com/2016/09/go-basic/">Go中的闭包</a>有所不同，Go的闭包函数是在编译时生成的，不同的闭包可以共享闭包函数(同一个函数地址)。Lua的闭包函数动态生成会一定程度地影响运行效率和内存占用。</p><p>Lua闭包除了用于高级函数，回调函数，迭代器等上下文环境中以外，在完全不同的上下文环境，可用于重定义或预定义函数，通过这种方法，可以为代码创建一个安全的执行环境(也叫沙箱，sandbox)。</p><p>Lua还提供了对C闭包的支持，每当你在Lua中创建一个新的C函数，你可以将这个函数与任意多个upvalues联系起来，每一个upvalue 可以持有一个单独的Lua值。当函数被调用的时候，可以通过假索引(<code>lua_upvalueindex</code>)自由的访问任何一个upvalues。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> val = lua_tonumber(L, lua_upvalueindex(<span class="number">1</span>));</div><div class="line">    lua_pushnumber(L, ++val);   <span class="comment">/* new value */</span></div><div class="line">    lua_pushvalue(L, <span class="number">-1</span>);       <span class="comment">/* duplicate it */</span></div><div class="line">    lua_replace(L, lua_upvalueindex(<span class="number">1</span>));  <span class="comment">/* update upvalue */</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* return new value */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">newCounter</span> <span class="params">(lua_State *L)</span> </span>&#123;</div><div class="line">    lua_pushnumber(L, <span class="number">0</span>);</div><div class="line">    lua_pushcclosure(L, &amp;counter, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C闭包与Lua闭包在概念上很相似，但有两点不同：</p><ol><li>C函数的upvalues是显示push到栈中的，而Lua则可通过闭包函数引用确定哪些是upvalues</li><li>C闭包不能共享upvalues，每个闭包在栈中都有独立的变量集，但你可以通过将upvalues指向同一个table来实现共享</li></ol><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Chunk是一系列语句，Lua执行的每一块语句，比如一个文件或者交互模式下的每一行都是一个Chunk。</p><p>当我们执行loadfile(“test.lua”)时，便将test.lua的内容编译后的Chunk作为一个函数返回，如果出现编译错误，则返回nil和错误信息。而dofile相当于:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofile</span> <span class="params">(filename)</span></span></div><div class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(filename))</div><div class="line">    <span class="keyword">return</span> f()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>loadstring和dostring的关系类似，只是接收字符串而不是文件名为参数。</p><p>再看require，require和dofile完成同样的功能，但主要有几点不同：</p><ol><li>require会搜索Lua环境目录来加载文件</li><li>require会判断文件是否已经加载而避免重复加载统一文件</li><li>require可以用于加载C .so库，功能类似loadlib，参考<a href="http://wudaijun.com/2014/12/lua-C/">这里</a></li></ol><p>一个lua模块编译后的Chunk被作为匿名函数被执行，那么定义于模块中函数对模块局部变量的引用就形成了闭包，所以说Lua中的闭包真是无处不在。</p><h2 id="Enviroment"><a href="#Enviroment" class="headerlink" title="Enviroment"></a>Enviroment</h2><p>Lua中的环境用table来表示，这简化了环境处理也带来了不少灵活性。</p><p>在Lua5.1及之前，Lua将环境本身存储在一个全局变量_G中，其中包含了全局变量，内置函数，内置模块等。我们在使用任何符号x时，如果在当前函数的局部变量和upvalues无法找到符号定义(PS: Lua查找变量定义的规则为：局部变量 -&gt; 外部局部变量(upvalue) -&gt; 全局变量)，则会返回_G.x的值。由于_G是一个table，因此我们可以用它实现一些有意思的功能：</p><ol><li>通过动态名字访问全局变量： <code>_G[varname]</code></li><li>通过_G的metatable改变对未定义全局变量的读(<code>__index</code>)和写(<code>__newindex</code>)行为</li><li>通过setfenv改变指定函数的_G环境，制造函数执行的沙盒环境</li></ol><p>现在再回头来看闭包，实际上，Lua闭包除了函数和upvalues，还包括函数环境，这三者组成了一个完整的执行沙盒。</p><p>在Lua5.2及之后，Lua取消了setfenv函数，用_ENV方案替代了_G方案：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- before Lua 5.1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">  <span class="built_in">setfenv</span>(<span class="number">1</span>, &#123;&#125;)</div><div class="line">  <span class="comment">-- code here</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">-- after Lua 5.2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">local</span> <span class="built_in">_ENV</span> = &#123;&#125;</div><div class="line">  <span class="comment">-- code here</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">or</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> <span class="built_in">_ENV</span> = &#123;&#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>_ENV有三个特性：</p><ol><li>对全局变量x的引用，将转换为_ENV.x</li><li>每个编译后的Chunk，都有一个_ENV upvalue(哪怕并未使用)，作为Chunk环境，并作用于其内定义的函数</li><li>在初始化时，_ENV=_G</li></ol><p>除了以上三点外，_ENV和普通变量并无区别。因此我们可以直接通过<code>local _ENV = {}</code>来覆盖接下来的代码的环境。将环境(_ENV)作为一个普通的upvalue来处理，这样做的好处是简化了闭包的概念，闭包等于函数加upvalues(没有了全局变量_G)，为闭包优化(如合并相同upvalues的闭包)提供更好的支持，同时也减少了<code>setfenv(f, env)</code>带来的不确定性和不安全性(函数的_ENV upvalue在闭包返回时就已经确定了)。</p><p>有_ENV还是一个table，因此对全局变量的访问控制等trick，仍然很容易实现。Lua目前仍然保留_G，但理解它们的别是比较重要的：</p><p>我们都知道Lua有一个全局注册表(Registry)，其中包含整个Lua虚拟机的信息，在Registry的<code>LUA_RIDX_GLOBALS</code>索引中，保存了Globals(也就是_G)，在创建Globals时，会生成<code>_G._G=_G</code>的自引用。在引入_ENV后，初始时，<code>_ENV=_G</code>，一旦编译器将_ENV放入Chunk的upvalue后，_ENV将作为普通upvalue被看待，因此我们可以对其重新赋值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">1</span> <span class="comment">-- 此时 _ENV.i == _G.i == 1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> <span class="built_in">_ENV</span>=&#123;i=<span class="number">2</span>, <span class="built_in">print</span>=<span class="built_in">print</span>, <span class="built_in">_G</span>=<span class="built_in">_G</span>&#125;</div><div class="line">    <span class="built_in">print</span>(i, <span class="built_in">_ENV</span>.i, <span class="built_in">_G</span>.i)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">()</span></span></div><div class="line">    <span class="built_in">print</span>(i, <span class="built_in">_ENV</span>.i, <span class="built_in">_G</span>.i)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">f() <span class="comment">-- 2 2 1</span></div><div class="line">g() <span class="comment">-- 1 1 1</span></div></pre></td></tr></table></figure><p>因此，_ENV除了在创建时和_G都指向Registry[LUA_RIDX_GLOBALS]之外，和_G并没有直接联系(<code>_G={}</code>不会影响函数环境，<code>_G.x=1</code>仍然会影响注册表中的Globals)，Lua5.2及之后的环境都由_ENV指定，_G出于历史原因保留，但实际上Lua并不在内部再使用：</p><blockquote><p>Lua keeps a distinguished environment called the global environment. This value is kept at a special index in the C registry (see §4.5). In Lua, the global variable _G is initialized with this same value. (_G is never used internally.)</p></blockquote><ul><li>参考<a href="http://lua-users.org/lists/lua-l/2014-08/msg00345.html" target="_blank" rel="external">_ENV vs _G</a>，<a href="http://stackoverflow.com/questions/14290527/recreating-setfenv-in-lua-5-2" target="_blank" rel="external">setfenv in Lua5.2</a></li></ul><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>在Lua中，有闭包，灵活的table和环境管理，想要实现包管理有非常多的方法：</p><h3 id="1-基本方法"><a href="#1-基本方法" class="headerlink" title="1. 基本方法"></a>1. 基本方法</h3><p>最简单的方法就是直接使用table和第一类函数特性：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">complex = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex.new</span><span class="params">(r,i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex.add</span><span class="params">(c1,c2)</span></span> ... <span class="keyword">end</span></div><div class="line">...</div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure><p>执行这个Chunk后，便可以通过<code>complex.xxx()</code>使用complex中定义的API了。这种方案主要的缺点是包内包外的调用都必须加上前缀，并且不能很好地隐藏私有成员。</p><h3 id="2-局部函数"><a href="#2-局部函数" class="headerlink" title="2. 局部函数"></a>2. 局部函数</h3><p>通过局部函数再导出的方式，我们可以解决包内调用前缀和隐藏私有成员(不导出即可)的问题。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c1,c2)</span></span> ... <span class="keyword">end</span></div><div class="line">...</div><div class="line">complex = &#123;new = new, add = add&#125;</div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure></p><p>但这样容易忘了local，造成全局命名空间污染。</p><h3 id="3-独立环境"><a href="#3-独立环境" class="headerlink" title="3. 独立环境"></a>3. 独立环境</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">complex = &#123;&#125;</div><div class="line"><span class="comment">-- before Lua5.1: setfenv(1, complex)</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = complex</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,  i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(c1, c2)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure><p>现在，包内所有全局符号new, add都会被转换为complex.new, complex.add，并且我们为包创建了一个独立沙盒环境，如果要在包内访问全局符号，也有多种方法:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 方案1: 保存老的全局环境 之后访问全局符号需要加上 _G.前缀</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">_G</span> = <span class="built_in">_G</span></div><div class="line"><span class="comment">-- 方案2: 通过metatable 效率低一些，并且外部可通过complex.print访问_G.print</span></div><div class="line"><span class="built_in">setmetatable</span>(complex, &#123;<span class="built_in">__index</span> = <span class="built_in">_G</span>&#125;)</div><div class="line"><span class="comment">-- 方案3: 只导出要使用的函数 这种方法隔离型更好，并且更快</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">sqrt</span> = <span class="built_in">math</span>.<span class="built_in">sqrt</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">print</span> = <span class="built_in">print</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Variables&quot;&gt;&lt;a href=&quot;#Variables&quot; class=&quot;headerlink&quot; title=&quot;Variables&quot;&gt;&lt;/a&gt;Variables&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;访问一个不存在的全局变量得到nil&lt;/li&gt;
&lt;li&gt;释放一个全局变量只需将其赋值为nil，效果与未定义该变量一样&lt;/li&gt;
&lt;li&gt;Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量&lt;/li&gt;
&lt;li&gt;局部变量比全局变量访问更快&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="lua" scheme="http://wudaijun.com/categories/lua/"/>
    
    
      <category term="lua" scheme="http://wudaijun.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X下的资源限制</title>
    <link href="http://wudaijun.com/2017/02/max-osx-ulimit/"/>
    <id>http://wudaijun.com/2017/02/max-osx-ulimit/</id>
    <published>2017-02-06T16:00:00.000Z</published>
    <updated>2017-02-08T04:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>系统的资源是有限的(如CPU，内存，内核所能打开的最大文件数等)，资源限制对针对进程能使用的系统资源设定上限。防止恶意进程无限制地占用系统资源。</p><p>资源限制分为两种，硬限制(Hard Limit)和软限制(Soft Limit)，软限制作用于实际进程并且可以修改，但不能超过硬限制，硬限制只有Root权限才能修改。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>在Mac OS X下，有如下三个命令与系统资源有关。</p><h3 id="launchctl"><a href="#launchctl" class="headerlink" title="launchctl"></a>launchctl</h3><p>launchctl管理OS X的启动脚本，控制启动计算机时需要开启的服务(通过后台进程launchd)。也可以设置定时执行特定任务的脚本，类似Linux cron。</p><p>例如，开机时自动启动Apache服务器：</p><pre><code>$ sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist</code></pre><p>关于launchctl的plist格式和用法参考:</p><ol><li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/launchctl.1.html" target="_blank" rel="external">launchctl man page</a></li><li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html" target="_blank" rel="external">launchd plist man page</a></li><li><a href="http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/" target="_blank" rel="external">mac-os-x-launchd-is-cool</a></li><li><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="external">creating launchd jobs</a></li></ol><p>简单来说，plist文件用类似XML格式定义了一个命令(及启动参数)和该命令的执行方式(定时执行，系统启动执行，用户登录执行等)。我们这里不着重讨论，我们关心launchctl中如何查看/更改系统资源限制。</p><pre><code># Usage: launchctl limit [&lt;limit-name&gt; [&lt;both-limits&gt; | &lt;soft-limit&gt; &lt;hard-limit&gt;]# 查看文件描述符限制launchctl limit maxfilesmaxfiles    256            unlimited # 修改软限制为512 系统重启失效sudo launchctl limit maxfiles 512 unlimited# 可将launchctl子命令写入/etc/launchd.conf中# 在launchd启动时 会执行该文件中的命令limit maxfiles 512 unlimited</code></pre><p>通过将更改命令写入plist文件，并在启动时执行，也可永久更改资源限制：</p><ol><li><p>新建Library/LaunchDaemons/limit.maxfiles.plist文件，写入</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;   &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;           &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt;     &lt;dict&gt;     &lt;key&gt;Label&lt;/key&gt;     &lt;string&gt;limit.maxfiles&lt;/string&gt;     &lt;key&gt;ProgramArguments&lt;/key&gt;     &lt;array&gt;       &lt;string&gt;launchctl&lt;/string&gt;       &lt;string&gt;limit&lt;/string&gt;       &lt;string&gt;maxfiles&lt;/string&gt;       &lt;string&gt;64000&lt;/string&gt;       &lt;string&gt;524288&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;RunAtLoad&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;ServiceIPC&lt;/key&gt;     &lt;false/&gt;   &lt;/dict&gt; &lt;/plist&gt;</code></pre></li><li><p>修改文件权限</p><pre><code> sudo chown root:wheel /Library/LaunchDaemons/limit.maxfiles.plist sudo chmod 644 /Library/LaunchDaemons/limit.maxfiles.plist</code></pre></li><li><p>加载plist文件(或重启系统后生效 launchd在启动时会自动加载该目录的plist)</p><pre><code> sudo launchctl load -w /Library/LaunchDaemons/limit.maxfiles.plist</code></pre></li><li><p>确认更改后的限制</p><pre><code> launchctl limit maxfiles</code></pre></li></ol><h3 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h3><p>大多数类Unix系统都通过(Linux/*BSD/OS X)都提供该命令来更改资源限制和内核配置：</p><pre><code># 查看当前内核和进程能打开的文件描述符限制$ sysctl -A | grep kern.maxfileskern.maxfiles: 12288             # 系统级的限制kern.maxfilesperproc: 10240    # 内核级的限制# 通过sysctl命令热更改 系统重启后失效$ sysctl -w kern.maxfilesperproc=20480# 通过配置文件永久更改 重启生效# 在/etc/sysctl.conf中写入kern.maxfiles=20480 kern.maxfilesperproc=24576</code></pre><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>ulimit是shell的内置命令，用于查看/更改当前shell及其创建的子进程的资源限制。使用比较简单：</p><pre><code># 查看当前shell(及其子进程)的所有限制ulimit -a# 改变进程能打开的最大文件描述符数软限制 当shell关闭后失效# 将其写入对应shell的startup文件(如~/.bashrc, ~/.zshrc)，可保留更改ulimit -S -n 1024</code></pre><h2 id="区别联系"><a href="#区别联系" class="headerlink" title="区别联系"></a>区别联系</h2><p>这三个命令的关系在Mac OS X各版本中尤其混乱，先说说本人的一些试验(Mac OS X 10.10.3)：</p><ul><li>在默认配置下(不配置plist和sysctl.conf)，launchctl的maxfiles默认值为(256, unlimited)，sysctl的maxfiles默认值为(12288, 10240)，而ulimit -n得到的值为4864。</li><li>当不定义plist而定义sysctl.conf，那么重启后launchctl和ulimit看到的上限仍为默认值，sysctl看到的上限与sysctl.conf定义的一致。</li><li>当同时在<code>/etc/sysctl.conf</code>和<code>/Library/LaunchDaemons/limit.maxfiles.plist</code>中定义maxfiles时，plist文件中的配置会覆盖sysctl.conf中的配置。如果通过系统重启应用plist，三个命令看到的上限均为plist配置。如果通过launchctl load加载plist，则会同步影响sysctl看到的上限，而不会影响shell下的ulimit上限。</li><li>如果通过launchctl配置的软上限和硬上限分别为S和H(非unlimited)，那么通过launchctl应用配置后最终得到软上限和硬上限都为S。如果设定的上限为S和unlimited，实际上应用的参数为S和10240(sysctl中kern.maxfilesperproc默认值)，当S&gt;10240时，会设置失败，S&lt;10240时，会得到(S, 10240)</li><li><code>ulimit -H -n 1000</code> 降低硬上限无需Root权限，升高则需要</li></ul><p>趁着头大，还可以看看这几篇文章:</p><ol><li><a href="http://superuser.com/questions/827984/open-files-limit-does-not-work-as-before-in-osx-yosemite" target="_blank" rel="external">open files limit does not work as before in osx yosemite</a></li><li><a href="http://krypted.com/mac-os-x/maximum-files-in-mac-os-x/" target="_blank" rel="external">maximum files in mac os x</a></li><li><a href="http://unix.stackexchange.com/questions/108174/how-to-persist-ulimit-settings-in-osx-mavericks" target="_blank" rel="external">how to persist ulimit settings in osx mavericks</a></li><li><a href="https://docs.basho.com/riak/kv/2.2.0/using/performance/open-files-limit/#mac-os-x" target="_blank" rel="external">open files limit in max os x</a></li><li><a href="http://superuser.com/questions/302754/increase-the-maximum-number-of-open-file-descriptors-in-snow-leopard" target="_blank" rel="external">increase the maximum number of open file descriptors in snow leopard</a></li></ol><p>网上对Mac OS X各版本的解决方案各不相同，并且对这三个命令(特别是launchctl和sysctl)在资源限制上的联系与区别也没有清晰的解释。</p><p>按照我的理解和折腾出来的经验：</p><ol><li>ulimit只影响当前Shell下的进程，并且受限于kern.maxfilesperproc</li><li>如果配置了plist，那么重启后，ulimit和sysctl均会继承plist中的值</li><li>热修改sysctl上限值不会影响launchctl，而反之，launchctl会影响sysctl上限值</li></ol><p>综上，在Mac OS X 10.10(我的版本，没试过之前的)之后，使用plist是最合理的方案(但launchctl貌似只能设定一样的软限制和硬限制，如果将硬限制设为ulimited，则会使用kern.maxfilesperproc值)。在系统重启后，kern.maxfilesperproc和ulimit -n都会继承plist maxfiles的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统的资源是有限的(如CPU，内存，内核所能打开的最大文件数等)，资源限制对针对进程能使用的系统资源设定上限。防止恶意进程无限制地占用系统资源。&lt;/p&gt;
&lt;p&gt;资源限制分为两种，硬限制(Hard Limit)和软限制(Soft Limit)，软限制作用于实际进程并且可以修改
      
    
    </summary>
    
      <category term="system" scheme="http://wudaijun.com/categories/system/"/>
    
    
      <category term="system" scheme="http://wudaijun.com/tags/system/"/>
    
      <category term="macosx" scheme="http://wudaijun.com/tags/macosx/"/>
    
  </entry>
  
  <entry>
    <title>Go 常用命令</title>
    <link href="http://wudaijun.com/2017/01/go-command-notes/"/>
    <id>http://wudaijun.com/2017/01/go-command-notes/</id>
    <published>2017-01-19T16:00:00.000Z</published>
    <updated>2017-02-06T08:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><ul><li>Go版本管理: <a href="https://github.com/moovweb/gvm" target="_blank" rel="external">gvm</a>(go version manager)</li><li>GOPATH管理: <a href="https://github.com/pote/gvp" target="_blank" rel="external">gvp</a>(go version package)</li><li>依赖版本管理: <a href="https://github.com/pote/gpm" target="_blank" rel="external">gpm</a>(go package manager)</li></ul><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p>用于编译指定的源码文件或代码包以及它们的依赖包。</p><blockquote><p>import导入路径中的最后一个元素是路径名而不是包名，路径名可以和包名不一样，但同一个目录只能定义一个包(包对应的_test测试包除外)</p></blockquote><a id="more"></a><p>编译包:</p><pre><code># 当前路径方式cd src/foo &amp;&amp; go build# 包导入路径方式go build foo bar# 本地代码包路径方式go build ./src/foo</code></pre><p>go build 在编译只包含库源码文件的代码包时，只做检查性的编译，不会输出任何结果文件。如果编译的是main包，则会将编译结果放到执行命令的目录下。</p><p>编译源码文件:</p><pre><code># 指定源码文件使用文件路径# 指定的多个源码文件必须属于同一个目录(包)go build src/foo/foo1.go src/foo/foo2.go</code></pre><p>当执行以上编译时，编译命令在分析参数的时候如果发现第一个参数是Go源码文件而不是代码包时，会在内部生成一个名为“command-line-arguments”的虚拟代码包。也就是当前的foo1.go foo2.go属于”command-line-arguments”包，而不是foo包，因此除了指定的源码文件和它们所依赖的包，其它文件(如foo3.go)不会被编译。</p><p>同样，对于库源码文件，build不会输出任何结果文件。对于main包的源文件，go build要求有且只能有一个main函数声明，并将生成结果(与指定的第一个源码文件同名)放在执行该命令的当前目录下。</p><p>构建与<code>go build</code>之上的其它命令(如<code>go run</code>，<code>go install</code>)，在编译包或源码文件时，过程和特性是一样的。</p><p>常用选项:</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-v</td><td>打印出那些被编译的代码包的名字。</td></tr><tr><td>-n</td><td>打印编译期间所用到的其它命令，但是并不真正执行它们。</td></tr><tr><td>-x</td><td>打印编译期间所用到的其它命令。注意它与-n标记的区别。</td></tr><tr><td>-a</td><td>强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。</td></tr><tr><td>-work</td><td>打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。</td></tr></tbody></table></div><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>go run编译(通过go build)并运行命令源码文件(main package)，查看过程:</p><pre><code>go run -x -work src/main/main.go# build 临时目录WORK=/var/folders/n5/j8y6skrx1xn3_ls64gl1lrsmmp53rv/T/go-build979313546# main.go依赖foo包  先编译foo包mkdir -p $WORK/foo/_obj/mkdir -p $WORK/cd /Users/wudaijun/Work/test/src/foo/usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/compile -o $WORK/foo.a -trimpath $WORK -p foo -complete -buildid cd61b5a9f3c8eba0f3088adca894fc9bf695826b -D _/Users/wudaijun/Work/test/src/foo -I $WORK -pack ./foo.go# 在虚拟包 command-line-arguments 中编译 main.gomkdir -p $WORK/command-line-arguments/_obj/mkdir -p $WORK/command-line-arguments/_obj/exe/cd /Users/wudaijun/Work/test/src/main/usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/compile -o $WORK/command-line-arguments.a -trimpath $WORK -p main -complete -buildid 9131b7dd9f64a85bb423da7f8a7d408c089a23e8 -D _/Users/wudaijun/Work/test/src/main -I $WORK -I /Users/wudaijun/Work/test/pkg/darwin_amd64 -pack ./main.go# 链接cd ./usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/link -o $WORK/command-line-arguments/_obj/exe/main -L $WORK -L /Users/wudaijun/Work/test/pkg/darwin_amd64 -w -extld=clang -buildmode=exe -buildid=9131b7dd9f64a85bb423da7f8a7d408c089a23e8 $WORK/command-line-arguments.a# 从临时目录运行可执行文件$WORK/command-line-arguments/_obj/exe/mainCall Foo()</code></pre><p>可看到<code>go run</code>的执行结果都在WORK临时目录中完成，由于使用了<code>-work</code>选项，因此WORK目录会在<code>go run</code>执行完成后保留。<code>go run</code>只接受命令源文件而不接收包路径作为参数，并且不会在当前目录生成任何文件。</p><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>只比<code>go build</code>多干一件事：安装编译后的结果文件到指定目录。</p><h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h3><p><code>go test</code>编译指定包或源文件，并执行所在包对应的测试用例。一个符合规范的测试文件指：</p><ul><li>文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码</li><li>你必须import testing这个包</li><li>所有的测试用例函数必须是Test开头</li><li>测试用例会按照源代码中写的顺序依次执行</li><li>测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态</li><li>测试格式：<code>func TestXxx (t *testing.T)</code>,Xxx部分可以为任意的字母数字的组合，但是- - 首字母不能是小写字母[a-z]，例如Testingdiv是错误的函数名</li><li>函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息</li></ul><p>测试分为包内测试和包外测试，即测试源码文件可于被测试源码文件位于同一个包(目录)，或者测试源码文件声明的包名可以是被测试包名+”_test”后缀。</p><p>另外，可以用一些插件来辅助编写测试用例，如<a href="https://github.com/cweill/gotests/" target="_blank" rel="external">gotest</a>(支持sublime, emacs, vim)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境管理&quot;&gt;&lt;a href=&quot;#环境管理&quot; class=&quot;headerlink&quot; title=&quot;环境管理&quot;&gt;&lt;/a&gt;环境管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go版本管理: &lt;a href=&quot;https://github.com/moovweb/gvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gvm&lt;/a&gt;(go version manager)&lt;/li&gt;
&lt;li&gt;GOPATH管理: &lt;a href=&quot;https://github.com/pote/gvp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gvp&lt;/a&gt;(go version package)&lt;/li&gt;
&lt;li&gt;依赖版本管理: &lt;a href=&quot;https://github.com/pote/gpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gpm&lt;/a&gt;(go package manager)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;go-build&quot;&gt;&lt;a href=&quot;#go-build&quot; class=&quot;headerlink&quot; title=&quot;go build&quot;&gt;&lt;/a&gt;go build&lt;/h3&gt;&lt;p&gt;用于编译指定的源码文件或代码包以及它们的依赖包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;import导入路径中的最后一个元素是路径名而不是包名，路径名可以和包名不一样，但同一个目录只能定义一个包(包对应的_test测试包除外)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>CSS 笔记</title>
    <link href="http://wudaijun.com/2017/01/css-notes/"/>
    <id>http://wudaijun.com/2017/01/css-notes/</id>
    <published>2017-01-08T16:00:00.000Z</published>
    <updated>2017-10-31T06:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-选择器"><a href="#一-选择器" class="headerlink" title="一. 选择器"></a>一. 选择器</h2><h3 id="1-普通选择器"><a href="#1-普通选择器" class="headerlink" title="1. 普通选择器"></a>1. 普通选择器</h3><div class="table-container"><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>标签选择器</td><td>div</td><td>以HTML 标签类型来选择元素,又叫类型选择器</td></tr><tr><td>类选择器</td><td>.span1</td><td>以class属性值来选择元素,可在页面中出现多个</td></tr><tr><td>ID选择器</td><td>#inst</td><td>以id属性值来选择元素,在页面中只能出现一次</td></tr></tbody></table></div><a id="more"></a><h3 id="2-并列选择器"><a href="#2-并列选择器" class="headerlink" title="2. 并列选择器"></a>2. 并列选择器</h3><div class="table-container"><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>并列选择器</td><td>div1,span1</td><td>同时定义多个样式,即该CSS有多个名称,简化CSS书写</td></tr></tbody></table></div><h3 id="3-层级选择器"><a href="#3-层级选择器" class="headerlink" title="3. 层级选择器"></a>3. 层级选择器</h3><div class="table-container"><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>后代选择器</td><td>body .span1</td><td>选择指定祖先元素内的后代元素</td></tr><tr><td>直接子元素选择器</td><td>body &gt; .span1</td><td>选择指定父元素内的直接子元素</td></tr></tbody></table></div><p>例子:</p><pre><code>/* body .span1 影响元素E1 E2 *//* body &gt; .span1 只影响元素E2 */ &lt;body&gt;    &lt;span class=&quot;span1&quot;&gt; E1 &lt;/span&gt;    &lt;div&gt; &lt;span class=&quot;span1&quot;&gt; E2 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="4-兄弟选择器"><a href="#4-兄弟选择器" class="headerlink" title="4. 兄弟选择器"></a>4. 兄弟选择器</h3><div class="table-container"><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>普通兄弟选择器</td><td>div ~ p</td><td>选择第一个元素后的兄弟元素,两者拥有相同的父元素</td></tr><tr><td>相邻兄弟选择器</td><td>div + p</td><td>选择第一个元素后紧跟的元素,两者拥有相同的父元素</td></tr></tbody></table></div><p>例子:</p><pre><code>/* div + p 影响 Three Six *//* div ~ p 影响 Three Six Seven */&lt;div&gt;    &lt;p&gt;One&lt;/p&gt;    &lt;div&gt;Two&lt;/div&gt;    &lt;p&gt;Three&lt;/p&gt;&lt;/div&gt;&lt;div&gt;    &lt;div&gt;Four&lt;/div&gt;    &lt;div&gt;&lt;p&gt;Five&lt;/p&gt;&lt;/div&gt;    &lt;p&gt;Six&lt;/p&gt;    &lt;p&gt;Seven&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="5-伪类-伪元素"><a href="#5-伪类-伪元素" class="headerlink" title="5. 伪类/伪元素"></a>5. 伪类/伪元素</h3><ul><li>伪类: 用于定义同一样式的不同状态</li><li><p>伪元素: 用来添加一些选择器的特殊效果</p><pre><code>  /* 常见伪类 */  a:link {color:#FF0000;} /* 未访问的链接 */  a:visited {color:#00FF00;} /* 已访问的链接 */  a:hover {color:#FF00FF;} /* 鼠标划过链接 */  a:active {color:#0000FF;} /* 已选中的链接 */  p:first-child{color:blue;} /* 改变当p作为父元素第一个子元素时的样式*/   /* 常见伪元素 */  h1:before{content:url(smiley.gif);} /* 在元素内容之前插入图片 */  h1:after{content:url(smiley.gif);} /* 在元素内容之后插入图片 */  p:first-line {color:#ff0000;} /* 为文本的首行设置特殊样式 */  p:first-letter {color:#ff0000;} /* 为文本的首字母设置特殊样式 */</code></pre></li></ul><h3 id="6-优先级"><a href="#6-优先级" class="headerlink" title="6. 优先级"></a>6. 优先级</h3><p><code>!import</code> &gt; 元素内嵌样式 &gt; ID选择器 &gt; Class选择器 &gt; 类型选择器 &gt; 父元素继承值，如果一个选择器应用的多个样式重复定义了某一属性，则样式在CSS中定义顺序越后面优先级越高。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">...</div><div class="line">h1 &#123;color: red; &#125;</div><div class="line">  .pink-text &#123; color: pink; &#125;</div><div class="line">  .blue-text &#123; color: blue; &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"orange-text"</span> <span class="attr">class</span>=<span class="string">"blue-text pink-text"</span> <span class="attr">style</span>=<span class="string">"color: white"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">应用color属性的优先级为: style="color:white" &gt; .orange-text &gt; .pink-text &gt; blue-text &gt; h1类型选择器 &gt; 从body继承color值</div><div class="line"></div><div class="line">如果对pink-text的color属性应用了!important，那么应用important的属性优先级将始终最高!</div></pre></td></tr></table></figure><h2 id="二-内外边距"><a href="#二-内外边距" class="headerlink" title="二. 内外边距"></a>二. 内外边距</h2><h3 id="1-元素结构"><a href="#1-元素结构" class="headerlink" title="1. 元素结构"></a>1. 元素结构</h3><p> <img src="/assets/image/css/css-padding-margin.gif" alt=""></p><h3 id="2-padding"><a href="#2-padding" class="headerlink" title="2. padding"></a>2. padding</h3><p>内边距，定义元素边框和元素内容之间的留白</p><ul><li>可填充背景</li><li>相邻元素的内边距会叠加(15px + 20px=35px)</li></ul><h3 id="3-margin"><a href="#3-margin" class="headerlink" title="3. margin"></a>3. margin</h3><p>外边距，元素周围生成额外的空白区。“空白区”通常是指其他元素不能出现且父元素背景可见的区域。</p><ul><li>不可填充背景</li><li>边界是完全透明的(父元素背景可见)</li><li>相邻元素的边界会被折叠15px + 20px=20px)</li></ul><p>margin可为负数，当static元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。例如：</p><pre><code>/* 元素向上移10px*/#mydiv1 {margin-top:-10px;}</code></pre><p>但如果你设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。</p><pre><code>/* #mydiv1后续元素向上移10px, #mydiv1 本身不移动 */#mydiv1 {margin-bottom:-10px;}</code></pre><p>关于负margin的更多用法: <a href="https://www.w3cplus.com/css/the-definitive-guide-to-using-negative-margins.html" target="_blank" rel="external">https://www.w3cplus.com/css/the-definitive-guide-to-using-negative-margins.html</a></p><h3 id="4-外边距合并"><a href="#4-外边距合并" class="headerlink" title="4. 外边距合并"></a>4. 外边距合并</h3><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><p>垂直外边距合并问题常见于第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距。如:</p><pre><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;title&gt;垂直外边距合并&lt;/title&gt;    &lt;style&gt;        .top{width:160px; height:50px; background:#ccf;}        .middle{width:160px; background:#cfc;}        .middle .firstChild{margin-top:20px;}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;middle&quot;&gt;        &lt;div class=&quot;firstChild&quot;&gt;我其实只是想和我的父元素隔开点距离。&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>原因：根据CSS规范，当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距会发生合并。因此firstChild和其父元素middle的上外边距重叠，并顶开了middle和top间的外边距。解决方案是为middle定义边框或者内边距。参考<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">CSS外边距合并</a>，<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="external">padding or margin</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-选择器&quot;&gt;&lt;a href=&quot;#一-选择器&quot; class=&quot;headerlink&quot; title=&quot;一. 选择器&quot;&gt;&lt;/a&gt;一. 选择器&lt;/h2&gt;&lt;h3 id=&quot;1-普通选择器&quot;&gt;&lt;a href=&quot;#1-普通选择器&quot; class=&quot;headerlink&quot; title=&quot;1. 普通选择器&quot;&gt;&lt;/a&gt;1. 普通选择器&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标签选择器&lt;/td&gt;
&lt;td&gt;div&lt;/td&gt;
&lt;td&gt;以HTML 标签类型来选择元素,又叫类型选择器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;类选择器&lt;/td&gt;
&lt;td&gt;.span1&lt;/td&gt;
&lt;td&gt;以class属性值来选择元素,可在页面中出现多个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ID选择器&lt;/td&gt;
&lt;td&gt;#inst&lt;/td&gt;
&lt;td&gt;以id属性值来选择元素,在页面中只能出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="web" scheme="http://wudaijun.com/categories/web/"/>
    
    
      <category term="web" scheme="http://wudaijun.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Erlang 内存问题诊断</title>
    <link href="http://wudaijun.com/2016/12/erlang-memory-debug/"/>
    <id>http://wudaijun.com/2016/12/erlang-memory-debug/</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2016-12-27T09:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过<code>erlang:memory()</code>查看节点内存占用总览，需要通过静态和动态两个维度对内存进行考核：</p><ul><li>静态: 各类内存占用比例，是否有某种类的内存占用了节点总内存的绝大部分</li><li>动态: 各类内存增长特性，如增长速度，或是否长期增长而不回收(atom除外)</li></ul><p>找出有疑似内存泄露的种类后，再进行下一步分析</p><h3 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h3><p>atom不会被GC，这意味着我们应该对atom内存增长更加重视而不是忽略。在编写代码时，尽量避免动态生成atom，因为一旦你的输入源不可靠或受到攻击(特别针对网络消息)，atom内存增长可能导致节点crash。可以考虑将atom生成函数替换为更安全的版本：</p><pre><code>list_to_atom/1 -&gt; list_to_existing_atom/1binary_to_atom/2 -&gt; binary_to_existing_atom/2binary_to_term(Bin) -&gt; binary_to_term(Bin,[safe])</code></pre><h3 id="ets"><a href="#ets" class="headerlink" title="ets"></a>ets</h3><p>ets内存占用通常是由于表过大，通过<code>ets:i().</code>查看ets表条目数，大小，占用内存等。</p><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>进程内存占用过高可能有两方面原因，进程数量过大和进程占用内存过高。针对于前者，首先找出那些没有被链接或监控的”孤儿进程”：</p><pre><code>[P || P&lt;-processes(),    [{_,Ls},{_,Ms}] &lt;- [process_info(P,[links,monitors])],    []==Ls,[]==Ms].</code></pre><p>或通过<code>supervisor:count_children/1</code>查看sup下进程数量和状态。</p><p>而如果是进程所占内存过高，则可将内存占用最高的几个进程找出来进行检查:</p><pre><code>recon:proc_count(memory, 10). % 打印占用内存最高的10个进程recon:proc_count(message_queue_len, 10). % 打印消息队列最长的10个进程</code></pre><h3 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h3><p>erlang binary大致上分为两种，heap binary(&lt;=64字节)和refc binary(&gt;64字节)，分别位于进程堆和全局堆上，进程通过ProBin持有refc binary的引用，当refc binary引用计数为0时，被GC。关于binary的详细实现，参考<a href="http://wudaijun.com/2015/12/erlang-datastructures/">Erlang常用数据结构实现</a>。</p><p>recon提供的关于binary问题检测的函数有：</p><pre><code>% 打印出引用的refc binary内存最高的N个进程recon:proc_count(binary_memory, N)% 对所有进程执行GC 打印出GC前后ProcBin个数减少数量最多的N个进程recon:bin_leak(N)</code></pre><p>以上两个函数，通常可以找出有问题的进程，然后针对进程的业务逻辑和上下文进行优化。通常来说，针对于refc binary，有如下思路：</p><ul><li>每过一段时间手动GC(高效，不优雅)</li><li>如果只持有大binary中的一小段，用<code>binary:copy/1-2</code>(减少refc binary引用)</li><li>将涉及大binary的工作移到临时一次性进程中，做完工作就死亡(变相的手动GC)</li><li>对非活动进程使用hibernate调用(该调用将进程挂起，执行GC并清空调用栈，在收到消息时再唤醒)</li></ul><p>一种典型地binary泄露情形发生在当一个生命周期很长的中间件当作控制和传递大型refc binary消息的请求控制器或消息路由器时，因为ProcBin仅仅只是个引用，因此它们成本很低而且在中间件进程中需要花很长的时间去触发GC，所以即使除了中间件其他所有进程都已经GC了某个refc binary对应的ProcBin，该refc binary也需要保留在共享堆里。因此中间件进程成为了主要的泄漏源。</p><p>针对这种情况，有如下解决方案：</p><ul><li>避免中间件接触到refc binary，由中间件进程返回目标进程的Pid，由原始调用者来进行binary转发</li><li>调整中间件进程的GC频率(fullsweep_after)</li></ul><h3 id="driver-nif"><a href="#driver-nif" class="headerlink" title="driver/nif"></a>driver/nif</h3><p>另一部分非Erlang虚拟机管制的内存通常来自于第三方Driver或NIF，要确认是否是这部分内存出了问题，可通过<code>recon_alloc:memory(allocated).</code>和OS所报告的内存占用进行对比，可以大概得到C Driver或NIF分配的内存，再根据该部分内存的增长情况和占用比例来判断是否出现问题。</p><p>如果是纯C，那么内存使用应该是相对稳定并且可预估的，如果还挂接了Lua这类动态语言，调试起来要麻烦一些，在我们的服务器中，Lua部分是无状态的，可以直接重新加载Lua虚拟机。其它的调试手段，则要透过Lua层面的GC机制去解决问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;code&gt;erlang:memory()&lt;/code&gt;查看节点内存占用总览，需要通过静态和动态两个维度对内存进行考核：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态: 各类内存占用比例，是否有某种类的内存占用了节点总内存的绝大部分&lt;/li&gt;
&lt;li&gt;动态: 各类内存增长特性，如增长
      
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Unicode编码</title>
    <link href="http://wudaijun.com/2016/12/unicode-in-erlang/"/>
    <id>http://wudaijun.com/2016/12/unicode-in-erlang/</id>
    <published>2016-12-16T16:00:00.000Z</published>
    <updated>2017-02-22T02:45:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unicode基础"><a href="#Unicode基础" class="headerlink" title="Unicode基础"></a>Unicode基础</h2><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>定义字符集中每个字符的<strong>codepoint(数字编码)</strong></p><ul><li>ASCII: 不用多说，编码空间为7位(0-127)</li><li><a href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="external">ISO 8859-1</a>: 又称Latin-1，以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号。编码空间为8位(0-255)</li><li>UCS-2: 16位编码空间 又称基本多文种平面或零平面</li><li>UCS-4: 32位编码空间 在UCS-2基本上，加入辅助平面(目前有16个辅助平面，至少需要21位)</li><li>注1: UCS(Universal Character Set, <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="external">通用字符集</a>)</li><li>注2: 以上四种编码都是向前兼容的，通常我们所说的Unicode编码指UCS-2和UCS-4，目前广泛运用的是UCS-2</li></ul><a id="more"></a><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>实现方式将字符的数字编码存储在计算机字节中，由于节省空间和平台差异性等，衍生不同的实现方式</p><ul><li><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">UTF-8</a>: 一种变长编码，使用1-3个字节编码UCS-2字符集，1-6个字节可编码UCS-4字符集(目前只用最多四个字节即可表示UCS-4所定义的17个平面)。优点是兼容ASCII，节省空间，并且不存在字节序的问题</li><li><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="external">UTF-16</a>: 和UTF-8类似，使用2个字节来编码UCS-2字符集(UCS-2中有预留的位用于实现UTF-16扩展多字节)，使用4个字节来编码UCS-4字符集。由于使用两个字节作为基本编码单位，UTF-16存在字节序的问题，通常使用BOM来解决</li><li><a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="external">UTF-32</a>: 32位定长编码，能够表示UCS-4字符集所有字符，但空间占用大，因此很少见</li><li>注1: UTF(Unicode Transformation Format, Unicode转换格式)</li><li>注2: BOM(byte-order mark, <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank" rel="external">字节顺序标记</a>)</li></ul><h2 id="Erlang中的Unicode"><a href="#Erlang中的Unicode" class="headerlink" title="Erlang中的Unicode"></a>Erlang中的Unicode</h2><h3 id="Unicode表示"><a href="#Unicode表示" class="headerlink" title="Unicode表示"></a>Unicode表示</h3><pre><code>%% 环境 Mac OSX Yosemite &amp; Erlang OTP/19Eshell V8.1  (abort with ^G)1&gt; L = &quot;中文&quot;.[20013,25991] % Erlang lists存放的是字符的Unicode编码2&gt; B = &lt;&lt;&quot;中文&quot;&gt;&gt;.&lt;&lt;45,135&gt;&gt; % Erlang只知&quot;中文&quot;的Unicode编码[20013,25991]，并不知应该用何种实现方式(UTF8或其他)，默认它会将Unicode编码 rem 256，产生0-255间的编码(并按照Lantin-1解码)% 下面我们将考虑将&quot;中文&quot;转换为binary% 方案一. erlang:list_to_binary -&gt; error3&gt; list_to_binary(L). % 该函数支持的list只能是iolist(见后面术语参考)，否则Erlang并不知道你想将字符串转换为何种编码格式的binary** exception error: bad argument     in function  list_to_binary/1        called as list_to_binary([20013,25991])% 方案二. unicode:characters_to_binary -&gt; ok4&gt; UTF8 = unicode:characters_to_binary(L).% 将L中的unicode编码转换为UTF8 binary&lt;228,184,173,230,150,135&gt;&gt;5&gt; UTF16Big = unicode:characters_to_binary(UTF8,utf8,utf16).&lt;&lt;78,45,101,135&gt;&gt; % 默认为Big Endian6&gt; UTF16Little = unicode:characters_to_binary(UTF8,utf8,{utf16,little}).&lt;&lt;45,78,135,101&gt;&gt;% 方案三. 利用binary构造语法构建7&gt; UTF8 = &lt;&lt;&quot;中文&quot;/utf8&gt;&gt;.&lt;&lt;228,184,173,230,150,135&gt;&gt;8&gt; UTF8 = &lt;&lt;L/utf8&gt;&gt;. % Why ?** exception error: bad argument</code></pre><p>在Erlang中，字符串就是整数列表，并且这个整数可以无限大，lists将保存其中每个字符的Unicode编码，只要lists中的整数是有效的Unicode codepoint，就可以找到对应的字符。因此也就不存在UTF8/UTF16格式的lists字符串一说。而binary的处理则要麻烦一些，Erlang用UTF8作为Unicode在binary上的实现方式，unicode模块提供了这方面丰富的unicode编码处理接口。</p><h3 id="Unicode使用"><a href="#Unicode使用" class="headerlink" title="Unicode使用"></a>Unicode使用</h3><pre><code>8&gt; io:format(&quot;~s&quot;, [L]).** exception error: bad argument in function  io:format/3    called as io:format(&lt;0.50.0&gt;,&quot;~s&quot;,[[20013,25991]])9&gt; io:format(&quot;~p&quot;, [L]).[20013,25991]ok10&gt; io:format(&quot;~ts&quot;, [L]).中文ok11&gt; io:format(&quot;~s&quot;, [UTF8]).ä¸­æok12&gt; io:format(&quot;~p&quot;, [UTF8]).&lt;&lt;228,184,173,230,150,135&gt;&gt;ok13&gt; io:format(&quot;~ts&quot;, [UTF8]).中文ok</code></pre><p>先解释几个Erlang术语：</p><ul><li><a href="http://www.cnblogs.com/me-sa/archive/2012/01/31/erlang0034.html" target="_blank" rel="external">iolist</a>: 0-255编码(Latin-1)的lists，binary，或它们的嵌套，如<code>[[&quot;123&quot;,&lt;&lt;&quot;456&quot;&gt;&gt;],&lt;&lt;&quot;789&quot;&gt;&gt;]</code></li><li>unicode binary: UTF8编码的binary(Erlang默认使用UTF8 binary编码unicode)</li><li>charlist: UTF8编码的binary，或包含有效unicode codepoint的lists，或它们的嵌套，如<code>[&lt;&lt;&quot;hello&quot;&gt;&gt;, &quot;中国&quot;]</code></li></ul><p><code>~s</code>只能打印iolist，binary，或atom，因此不能直接打印中文lists(无法解码超过255的codepoint)或UTF8 binary(会按字节解释，出现乱码)。</p><p><code>~ts</code>则可打印charlist和unicode binary。</p><p><code>~p</code>如果不能打印出ASCII(0-127)字符，则直接打印出原生Term，不会对Unicode编码进行处理。</p><p>参考：</p><ol><li><a href="http://erlang.org/doc/man/unicode.html" target="_blank" rel="external">http://erlang.org/doc/man/unicode.html</a></li><li><a href="http://erlang.org/doc/apps/stdlib/unicode_usage.html" target="_blank" rel="external">http://erlang.org/doc/apps/stdlib/unicode_usage.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Unicode基础&quot;&gt;&lt;a href=&quot;#Unicode基础&quot; class=&quot;headerlink&quot; title=&quot;Unicode基础&quot;&gt;&lt;/a&gt;Unicode基础&lt;/h2&gt;&lt;h3 id=&quot;编码方式&quot;&gt;&lt;a href=&quot;#编码方式&quot; class=&quot;headerlink&quot; title=&quot;编码方式&quot;&gt;&lt;/a&gt;编码方式&lt;/h3&gt;&lt;p&gt;定义字符集中每个字符的&lt;strong&gt;codepoint(数字编码)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASCII: 不用多说，编码空间为7位(0-127)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/ISO/IEC_8859-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ISO 8859-1&lt;/a&gt;: 又称Latin-1，以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号。编码空间为8位(0-255)&lt;/li&gt;
&lt;li&gt;UCS-2: 16位编码空间 又称基本多文种平面或零平面&lt;/li&gt;
&lt;li&gt;UCS-4: 32位编码空间 在UCS-2基本上，加入辅助平面(目前有16个辅助平面，至少需要21位)&lt;/li&gt;
&lt;li&gt;注1: UCS(Universal Character Set, &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;通用字符集&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;注2: 以上四种编码都是向前兼容的，通常我们所说的Unicode编码指UCS-2和UCS-4，目前广泛运用的是UCS-2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>探索Docker在Erlang集群中的应用</title>
    <link href="http://wudaijun.com/2016/11/docker-erlang/"/>
    <id>http://wudaijun.com/2016/11/docker-erlang/</id>
    <published>2016-11-04T16:00:00.000Z</published>
    <updated>2016-11-14T08:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>接<a href="http://0.0.0.0:4444/2016/11/docker-basic/" target="_blank" rel="external">上篇</a>，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。</p><h2 id="简单Docker交互"><a href="#简单Docker交互" class="headerlink" title="简单Docker交互"></a>简单Docker交互</h2><p>下面是个简单的echo server：</p><pre><code>-module(server_echo).-export([start/0]).start() -&gt;     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),     {ok, Listen} = gen_tcp:listen(2345, [ binary                                         , {packet, 0}                                         , {reuseaddr, true}                                         , {active, true}                                         ]),     io:format(&quot;SERVER Listening on port 2345\n&quot;),     accept(Listen). accept(Listen) -&gt;     {ok, Socket} = gen_tcp:accept(Listen),     WorkerPid = spawn(fun() -&gt; echo(Socket) end),     gen_tcp:controlling_process(Socket, WorkerPid),     accept(Listen). echo(Socket) -&gt;     receive         {tcp, Socket, Bin} -&gt;             io:format(&quot;SERVER Received: ~p\n&quot;, [Bin]),             gen_tcp:send(Socket, Bin),             echo(Socket);         {tcp_closed, Socket} -&gt;             io:format(&quot;SERVER: The client closed the connection\n&quot;)     end.</code></pre><p>简单起见，我们直接用<code>telnet</code>命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。</p><a id="more"></a><h3 id="容器中运行"><a href="#容器中运行" class="headerlink" title="容器中运行"></a>容器中运行</h3><pre><code>sudo docker run -it --rm -v ~/docker:/code -w /code erlang erlErlang/OTP 19 [erts-8.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.1  (abort with ^G)1&gt; c(server_echo).{ok,server_echo}2&gt; server_echo:start().SERVER Trying to bind to port 2345SERVER Listening on port 2345</code></pre><p>在<code>docker run</code>中，我们将本地代码路径挂载到容器的/code目录，并且将/code作为容器的工作目录，此后对本地代码的修改，将直接反映在容器中，而无需拷贝。运行容器后会进入erl shell，并且当前路径(/code)即为本地代码路径(~/docker)，之后编译运行server即可。</p><h3 id="宿主机访问容器"><a href="#宿主机访问容器" class="headerlink" title="宿主机访问容器"></a>宿主机访问容器</h3><p>如下方案可以让宿主机能访问容器端口：</p><ul><li>在<code>docker run</code>中指定<code>-p 2345:2345</code>导出2345端口，之后访问宿主机的2345端口等同于访问容器2345端口</li><li>在<code>docker run</code>中指定<code>--network host</code>使容器和宿主机共享网络栈，IP和端口</li><li>通过<code>docker inspect</code>查询容器IP地址(如:<code>172.17.0.2</code>)，可在宿主机上通过该IP访问容器</li></ul><h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器间交互方式主要有三种：</p><ul><li>通过<code>docker inspect</code>得到容器IP地址，通过IP地址进行容器间的交互</li><li>通过<code>docker run</code>中指定<code>--network container:&lt;name or id&gt;</code>，将新创建的容器与一个已经存在的容器的共享网络栈，IP和端口</li><li>通过<code>docker run</code>的<code>--link &lt;name or id&gt;</code>选项链接两个容器，之后可以将容器名或容器ID作为Hostname来访问容器，注意<code>--link</code>选项仅在<code>--network bridge</code>下有效</li></ul><h3 id="定义Dockerfile"><a href="#定义Dockerfile" class="headerlink" title="定义Dockerfile"></a>定义Dockerfile</h3><p>前面我是通过挂载目录的方式将本地代码映射到容器中，这种方式在本地开发中比较方便，但是在项目部署或环境配置比较复杂时，我们需要通过Dockerfile来构建自己的镜像(而不是基于官方Erlang镜像)，初始化项目环境，就本例而言，Dockerfile非常简单：</p><pre><code>FROM erlangRUN mkdir codeCOPY server_echo.erl code/server_echo.erlRUN cd code &amp;&amp; erlc server_echo.erlWORKDIR /codeENTRYPOINT [&quot;erl&quot;, &quot;-noshell&quot;, &quot;-run&quot;, &quot;server_echo&quot;, &quot;start&quot;]</code></pre><h2 id="Erlang多节点通信"><a href="#Erlang多节点通信" class="headerlink" title="Erlang多节点通信"></a>Erlang多节点通信</h2><h3 id="再谈Erlang分布式通信"><a href="#再谈Erlang分布式通信" class="headerlink" title="再谈Erlang分布式通信"></a>再谈Erlang分布式通信</h3><p>Erlang的分布式节点有自己的通信机制，这套通信机制对上层用户是透明的，我们只需一个节点名(<code>node@host</code>)，即可访问这个节点，而无需关心这个节点是在本机上还是在其它主机上。在这之上封装的Pid，进一步地屏蔽了节点内进程和跨节点进程的差异。</p><p>在<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>中，我提到了Erlang的分布式设施，其中epmd扮演着重要的角色：它维护了本机上所有节点的节点名到节点监听地址的映射，并且由于epmd进程本身的监听端口在集群内是周知的(默认为4369)，因此可以根据节点名<code>node@host</code>得到节点所在主机上epmd的监听地址(<code>host:4369</code>)，进而从epmd进程上查询到节点名<code>node</code>所监听的地址，实现节点间通信。</p><h3 id="在同主机不同容器中部署集群"><a href="#在同主机不同容器中部署集群" class="headerlink" title="在同主机不同容器中部署集群"></a>在同主机不同容器中部署集群</h3><p>现在回到Docker，我们先尝试在同一个主机，不同容器上建立集群：</p><pre><code># 容器A 启动后通过docker inspect查询得到IP地址: 172.17.0.2sudo docker run -it erlang /bin/bashroot@4453d880b5a5:/# erl -name n1@172.17.0.2 -setcookie 123Eshell V8.1  (abort with ^G)(n1@172.17.0.2)1&gt; # 容器B 启动后通过docker inspect查询得到IP地址: 172.17.0.4sudo docker run -it erlang /bin/bashroot@dd0f30178036:/# erl -name n2@172.17.0.4 -setcookie 123Eshell V8.1  (abort with ^G)(n2@172.17.0.4)1&gt; net_kernel:connect_node(&#39;n1@172.17.0.2&#39;).true(n2@172.17.0.4)2&gt; nodes().[&#39;n1@172.17.0.2&#39;]</code></pre><p>和在宿主机上一样，我们可以直接通过容器IP架设集群。这里使用的是<code>-name node@host</code>指定的longname，而如果使用shortname：</p><pre><code># 容器Aroot@4453d880b5a5:/# erl -sname n1 -setcookie 123Eshell V8.1  (abort with ^G)(n1@4453d880b5a5)1&gt;# 容器Broot@dd0f30178036:/# erl -sname n2 -setcookie 123Eshell V8.1  (abort with ^G)(n2@dd0f30178036)1&gt; net_kernel:connect_node(&#39;n1@4453d880b5a5&#39;).false</code></pre><p>在shortname方案中，我们并不能通过nodename访问节点，本质上是因为<code>n2</code>节点不能通过<code>4453d880b5a5:4369</code>访问到<code>n1</code>节点所在主机上的epmd进程。我们测试一下网络环境：</p><pre><code># 通过容器A名字pingping 4453d880b5a5ping: unknown host# 直接ping容器A IPping 172.17.0.2PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.099 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.089 ms</code></pre><p>发现是hostname解析出了问题，容器链接来解决这个问题：</p><pre><code># 重新启动容器B 并链接到容器Adocker run -it --link 4453d880b5a5 erlang /bin/bashroot@7692c8c71218:/# erl -sname n2 -setcookie 123Eshell V8.1  (abort with ^G)(n2@dd0f30178036)1&gt; net_kernel:connect_node(&#39;n1@4453d880b5a5&#39;).true</code></pre><p>有个有趣的问题是，当容器B link了容器A，那么容器B能通过容器A的Id或名字访问容器B，而反过来，容器A却不能以同样的方式访问容器B。也就是说link是单向的，这同样可以通过ping来验证。</p><h3 id="在不同的主机上部署集群"><a href="#在不同的主机上部署集群" class="headerlink" title="在不同的主机上部署集群"></a>在不同的主机上部署集群</h3><p>在不同的主机上部署集群，问题开始变得复杂：</p><ol><li>不同的主机上的Docker容器处于不同的子网(一台主机对应一个子网)，因此不同主机上的容器不能直接访问，需要先发布(publish)Erlang节点监听端口</li><li>Erlang节点在Docker容器中的监听地址是由Erlang VM启动时分配的，因此我们无法在启动容器时就获知Erlang节点监听端口(从而发布该端口)</li><li>假定我们预配置了Erlang节点的监听端口xxx，如果我们使用<code>-p xxx:xxx</code>将可能导致端口争用(亦即一台物理机只能运行一个Docker容器)，如果我们使用<code>-p xxx</code>将该端口发布到主机任意一个端口，那么这个发布的主机端口，将只能通过Docker Daemon获取到(命令行下可通过<code>docker port</code>查看)</li><li>再来看epmd，每个Docker容器中都会跑一个epmd进程，它记录的是节点名到<strong>节点在容器中的监听地址</strong>，因此，epmd本身返回的地址是不能直接被其它主机上的节点使用的</li></ol><h4 id="Erlang-In-Docker"><a href="#Erlang-In-Docker" class="headerlink" title="Erlang In Docker"></a>Erlang In Docker</h4><p>基于上面的种种限制，有人给出了一套解决方案：<a href="https://github.com/Random-Liu/Erlang-In-Docker" target="_blank" rel="external">Erlang In Docker</a>。这套方案对Erlang集群做了如下制约：</p><ol><li>每个Docker容器只能运行一个Erlang节点</li><li>预配置Erlang节点的监听端口</li><li>Erlang节点名格式为<code>DockerContainerID@HostIP</code></li><li>使用Docker Daemon而不是epmd来获取节点监听端口</li></ol><p>这套方案的核心思路是用Docker Daemon替换epmd做节点监听的服务发现，原因有二：</p><ul><li>Docker Daemon运行于主机同级网络中</li><li>维护了容器端口和主机端口的映射关系</li></ul><p>如果节点A想要访问节点B，则节点A需要提供：</p><ul><li>节点B所在主机地址: Host</li><li>节点B所在主机上Docker Daemon的监听端口: DaemonPort</li><li>节点B所在容器ID: ContainerID</li><li>节点B在所在容器中的监听端口: Port0</li></ul><p>之后就可以通过Docker Daemon(<code>Host:DaemonPort</code>)查询到<code>ContainerID</code>容器的<code>Port0</code>端口在主机上对应的发布端口<code>Port1</code>，之后节点A即可通过<code>Host:Port1</code>与节点B通信。</p><p>然而节点A只有节点B的名字，要在节点B中编码这四条信息是非常困难的，因此Erlang In Docker的做法是，预配置Port0(12345)和DaemonPort(4243)，剩下的主机地址和容器ID则编码在节点名中：<code>DockerContainerID@HostIP</code>。</p><p>EID代码并不复杂，得益于Erlang可替换的分布式通信协议，EID只自定义了<code>eid_tcp_dist</code>(替换默认的<code>inet_tcp_dist</code>模块)和dpmd(通过与Docker Daemon交互模拟epmd的功能)两个模块。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>将Erlang应用到Docker上比较困难的主要原因是Erlang已经提供了非常完备的分布式设施(参见<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>)，并且这一套对上层都是透明的。EID这套方案看起来限制很多，但细想也没多大问题，具体还要看在生产环境中的表现，目前我比较顾虑它的通信效率(NAT)和<code>eid_tcp_dist</code>是否足够健壮。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接&lt;a href=&quot;http://0.0.0.0:4444/2016/11/docker-basic/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上篇&lt;/a&gt;，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。&lt;/p&gt;
&lt;h2 id=&quot;简单Docker交互&quot;&gt;&lt;a href=&quot;#简单Docker交互&quot; class=&quot;headerlink&quot; title=&quot;简单Docker交互&quot;&gt;&lt;/a&gt;简单Docker交互&lt;/h2&gt;&lt;p&gt;下面是个简单的echo server：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-module(server_echo).
-export([start/0]).

start() -&amp;gt;
     io:format(&amp;quot;SERVER Trying to bind to port 2345\n&amp;quot;),
     {ok, Listen} = gen_tcp:listen(2345, [ binary
                                         , {packet, 0}
                                         , {reuseaddr, true}
                                         , {active, true}
                                         ]),
     io:format(&amp;quot;SERVER Listening on port 2345\n&amp;quot;),
     accept(Listen).

 accept(Listen) -&amp;gt;
     {ok, Socket} = gen_tcp:accept(Listen),
     WorkerPid = spawn(fun() -&amp;gt; echo(Socket) end),
     gen_tcp:controlling_process(Socket, WorkerPid),
     accept(Listen).

 echo(Socket) -&amp;gt;
     receive
         {tcp, Socket, Bin} -&amp;gt;
             io:format(&amp;quot;SERVER Received: ~p\n&amp;quot;, [Bin]),
             gen_tcp:send(Socket, Bin),
             echo(Socket);
         {tcp_closed, Socket} -&amp;gt;
             io:format(&amp;quot;SERVER: The client closed the connection\n&amp;quot;)
     end.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单起见，我们直接用&lt;code&gt;telnet&lt;/code&gt;命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。&lt;/p&gt;
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习</title>
    <link href="http://wudaijun.com/2016/11/docker-basic/"/>
    <id>http://wudaijun.com/2016/11/docker-basic/</id>
    <published>2016-10-31T16:00:00.000Z</published>
    <updated>2017-11-21T13:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-理解-Docker"><a href="#一-理解-Docker" class="headerlink" title="一. 理解 Docker"></a>一. 理解 Docker</h2><p>Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：</p><ul><li>隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势</li><li>一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。</li></ul><a id="more"></a><p>Docker和其它虚拟机或容器技术相比，一是轻量，开销很小，二是发展迅速， 平台兼容性增长很快。虽然Docker的应用场景很多，但都是基于虚拟化和容器技术的这两种特性在特定问题下提出的解决方案。</p><p>下面来看看Docker的基本概念：</p><ol><li>Docker是C/S模式的，包括docker CLI和docker daemon两部分，它们之间通过RESTful API交互，Docker CLI就是我们用的docker命令</li><li>镜像(Image)：是一个只读的模板，包含了系统和运行程序，是用于创建容器的一系列指令(Dockfile)，相当于一份虚拟机的磁盘文件。</li><li>容器(Container)：当镜像启动后就转化为容器，容器是运行着的镜像，在容器内的修改不会影响镜像，程序的写入操作都保存在容器中。容器可被启动，停止和删除，由docker daemon管理。</li><li>仓库(Registry)：Docker镜像可通过公有和私有的仓库来进行共享和分发，仓库是存放和分享镜像文件的场所，功能类似于Github。Docker仓库有免费的<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>和付费的<a href="https://store.docker.com/" target="_blank" rel="external">Docker Store</a>。</li></ol><h2 id="二-Docker-容器"><a href="#二-Docker-容器" class="headerlink" title="二. Docker 容器"></a>二. Docker 容器</h2><h3 id="1-容器操作"><a href="#1-容器操作" class="headerlink" title="1. 容器操作"></a>1. 容器操作</h3><p>通常我们都使用docker CLI和docker daemon交互完成docker操作，随着docker日渐完善，docker所提供的功能和参数也更复杂，以下只列举几个常用的。</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>从镜像中创建并启动容器，常用Options有：</p><ul><li><code>-d</code>：后台运行</li><li><code>-t</code>：为容器分配一个伪终端，通常于-i一起使用</li><li><code>-i</code>：以交互模式运行容器，如果开了-i而没有指定-t，可以通过管道与容器交互</li><li><code>-v</code>：为容器挂载目录，冒号前为宿主机目录，其后为容器目录</li><li><code>-p</code>： [hip:]hport:cport 端口映射，将容器端口绑定到指定主机端口</li><li><code>--name</code>：为容器命名</li><li><code>--link</code>：链接到其它容器，之后可通过容器ID或容器名访问该容器(只针对bridge)</li><li><code>--ip</code>：指定容器的IP</li><li><code>--network</code>：配置容器的网络</li><li><code>--rm</code>：当容器退出时，删除容器</li></ul><p>完整的命令可通过<code>docker run --help</code>查看。</p><p>例如：</p><pre><code>docker run -it ubuntu:14.04 /bin/bash </code></pre><p>我们就以<code>ubuntu:14:04</code>镜像启动了一个容器，并进入到bash交互模式。docker所做的事情为，先在本地查找ubuntu镜像，如果没有，将从<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>中拉取到本地，解析镜像文件，创建容器，并运行<code>/bin/bash</code>命令。</p><p>每个容器在创建时，docker daemon都会为其生成一个Container ID，容器在运行结束后，为<code>STOP</code>状态，可以通过Container ID或容器名字再次启动/停止或删除。可通过<code>docker ps</code>来查看容器状态。以下是其它常用的容器管理命令：</p><pre><code>// 查看容器， 默认只显示运行中的容器，-a选项可显示所有容器docker ps [OPTIONS]// 启动容器docker start/stop [OPTIONS] CONTAINER [CONTAINER...]// 停止容器docker rm CONTAINER// 把后台容器调到前端docker attach [OPTIONS] CONTAINER// 查询容器的详细信息，也可用于镜像docker inspect [OPTIONS] CONTAINER/IMAGE// 在容器内执行指定命令 如:  docker exec -it CONTAINER bashdocker exec [OPTIONS] CONTAINER COMMAND [ARG...]也可使用第三方工具如nsenter来进入容器</code></pre><h3 id="2-容器持久化"><a href="#2-容器持久化" class="headerlink" title="2. 容器持久化"></a>2. 容器持久化</h3><p>镜像是分层存储的，容器也一样，每一个容器以镜像为基础层，在其上构建一个当前容器的可读可写层，容器对文件的所有更改都基于这一层。容器的可读可写层的生命周期与容器一样，当容器消亡时，容器在可读可写层作出的任何更改都将丢失(容器不能对基础镜像作出任何更改)。</p><p>有几种方式可以持久化容器作出的更改:</p><ol><li>通过<code>docker commit</code>以镜像构建的方式将可读可写层提交为一个新的镜像(<code>docker commit</code>是<code>docker run</code>的逆操作)。这种方式并不推荐，因为手动commit构建的镜像没有Dockerfile说明，是”隐晦”的，使用者并不知道你对镜像作出了何种修改。</li><li>在运行容器时指定<code>docker run -v hostdir:containerdir</code>来将宿主机上的某个目录挂载到容器的指定目录下，这样容器对该目录作出的所有更改，都直接写入到宿主机上，效率也更高。这通常用于在容器中导出应用日志和数据，这样容器消亡后，日志和数据信息不会丢失。</li><li>通过网络IO，将数据持久化到其它地方，如mongo，redis等。</li></ol><p>我们在运行容器时，要尽量保证容器的运行是”无状态”的，即容器可以随时被终止而重要数据不会丢失。</p><h2 id="三-Docker-镜像"><a href="#三-Docker-镜像" class="headerlink" title="三. Docker 镜像"></a>三. Docker 镜像</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1. Dockerfile"></a>1. Dockerfile</h3><p>Docker的镜像通过一个Dockerfile构建，我们可以通过编Dockerfile来创建自定义镜像：</p><pre><code># 这是注释INSTRUCTION args</code></pre><p>Dockerfile不区分大小写，但惯例是将指令大写，下面介绍几个Dockerfile中常用的指令：</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>FROM命令必须是Dockerfile的第一条指令，用于指明基础镜像(镜像基础层)：</p><pre><code># 格式：FROM &lt;image&gt;[:&lt;tag&gt;]FROM ubuntu:14:04FROM erlang</code></pre><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>在当前镜像的顶层执行命令(比如安装一个软件包)，将执行结果commit到当前镜像层。</p><p>RUN有两种格式：</p><pre><code># shell 格式，相当于 /bin/sh -c &lt;command&gt;# 意味着可以访问shell环境变量 如$HOMERUN &lt;command&gt;# exec 格式，推荐格式，直接执行命令，不会打开shell# 这种格式更灵活，强大RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# 以下两种写法完全等价RUN echo &quot;hello&quot;RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></pre><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD指令的主要目的是为容器提供默认值，这些默认值可以包含容器执行入口和参数，也可以只指定参数，这种情况下，容器入口由ENTRYPOINT指出。CMD有三种定义方式：</p><pre><code># exec 格式 指定了执行入口和参数# 可被docker run &lt;image&gt;后的参数覆盖CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]# 当ENTRYPOINT存在时，exec格式退化为默认参数格式# 此时CMD提供的参数将被附加到ENTRYPOINT指定的入口上# 可被docker run &lt;image&gt;后的参数覆盖CMD [&quot;param1&quot;, &quot;param2&quot;]# shell 格式 这种格式不能为ENTRYPOINT提供默认参数  只能提供默认执行入口# 会被ENTRYPOINT或docker run &lt;image&gt;指定的入口覆盖CMD command param1 param2</code></pre><p>Dockerfile中只能有一个CMD命令(如果有多个，只有最后一个生效)，如果CMD要作为ENTRYPOINT的默认参数(即第二种定义方式)，那么CMD和ENTRYPOINT都必须以Json数组的方式指定。</p><p>CMD和RUN的区别：RUN在<code>docker build</code>构建镜像时执行，将执行结果写入新的镜像层(实际上也是通过容器写入的，详见后面<code>docker build</code>命令)，而CMD在<code>docker run</code>时执行，执行结果不会写入镜像。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>ENTRYPOINT用于设置在容器启动时执行命令，ENTRYPOINT有两种定义方式：</p><pre><code># exec格式 推荐格式ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# shell格式 以这种方式定义，CMD和docker run提供的参数均不能附加给command命令参数ENTRYPOINT command param1 param2</code></pre><p><code>docker run &lt;image&gt;</code>后面的参数将会附加在ENTRYPOINT指定的入口上，如：</p><pre><code>FROM ubuntu:14.04ENTRYPOINT [&quot;echo&quot;, &quot;hello&quot;]CMD [&quot;world&quot;]</code></pre><p>构建镜像<code>docker build -t echo_img .</code>，之后如果我们以<code>docker run --rm echo_img</code>启动容器，CMD指定的默认参数将附加在ENTRYPOINT的入口上，因此相当于执行<code>echo hello world</code>。而如果我们以<code>docker run --rm echo_img wudaijun</code>启动容器，此时<code>docker run</code>提供的参数将覆盖CMD指定的默认参数，相当于执行<code>echo hello wudaijun</code>。</p><p>再举个例子：</p><pre><code>FROM ubuntu:14.04CMD [&quot;echo&quot;, &quot;hello&quot;]</code></pre><p>由于没有指定ENTRYPOINT，因此CMD指定了默认的执行入口<code>echo hello</code>，如果<code>docker run &lt;image&gt;</code>未指定任何参数，则执行<code>echo hello</code>，否则<code>docker run &lt;image&gt;</code>的参数将覆盖CMD指定的执行入口。如果我们再加上Dockerfile中再加一行<code>ENTRYPOINT [&quot;echo&quot;]</code>，并且<code>docker run &lt;image&gt;</code>后未指定参数，那么将执行<code>echo echo hello</code>，输出<code>echo hello</code>。</p><p>和CMD一样，ENTRYPOINT在Dockerfile中最多只能生效一个，如果定义了多个，只有最后一个生效，在docker run中可通过<code>docker run --entrypoint</code>覆盖ENTRYPOINT。</p><p>CMD和ENTRYPOINT的区别：CMD和ENTRYPOINT都可用于设置容器执行入口，但CMD会被<code>docker run &lt;image&gt;</code>后的参数覆盖；而ENTRYPOINT会将其当成参数附加给其指定的命令（不会对命令覆盖）。另外CMD还可以单独作为ENTRYPOINT的所接命令的可选参数。如果容器是Execuatble的，通常用法是，用ENTRYPOINT定义不常变动的执行入口和参数(exec格式)，用CMD提供额外默认参数(exec格式)，再用<code>docker run &lt;image&gt;</code>提供的参数来覆盖CMD。另外，ENTRYPOINT指定的入口也可以是shell script，用于实现更灵活的容器交互。</p><p>ENTRYPOINT，CMD，RUN在定义时，均推荐使用Json数组方式。参见<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices" target="_blank" rel="external">Dockerfile Best Practices</a></p><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><pre><code>ENV: 定义环境变量，该变量可被后续其它指令引用，并且在生成的容器中同样有效ADD: src dst 将本地文件拷贝到镜像，src可以是文件路径或URL，ADD支持自动解压tar文件COPY: 和ADD类似，但不支持URL并且不能自动解压EXPOSE: port, 指定容器在运行时监听的端口WORKDIR: path, 指定容器的工作目录(启动之后的当前目录)VOLUME: [path], 在容器中设置一个挂载点，用于挂载宿主机或其它容器的目录 </code></pre><p>关于Dockerfile的语法参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile Reference</a>。</p><h3 id="2-docker-build-原理"><a href="#2-docker-build-原理" class="headerlink" title="2. docker build 原理"></a>2. docker build 原理</h3><p><code>docker build</code>的核心机制包括<code>docker commit</code>和<code>build cache</code>两部分。</p><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>写好Dockerfile之后，通过<code>docker build</code>即可构建镜像：</p><pre><code>docker build -t 镜像名[:tag]  Dockerfile所在目录或URL</code></pre><p><code>docker build</code>将按照指令顺序来逐层构建镜像，每一条指令的执行结果将会commit为一个新的镜像层，并用于下一条指令。理解镜像层和commit的概念，是理解Docker镜像构建的关键。</p><p>镜像是被一层一层地”commit”上去的，而commit操作本身是由Docker容器执行的。<code>docker build</code>在执行一条指令时，会根据当前镜像层启动一个容器，Docker会在容器的层级文件系统最上层建立一层空的可读可写层(镜像层的内容对于容器来说是readonly的)，之后Docker容器执行指令，将执行结果写入可读可写层(并更新镜像Json文件)，最后再通过<code>docker commit</code>命令将可读可写层提交为一个新的镜像层。</p><p>Docker镜像层与镜像层之间是存在层级关系的，<code>docker build</code>会为Dockerfile每一条指令建立(commit)一个镜像层，并最终产生一个带标签(tag)的镜像，之前Dockerfile指令得到的镜像层(不会在构建完成后删除)是这个含标签镜像的祖先镜像。这样做的好处是最大化地复用镜像，不同的镜像之间可以共享镜像层，组成树形的镜像层级关系。</p><h4 id="build-cache"><a href="#build-cache" class="headerlink" title="build cache"></a>build cache</h4><p>在<code>docker build</code>过程中，如果发现本地有镜像与即将构建出来的镜像层一致时，则使用已有镜像作为Cache，充当本次构建的结果。从而加快build过程，并且避免构建重复的镜像。</p><p>那么docker是如何知道当前尚未构建的镜像的形态，并且与本地镜像进行比较呢？</p><p>Docker镜像由镜像文件系统内容和镜像Json文件两部分构成，前者即为<code>docker commit</code>提交的可读可写层，而镜像Json文件的作用为：</p><ul><li>记录镜像的父子关系，以及父子间的差异信息</li><li>弥补镜像本身以及镜像到容器转换所需的额外信息</li></ul><p>比如镜像Json文件中记录了当前镜像的父镜像，以及当前镜像与父镜像的差异(比如执行了哪条指令)，<code>docker build</code>则在这个基础上进行预测：</p><ul><li>判断已有镜像和目标镜像(当前正在构建的镜像)是父镜像ID是否相同</li><li>评估已有镜像的Json文件(如执行了那条命令，有何变动)，与目标镜像是否匹配</li></ul><p>如果条件满足，则可将已有镜像作为目标镜像的Cache，当然这种机制是并不完善的，比如当你执行的指令有外部动态依赖，此时可通过<code>docker build --no-cache</code>禁止使用Cache。</p><p>另外，基于build cache的机制，我们在写Dockerfile的时候，应该将静态安装，配置命令等尽可能放在Dockerfile前面，这样才能最大程度地利用cache，加快build过程。因为一旦Dockerfile前面有指令更新了并导致新的镜像层生成，那么该指令之后的镜像层cache也就完全失效了(树结构长辈节点更新了，子节点当然就不一样了)。</p><h3 id="3-docker-build-示例"><a href="#3-docker-build-示例" class="headerlink" title="3. docker build 示例"></a>3. docker build 示例</h3><p>Dcokerfile:</p><pre><code>FROM ubuntu:14.04# 创建一个100M的文件 /testRUN dd if=/dev/zero of=/test bs=1M count=100RUN rm /testRUN dd if=/dev/zero of=/test bs=1M count=100# 在根目录统计容器大小ENTRYPOINT [&quot;du&quot;, &quot;-sh&quot;]</code></pre><p>build镜像：</p><pre><code>▶ docker build . Sending build context to Docker daemon   599 kBStep 1 : FROM ubuntu:14.04 ---&gt; 1e0c3dd64ccdStep 2 : RUN dd if=/dev/zero of=/test bs=1M count=100 ---&gt; Running in d98f674c46f2100+0 records in100+0 records out104857600 bytes (105 MB) copied, 0.0980112 s, 1.1 GB/s ---&gt; f3a606172d91Removing intermediate container d98f674c46f2Step 3 : RUN rm /test ---&gt; Running in 14544c0dc6a0 ---&gt; 7efc0655e95dRemoving intermediate container 14544c0dc6a0Step 4 : RUN dd if=/dev/zero of=/test bs=1M count=100 ---&gt; Running in 387be027ef2f100+0 records in100+0 records out104857600 bytes (105 MB) copied, 0.0852024 s, 1.2 GB/s ---&gt; 38e3ea5c1412Removing intermediate container 387be027ef2fStep 5 : ENTRYPOINT du -sh ---&gt; Running in e190adcbcce2 ---&gt; baec9103f182Removing intermediate container e190adcbcce2Successfully built baec9103f182</code></pre><p>可以看到build过程为不断基于当前镜像启动中间容器(如d98f674c46f2容器基于1e0c3dd64ccd镜像层执行指令<code>RUN dd if=/dev/zero of=/test bs=1M count=100</code>并提交f3a606172d91镜像层)。通过<code>docker history &lt;image&gt;</code>可查看镜像层级关系：</p><pre><code>docker history baec9103f182                                                                                IMAGE               CREATED             CREATED BY                                      SIZE                COMMENTbaec9103f182        4 minutes ago       /bin/sh -c #(nop)  ENTRYPOINT [&quot;du&quot; &quot;-sh&quot;]      0 B38e3ea5c1412        4 minutes ago       /bin/sh -c dd if=/dev/zero of=/test bs=1M cou   104.9 MB7efc0655e95d        4 minutes ago       /bin/sh -c rm /test                             0 Bf3a606172d91        4 minutes ago       /bin/sh -c dd if=/dev/zero of=/test bs=1M cou   104.9 MB1e0c3dd64ccd        3 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0 B&lt;missing&gt;           3 weeks ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#39;doc   7 B&lt;missing&gt;           3 weeks ago         /bin/sh -c sed -i &#39;s/^#\s*\(deb.*universe\)$/   1.895 kB&lt;missing&gt;           3 weeks ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B&lt;missing&gt;           3 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &#39;#!/bin/sh&#39; &gt; /u   194.6 kB&lt;missing&gt;           3 weeks ago         /bin/sh -c #(nop) ADD file:bc2e0eb31424a88aad   187.7 MB</code></pre><p>注意到其中一些镜像层的SIZE为0，这是因为该镜像层执行的命令不会影响到镜像的文件系统大小，这些命令会单独记录在镜像Json文件中。由于镜像的层级原理，Docker在执行<code>RUN rm /test</code>指令时，并没有真正将其当前镜像f3a606172d91中的/test文件真正删掉，而是将rm操作记录在镜像Json文件中(容器只能在其上层的可读写层进行更改操作)，最终我们得到的镜像大小约为400M。</p><p>然后我们基于得到镜像启动容器：</p><pre><code>docker run --rm baec9103f182du: cannot access &#39;./proc/1/task/1/fd/4&#39;: No such file or directorydu: cannot access &#39;./proc/1/task/1/fdinfo/4&#39;: No such file or directorydu: cannot access &#39;./proc/1/fd/4&#39;: No such file or directorydu: cannot access &#39;./proc/1/fdinfo/4&#39;: No such file or directory296M    .</code></pre><p>我们的容器大小只是近300M，因此Docker镜像的大小和容器中文件系统内容的大小是两个概念。镜像的大小等于其包含的所有镜像层之和，并且由于镜像层共享技术的存在(比如我们再构建一个基于ubuntu14:04的镜像，将直接复用本地已有的ubuntu镜像层)，极大节省了磁盘空间。</p><ol><li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices" target="_blank" rel="external">Dockerfile Best Practices</a></li><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile Reference</a></li><li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="external">Docker run Reference</a></li><li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker 从入门到实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-理解-Docker&quot;&gt;&lt;a href=&quot;#一-理解-Docker&quot; class=&quot;headerlink&quot; title=&quot;一. 理解 Docker&quot;&gt;&lt;/a&gt;一. 理解 Docker&lt;/h2&gt;&lt;p&gt;Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势&lt;/li&gt;
&lt;li&gt;一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记(7) 记线上一次回档BUG</title>
    <link href="http://wudaijun.com/2016/10/erlang-server-design7-cluster-bug-note/"/>
    <id>http://wudaijun.com/2016/10/erlang-server-design7-cluster-bug-note/</id>
    <published>2016-10-16T16:00:00.000Z</published>
    <updated>2016-10-18T06:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有十几个玩家报告被回档，几小时到一两天不等</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在我们的<a href="http://wudaijun.com/2016/01/erlang-server-design5-server-node/">集群架构</a>中，集群有若干GS节点，每个GS节点可部署N个GS服务器，整个集群所有的玩家进程注册于cluster，我们通过为每个服开一个player_mgr来维护单服玩家状态，player_mgr维护{player_id, agent_pid, player_pid}三元组，用户处理多点登录，单服逻辑，离线玩家LRU等。cluster本身只提供服务注册/注销，如果做服务替换(如agent)，确保服务的唯一性(如player)应该由外部逻辑来确保，cluster并不知晓内部各种服务的特性。player进程启动/终止时，会向player_mgr和cluster分别注册/注销自己。</p><a id="more"></a><h3 id="问题追踪"><a href="#问题追踪" class="headerlink" title="问题追踪"></a>问题追踪</h3><ol><li>error日志中出现几十个rewrite player process(重写cluster中player服务)的错误日志，并且这些玩家基本都属于一个公会</li><li>所有玩家进程的启动(login, get_fork)均由player_mgr控制，player_mgr确保玩家进程唯一，依赖的是自身的State数据，而不是cluster，问题可能出在player_mgr 和 cluster 状态不一致上</li><li>写了个检查脚本，查出仍有有个别玩家存在于cluster而不在player_mgr中，这类玩家在get_fork或login时，player_mgr会重新开一个player进程，导致rewrite player process，此时同一时刻就存在两个player进程(老玩家进程Pid0，新玩家进程Pid1)，已有Agent消息会被重新路由(通过cluster服务查找)到Pid1进程上，而Pid0不在cluster和player_mgr中，不会被终止，但会不断写盘，称第三方进程，这是导致玩家回档的根本原因</li><li>现在问题焦点：为什么player_mgr维护的数据和cluster不一致(比cluster少)</li><li>在player_mgr LRU剔除玩家进程时，是先在自己State中删除玩家进程，再cast消失让玩家进程终止，最后在player_server:terminate中，再向player_mgr和cluster注销自己。那么存在这样一种情况：player_mgr LRU剔除玩家进程Pid0到 player_server:terminate从cluster中注销自己之间，新的login或get_fork请求到来，此时player_mgr再启动了Pid1，并且rewrite player process，那么当Pid0 terminate时，检查到cluster中当前服务不是自己，不会更新cluster，之后，Pid0还会向player_mgr注销自己，并且没有带上Pid进行Pid检查，因此将Pid1从player_mgr中删除了！至此，player_mgr和cluster出现了不一致，cluster中存在Pid1程，而player_mgr中没有。下一次玩家login或get_fork一个新的Pid2时，Pid1被rewrite，Pid1也就成了第三方进程</li><li>上面的概率看起来很小，但由于公会等组逻辑，可能导致N个玩家同时被get_fork起来，而LRU又是player_mgr统一定期(10分钟)清理的，因此如果alliance前后10分钟get_fork两次，问题出现的概率就被放大了，这也是本次出问题的玩家基本都在一个公会的原因</li></ol><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ol><li>player_mgr在没有确认玩家进程已经退出时(此时可能还有一堆消息没处理完)，就删除了它</li><li>玩家进程在向player_mgr注销自己时，没有做Pid检查，注销了其它进程(没有考虑容错)</li></ol><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>线上热更的方案：</p><ol><li>player_mgr和cluster均在player terminate时才确认注销</li><li>服务注销时做Pid检查</li><li>在玩家进程定期存盘时检查其cluster和player_mgr状态，并stop掉第三方进程</li></ol><h3 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h3><p> 本质上来说，这次的问题源于：</p><ol><li>数据冗余导致短暂的不一致状态(player_mgr和cluster不一致)</li><li>在这种不一致状态下的特定事件(player login/get_fork)，导致不一致的影响被放大(存在第三方玩家进程)</li><li>对这种不一致状态缺乏检查和处理，导致BUG(玩家回档)</li></ol><p>在Code Review的过程中，还发现一些其它并发和异步问题。在多Actor异步交互模型中，调度时序，网络时延都可能导致状态不一致。在分布式系统中，想要从根本上杜绝不一致，是几乎不可能的(我们对同步和事务非常敏感)，因此我们不只是要从问题预防上考虑，还要从错误恢复上着手，让系统具备一定程度的”自愈能力”：</p><p>预防：减少不一致的可能性</p><ol><li>减少数据冗余，将cluster作为数据的第一参照，player_mgr的优先级降低，并只用于全服逻辑</li><li>简化player_mgr的功能，如将离线玩家的LRU移到player自身去管理</li></ol><p>恢复：检查并修复不一致</p><ol><li>在服务启动/运行/终止时，加上检查和修复机制，并记录日志</li><li>跑定时脚本检查player_mgr和cluster的一致性，并予以临时修复和报警</li></ol><p>最后，总结出的经验是，在分布式系统中，对问题的检查和修复，和问题的预防同样重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;有十几个玩家报告被回档，几小时到一两天不等&lt;/p&gt;
&lt;h3 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h3&gt;&lt;p&gt;在我们的&lt;a href=&quot;http://wudaijun.com/2016/01/erlang-server-design5-server-node/&quot;&gt;集群架构&lt;/a&gt;中，集群有若干GS节点，每个GS节点可部署N个GS服务器，整个集群所有的玩家进程注册于cluster，我们通过为每个服开一个player_mgr来维护单服玩家状态，player_mgr维护{player_id, agent_pid, player_pid}三元组，用户处理多点登录，单服逻辑，离线玩家LRU等。cluster本身只提供服务注册/注销，如果做服务替换(如agent)，确保服务的唯一性(如player)应该由外部逻辑来确保，cluster并不知晓内部各种服务的特性。player进程启动/终止时，会向player_mgr和cluster分别注册/注销自己。&lt;/p&gt;
    
    </summary>
    
      <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
      <category term="distribution" scheme="http://wudaijun.com/tags/distribution/"/>
    
  </entry>
  
  <entry>
    <title>goa - go web框架</title>
    <link href="http://wudaijun.com/2016/09/goa-intro/"/>
    <id>http://wudaijun.com/2016/09/goa-intro/</id>
    <published>2016-09-19T16:00:00.000Z</published>
    <updated>2016-09-20T14:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h3><p><a href="https://github.com/goadesign/goa" target="_blank" rel="external">goa</a>是基于微服务的go语言框架，能够有效帮助开发人员快速开发基于微服务的系统。它通过DSL和代码生成器来生成样板代码和辅助套件(如文档，客户端模块，客户端工具等)。这些生成数据均基于服务的设计描述，goa遵循<strong>单一数据源</strong>(Single Source of Truth, SSOT)原则，任何对设计的改变，都将自动反映到系统各处，</p><p>goa可以分为三个部分：</p><ul><li>goa的设计语言是内置DSL，用于描述微服务的设计</li><li>goa代码生成器，用于根据DSL描述生成代码模块，辅助工具，和文档等</li><li>goa利用生成代码和用户代码来实现一个服务，并提供一个完全可插拨的框架</li></ul><a id="more"></a><p>goa的特点：</p><ul><li>重视框架设计(Design-Based)，将框架，文档，胶水代码和辅助工具作为一个整体来设计和描述</li><li>为用户生成了大量的代码(框架代码，胶水代码，测试代码，客户端工具等等)，上手快速</li><li>DSL，代码生成器，用户代码均使用Go语言编写，并且前两者使用plugin实现，可以替换</li><li>基于微服务，对<a href="http://www.infoq.com/cn/articles/rest-introduction#anch82429" target="_blank" rel="external">RESTful</a> API有非常好的支持，方便构建更高效，易于扩展的HTTP服务器</li></ul><h3 id="二-使用"><a href="#二-使用" class="headerlink" title="二. 使用"></a>二. 使用</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><pre><code>// 获取goago get github.com/goadesign/goago get github.com/goadesign/goa/goagen// 安装goagengo install github.com/goadesign/goa/goagen</code></pre><h4 id="2-DSL-服务设计"><a href="#2-DSL-服务设计" class="headerlink" title="2. DSL 服务设计"></a>2. DSL 服务设计</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> design                         <span class="comment">// The convention consists of naming the design</span></div><div class="line">                                                   <span class="comment">// package "design"</span></div><div class="line"><span class="keyword">import</span> (</div><div class="line">        . <span class="string">"github.com/goadesign/goa/design"</span>        <span class="comment">// Use . imports to enable the DSL</span></div><div class="line">        . <span class="string">"github.com/goadesign/goa/design/apidsl"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = API(<span class="string">"cellar"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                     <span class="comment">// API defines the microservice endpoint and</span></div><div class="line">        Title(<span class="string">"The virtual wine cellar"</span>)           <span class="comment">// other global properties. There should be one</span></div><div class="line">        Description(<span class="string">"A simple goa service"</span>)        <span class="comment">// and exactly one API definition appearing in</span></div><div class="line">        Scheme(<span class="string">"http"</span>)                             <span class="comment">// the design.</span></div><div class="line">        Host(<span class="string">"localhost:8080"</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = Resource(<span class="string">"bottle"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                <span class="comment">// Resources group related API endpoints</span></div><div class="line">        BasePath(<span class="string">"/bottles"</span>)                       <span class="comment">// together. They map to REST resources for REST</span></div><div class="line">        DefaultMedia(BottleMedia)                  <span class="comment">// services.</span></div><div class="line"></div><div class="line">        Action(<span class="string">"show"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                    <span class="comment">// Actions define a single API endpoint together</span></div><div class="line">                Description(<span class="string">"Get bottle by id"</span>)    <span class="comment">// with its path, parameters (both path</span></div><div class="line">                Routing(GET(<span class="string">"/:bottleID"</span>))         <span class="comment">// parameters and querystring values) and payload</span></div><div class="line">                Params(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                    <span class="comment">// (shape of the request body).</span></div><div class="line">                        Param(<span class="string">"bottleID"</span>, Integer, <span class="string">"Bottle ID"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">                                Minimum(<span class="number">0</span>) <span class="comment">// Do not allow for negative values.</span></div><div class="line">                        &#125;)</div><div class="line">                &#125;)</div><div class="line">                Response(OK)                       <span class="comment">// Responses define the shape and status code</span></div><div class="line">                Response(NotFound)                 <span class="comment">// of HTTP responses.</span></div><div class="line">        &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// BottleMedia defines the media type used to render bottles.</span></div><div class="line"><span class="keyword">var</span> BottleMedia = MediaType(<span class="string">"application/vnd.goa.example.bottle+json"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        Description(<span class="string">"A bottle of wine"</span>)</div><div class="line">        Attributes(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                         <span class="comment">// Attributes define the media type shape.</span></div><div class="line">                Attribute(<span class="string">"id"</span>, Integer, <span class="string">"Unique bottle ID"</span>)</div><div class="line">                Attribute(<span class="string">"href"</span>, String, <span class="string">"API href for making requests on the bottle"</span>)</div><div class="line">                Attribute(<span class="string">"name"</span>, String, <span class="string">"Name of wine"</span>)</div><div class="line">                Required(<span class="string">"id"</span>, <span class="string">"href"</span>, <span class="string">"name"</span>)</div><div class="line">        &#125;)</div><div class="line">        View(<span class="string">"default"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                    <span class="comment">// View defines a rendering of the media type.</span></div><div class="line">                Attribute(<span class="string">"id"</span>)                     <span class="comment">// Media types may have multiple views and must</span></div><div class="line">                Attribute(<span class="string">"href"</span>)                   <span class="comment">// have a "default" view.</span></div><div class="line">                Attribute(<span class="string">"name"</span>)</div><div class="line">        &#125;)</div><div class="line">&#125;)</div><div class="line"></div></pre></td></tr></table></figure>    <p>上面的DSL主要用到的接口：</p><ul><li>API: 描述一个Service及其地址，协议规范等</li><li>Resource: 定义一个资源及其一系列相关的操作(Action)，以及这些操作所共用的一些属性</li><li>Action: 定义针对于某个资源的操作，包括方法(GET,POST等)，URL(可有多个)，参数(goa自动做类型检查，值检查等)等</li><li>Response: 定义一个响应，包括响应模板和承载内容(payload)，在代码中决定调用那个响应模板</li><li>MediaType: 定义Response返回的数据结构，一个Media可以有多个View，可在Response中指定返回的View</li></ul><p>goa本身DSL设计是<a href="http://www.infoq.com/cn/articles/rest-introduction#anch82429" target="_blank" rel="external">RESTful</a>的，通过Go的匿名函数，提供了非常强大的描述能力，如参数定义，参数检查，传输媒体，响应模板等。goa基于服务提供功能，每个API定义一个服务(Service)，每个服务有若干资源(Resource)，每个资源对应若干操作(Action)，每个操作(Action)有多种响应(Response)，每个响应可能返回不同媒介(Media)的不同视图(View)。当然goa提供了更好的层级控制和继承关系(如上例，Response返回的视图继承于Resource中定义的默认媒介(BottleMedia)的默认视图(default))。更详细的DSL设计文档参考<a href="https://goa.design/design/overview/" target="_blank" rel="external">goa dsl design</a>和<a href="https://goa.design/reference/goa/design/apidsl" target="_blank" rel="external">goa dsl api</a>。</p><h4 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3. 生成代码"></a>3. 生成代码</h4><p>通过goa根据单个DSL文件，即可生成一整套框架代码：</p><pre><code>cd src/cellargoagen bootstrap -d cellar/design</code></pre><p>goa会生成一堆代码，主要包括四个目录两个文件：</p><ul><li>app目录: 根据DSL，生成若干类，并将底层的HTTP服务器和DSL中的资源，路由结合起来</li><li>client目录:  配套的client包，包含对媒介类型的定义，和对请求响应的编解码</li><li>tool目录：根据client包生成的控制台工具，用于模拟客户端发送请求</li><li>swagger目录：包含对整个服务(API)的总体描述(Json和Yaml格式)</li><li>main.go文件：主文件，挂载资源路由(BottleController)，启动服务</li><li>bottle.go文件：bottle资源的逻辑处理，即BottleController的Action实现</li></ul><p>当改变DSL文件并再次用goagen生成代码时，goagen只会重新生成框架代码(app,client,tool,swagger)，而不会覆盖逻辑代码(main.go和bottle.go以及其它自定义文件)，做到框架与逻辑分离。</p><p>得到这些文件之后，我们直接编辑bottle.go，完善bottle资源的Action逻辑即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Show runs the show action.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *BottleController)</span> <span class="title">Show</span><span class="params">(ctx *app.ShowBottleContext)</span> <span class="title">error</span></span> &#123;</div><div class="line"><span class="comment">// BottleController_Show: start_implement</span></div><div class="line"></div><div class="line"><span class="comment">// Put your logic here</span></div><div class="line">    <span class="keyword">if</span> ctx.BottleID == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> ctx.NotFound()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bottle := app.GoaExampleBottle&#123;</div><div class="line">        ID : ctx.BottleID,</div><div class="line">        Name : fmt.Sprintf(<span class="string">"Bottle #%d"</span>, ctx.BottleID),</div><div class="line">        Href : app.BottleHref(ctx.BottleID),</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// BottleController_Show: end_implement</span></div><div class="line"><span class="keyword">return</span> ctx.OK(&amp;bottle)</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><p>至此，服务器就已经设计好了，剩下的HTTP Server，消息编解码，参数检查，路由，响应模板，甚至测试工具，gagen都已经为你做好了。</p><h4 id="4-运行和测试"><a href="#4-运行和测试" class="headerlink" title="4. 运行和测试"></a>4. 运行和测试</h4><p>运行服务器：</p><pre><code>cd src/cellargo build -o cellar./cellar2016/09/20 00:26:41 [INFO] mount ctrl=Bottle action=Show route=GET /bottles/:bottleID2016/09/20 00:26:41 [INFO] listen transport=http addr=:8080</code></pre><p>通过curl测试：</p><pre><code># 404 NOT FOUNDcurl -i localhost:8080/bottles/0# 200 一个有效的BottleMedia Viewcurl -i localhost:8080/bottles/1# 400 无效参数 得到参数检查错误提示curl -i localhost:8080/bottles/n</code></pre><p>通过celler-cli工具测试：</p><pre><code>cd src/cellar/tool/cellar-cligo build -o cellar-cli# 使用帮助./cellar-cli # show bottle 命令的用法./cellar-cli show bottle# 发送HTTP请求 cellar-cli中集成了服务的地址信息./cellar-cli show bottle /bottles/1</code></pre><p>最终我们只写了几十行的DSL和几行逻辑代码，就得到了一个基于微服务，RESTful风格的HTTP服务器，附以完整的客户端代码，测试工具，甚至服务API描述。更关键的是，这一套环境是SSOT(Single Source of Truth)的，更改一份DSL服务描述文件，整个服务器底层代码，胶水代码，测试环境，甚至API描述都会重新生成(不会影响到已有的逻辑代码)，这让整个服务保持高度一致性和可控性。</p><p>最后，以一段<a href="https://github.com/goadesign/goa" target="_blank" rel="external">goa github</a>上的描述收尾：</p><blockquote><blockquote><p>There are a number of good Go packages for writing modular web services out there so why build another one? Glad you asked! The existing packages tend to focus on providing small and highly modular frameworks that are purposefully narrowly focused. The intent is to keep things simple and to avoid mixing concerns.</p><p>This is great when writing simple APIs that tend to change rarely. However there are a number of problems that any non trivial API implementation must address. Things like request validation, response media type definitions or documentation are hard to do in a way that stays consistent and flexible as the API surface evolves.</p><p>goa takes a different approach to building these applications: instead of focusing solely on helping with implementation, goa makes it possible to describe the design of an API in an holistic way. goa then uses that description to provide specialized helper code to the implementation and to generate documentation, API clients, tests, even custom artifacts.</p></blockquote></blockquote><p>完整示例参考<a href="https://goa.design/learn/guide/" target="_blank" rel="external">goa learn guide</a>和<a href="https://github.com/goadesign/goa" target="_blank" rel="external">goa github</a>。</p><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>goa的优点：</p><ul><li>先进的理念：Design-Based, DSL, Micro-Service, RESTful API，Plugins等</li><li>DSL，代码生成器，用户代码，辅助工具等一整套环境都用Go实现</li><li>一份服务设计(DSL文件)，生成了包括框架代码，辅助(胶水)代码，测试代码，客户端工具等一整套环境(SSOT)</li><li>上手简单，功能强大</li><li>文档齐全，社区活跃度高</li></ul><p>后续会继续关注这个框架，尽快拿到实践中用用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一. 简介&quot;&gt;&lt;/a&gt;一. 简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/goadesign/goa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;goa&lt;/a&gt;是基于微服务的go语言框架，能够有效帮助开发人员快速开发基于微服务的系统。它通过DSL和代码生成器来生成样板代码和辅助套件(如文档，客户端模块，客户端工具等)。这些生成数据均基于服务的设计描述，goa遵循&lt;strong&gt;单一数据源&lt;/strong&gt;(Single Source of Truth, SSOT)原则，任何对设计的改变，都将自动反映到系统各处，&lt;/p&gt;
&lt;p&gt;goa可以分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;goa的设计语言是内置DSL，用于描述微服务的设计&lt;/li&gt;
&lt;li&gt;goa代码生成器，用于根据DSL描述生成代码模块，辅助工具，和文档等&lt;/li&gt;
&lt;li&gt;goa利用生成代码和用户代码来实现一个服务，并提供一个完全可插拨的框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
      <category term="goa" scheme="http://wudaijun.com/tags/goa/"/>
    
  </entry>
  
  <entry>
    <title>Rebar3 Erlang/OTP构建利器</title>
    <link href="http://wudaijun.com/2016/09/erlang-rebar3/"/>
    <id>http://wudaijun.com/2016/09/erlang-rebar3/</id>
    <published>2016-09-09T16:00:00.000Z</published>
    <updated>2016-09-09T18:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-依赖管理"><a href="#一-依赖管理" class="headerlink" title="一. 依赖管理"></a>一. 依赖管理</h3><h4 id="1-包依赖和源码依赖"><a href="#1-包依赖和源码依赖" class="headerlink" title="1. 包依赖和源码依赖"></a>1. 包依赖和源码依赖</h4><p>Rebar3支持两种依赖：</p><pre><code>{deps,[  %% 包依赖  rebar,  {rebar,&quot;1.0.0&quot;},  {rebar, {pkg, rebar_fork}}, % rebar app under a different pkg name  {rebar, &quot;1.0.0&quot;, {pkg, rebar_fork}},  %% 源码依赖  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;}},  {rebar, {git, &quot;http://github.com/erlang/rebar3.git&quot;}},  {rebar, {git, &quot;https://github.com/erlang/rebar3.git&quot;}},  {rebar, {git, &quot;git@github.com:erlang/rebar3.git&quot;}},  {rebar, {hg, &quot;https://othersite.com/erlang/rebar3&quot;}},  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;, {ref, &quot;aef728&quot;}}},  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;, {branch, &quot;master&quot;}}},  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;, {tag, &quot;3.0.0&quot;}}}  ]}</code></pre><a id="more"></a><p>Rebar3通过<a href="https://hex.pm" target="_blank" rel="external">hex.pm</a>来管理包依赖，在使用之前，需要通过<code>rebar3 update</code>从hex.pm更新包索引，并将包索引信息缓存到本地(<code>~/.cache/rebar3/</code>)。之后Rebar3便能正确解析包依赖，对应用程序使用上来说，两者没有明显区别。</p><h4 id="2-升级依赖"><a href="#2-升级依赖" class="headerlink" title="2. 升级依赖"></a>2. 升级依赖</h4><p>在使用Rebar2的时候，如果项目依赖一个指向分支的dep，就会出现这种情况：</p><ul><li>这个dep有远程分支更新时，rebar get-deps不会自动拉取更新，通常你只能进入dep目录执行<code>git pull</code>，或者删除该dep重新执行rebar get-deps。</li><li>项目成员各自的工作目录deps版本可能不一致，并且一些很久没更新的依赖可能在你部署新环境时(此时所有依赖都指向最新)出现问题。</li></ul><p>所以在Rebar2的reabr.config中定义deps，都应该尽量使用tag, commitid来指定，而不是直接指向分支。那么Rebar3是如何解决这个问题的呢？</p><p>Rebar3解决此问题的核心在rebar.lock文件，该文件内容如下：</p><pre><code>{&quot;1.1.0&quot;,[{&lt;&lt;&quot;goldrush&quot;&gt;&gt;,{pkg,&lt;&lt;&quot;goldrush&quot;&gt;&gt;,&lt;&lt;&quot;0.1.8&quot;&gt;&gt;},1}, {&lt;&lt;&quot;lager&quot;&gt;&gt;,{pkg,&lt;&lt;&quot;lager&quot;&gt;&gt;,&lt;&lt;&quot;3.2.1&quot;&gt;&gt;},0}]}.[{pkg_hash,[ {&lt;&lt;&quot;goldrush&quot;&gt;&gt;, &lt;&lt;&quot;2024BA375CEEA47E27EA70E14D2C483B2D8610101B4E852EF7F89163CDB6E649&quot;&gt;&gt;}, {&lt;&lt;&quot;lager&quot;&gt;&gt;, &lt;&lt;&quot;EEF4E18B39E4195D37606D9088EA05BF1B745986CF8EC84F01D332456FE88D17&quot;&gt;&gt;}]}].</code></pre><p>该文件是项目当前使用依赖库的一个版本快照。当一个依赖被获取和锁定，Rebar3将从依赖中提取版本信息并写入rebar.lock文件中，该文件应该加入GIt仓库，并且由专人维护，这样只要rebar.lock一致，各本地仓库的依赖库版本就是一致的。</p><p>依赖升级分为两种，一种是直接通过<code>rebar upgrade [dep]</code>进行源码更新或包更新(只能更新Top Level依赖)。另一种是rebar.config发生变动，比如去除了某个依赖，此时需要<code>rebar unlock [dep]</code>命令来清理rebar.lock文件。</p><p>相关命令：</p><pre><code>rebar3 update  // 更新包索引rebar3 pkgs // 列出所有可用的包rebar3 deps  // 列出所有一级(Top Level)依赖rebar3 tree  // 以树形结构查看依赖rebar3 compile // 获取并编译依赖rebar3 upgrade [dep] // 升级依赖rebar3 lock [dep] // 锁定依赖rebar3 unlock [dep] // 解锁依赖</code></pre><h3 id="二-构建"><a href="#二-构建" class="headerlink" title="二. 构建"></a>二. 构建</h3><pre><code>rebar3 new app [appname]rebar3 new lib [libname]</code></pre><p>Rebar3建议应用程序按照OTP规范目录进行组织：</p><pre><code>├── LICENSE├── README.md├── apps│   └── myapp│       └── src│           ├── myapp.app.src│           ├── myapp_app.erl│           └── myapp_sup.erl├── config│   ├── sys.config│   └── vm.args├── lib│   └── mylib│       ├── LICENSE│       ├── README.md│       ├── rebar.config│       └── src│           ├── mylib.app.src│           └── mylib.erl└── rebar.config</code></pre><p>这样无需在rebar.config中指定sub_dirs，Rebar3会自动将lib和apps作为搜索路径。</p><p>Rebar3没有get-deps命令，通过<code>rebar3 compile</code>即可编译项目，并自动获取和编译不存在的依赖，Rebar3将所有编译文件和Release信息都置于<code>_build</code>目录下。默认apps，deps和lib下的应用都被编译到<code>_build/default/lib</code>中。要指定应用目录和输出目录等选项，请参考：<a href="http://www.rebar3.org/docs/configuration" target="_blank" rel="external">Rebar3配置</a>。</p><h3 id="三-发布"><a href="#三-发布" class="headerlink" title="三. 发布"></a>三. 发布</h3><h4 id="1-发布环境"><a href="#1-发布环境" class="headerlink" title="1. 发布环境"></a>1. 发布环境</h4><p>Rebar3放弃了<a href="http://erlang.org/doc/man/reltool.html" target="_blank" rel="external">reltool</a>而使用<a href="https://github.com/erlware/relx" target="_blank" rel="external">relx</a>作为发布工具。并且将relx.config内容集成到rebar.config当中，通过<code>rebar new release [appname]</code>可创建一个发布，rebar.config内容如下：</p><pre><code>{erl_opts, [debug_info]}.{deps, []}.%% 定义默认发布环境(default环境){relx, [{release, { myapp, &quot;0.1.0&quot; },         [myapp,          sasl]},        {sys_config, &quot;./config/sys.config&quot;},        {vm_args, &quot;./config/vm.args&quot;},    %% 当dev_mode==true时 _build/default/rel/myapp/lib/目录下的库其实是_build/default/lib目录下对应lib的软链接，这样重新编译后，无需重新发布，重启或热加载代码即可        {dev_mode, true},        %% 是否在发布目录中包含虚拟机 即为一个独立的运行环境        {include_erts, false},        {extended_start_script, true}]}.%% 定义其它发布环境%% 参数使用覆盖(override)机制，即这里面没有定义的参数，将使用默认发布环境(default)配置{profiles, [{prod, [{relx, [{dev_mode, false},                            {include_erts, true}]}]            }]}</code></pre><p>Rebar3中有发布环境(profiles)的概念，如开发环境(default)，生产环境(prod)，它们可以独立定义编译参数(erl_opts)，发布参数(dev_mode, include_erts)，甚至依赖应用(deps)。目前Rebar3支持四种环境定义：</p><ul><li>default：默认环境，也就是rebar.config中最外部定义的环境</li><li>prod：生产环境，通常在此环境下将使用库的完整发布包(而不是软链接)，有更严格的编译选项，并且可能还要包含Erlang运行时所需要的所有环境</li><li>native：原生环境，强制使用<a href="http://erlang.org/doc/man/HiPE_app.html" target="_blank" rel="external">HiPE</a>编译，从而得到更快的编译速度</li><li>test：测试环境，将加载一些额外的库(如<a href="https://github.com/eproxus/meck" target="_blank" rel="external">meck</a>)，打开调试信息，用于跑测试代码</li></ul><p>不同发布环境将发布在不同的目录下，如prod环境默认将生成在<code>_build/prod/</code>下，无论顶层应用采用何种发布环境，依赖将始终只能使用prod环境发布。并且只有顶层依赖的default环境，可以被保存到rebar.lock中。</p><p><code>rebar3 release</code>将按照default环境发布应用，通过<code>rebar3 as prod release</code>可以将应用在生产环境发布。具体环境配置及命令参考<a href="http://www.rebar3.org/docs/profiles" target="_blank" rel="external">Rebar3环境</a>。</p><h4 id="2-发布多个应用"><a href="#2-发布多个应用" class="headerlink" title="2. 发布多个应用"></a>2. 发布多个应用</h4><p>Rebar3支持在rebar.config中定义多个应用的发布，多个应用可以共享配置：</p><pre><code>{relx, [{release, {myapp1, &quot;0.0.1&quot;},     [myapp1]},    {release, {myapp2, &quot;0.1.0&quot;},     [myapp2]},     % 共用配置{sys_config, &quot;config/sys.config&quot;},{vm_args, &quot;config/vm.args&quot;},    {dev_mode, true},    {include_erts, false},    {extended_start_script, true}]}.</code></pre><p>也可以独立配置：</p><pre><code>{relx, [    {release, {myapp1, &quot;0.0.1&quot;},             [myapp1],             % 注意配置顺序和格式 各应用的独立配置是一个PropList             [{sys_config, &quot;config/sys1.config&quot;},        {vm_args, &quot;config/vm1.args&quot;}]    },        {release, {myapp2, &quot;0.1.0&quot;},             [myapp2],             [{sys_config, &quot;config/sys1.config&quot;},        {vm_args, &quot;config/vm1.args&quot;},        {overlay}]    },        {dev_mode, true},    {include_erts, false},    {extended_start_script, true}]}.</code></pre><h4 id="3-应用依赖"><a href="#3-应用依赖" class="headerlink" title="3. 应用依赖"></a>3. 应用依赖</h4><p>定义于rebar.config deps中的依赖被获取后放在<code>_build/default/lib</code>目录下，默认并不会打包到应用的发布目录<code>_build/default/rel/myapp/lib</code>中，你需要在relbar.config的relx中指定应用依赖：</p><pre><code>{relx, [{release, { myapp, &quot;0.1.0&quot; },         [         % 指定应用依赖 mylib会先于myapp被启动         mylib,          myapp]         },        {sys_config, &quot;./config/sys.config&quot;},        {vm_args, &quot;./config/vm.args&quot;},        {dev_mode, true},        {include_erts, false},        {extended_start_script, true}]}.</code></pre><p>那么对于一些辅助lib呢，我们希望它被打包在应用发布目录中，但不希望它们被启动(它们可能根本不能启动)，一种方法是将mylib指定为<code>{mylib, load}</code>(参见<a href="https://github.com/erlware/relx/issues/483" target="_blank" rel="external">Issue1</a>, <a href="https://github.com/erlware/relx/issues/149" target="_blank" rel="external">Issue2</a>)，列表中的依赖项默认被relx解释为<code>{mylib, permanent}</code>，即以常驻的方式启动应用。</p><h4 id="4-Overlays"><a href="#4-Overlays" class="headerlink" title="4. Overlays"></a>4. Overlays</h4><p>Overlay允许用户定义一些文件模板和部署准备工作，如拷贝文件，创建文件夹等：</p><pre><code>{relx, [    {overlay_vars, &quot;vars.config&quot;},    {overlay, [{mkdir, &quot;log/sasl&quot;},               {template, &quot;priv/app.config&quot;, &quot;etc/app.config&quot;}，               % root_dir是relx提供的变量 代表项目根目录               {copy, &quot;\{\{root_dir\}\}/configures&quot;, &quot;./&quot;}]}]}.</code></pre><p>Overlay可以如sys_config和vm_config一样，放在各应用的独立发布配置中。</p><p>更多关于Rebar3发布流程，发布配置，以及库升级等，参考<a href="http://www.rebar3.org/v3/docs/releases" target="_blank" rel="external">Rebar3发布</a>。</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h3><p>Rebar3无疑是个好东西，更先进的依赖管理，多节点发布，发布环境的概念，都是Rebar2 + Reltool所不能实现的，当前我们项目就使用的Rebar2.x，用于部署一个多节点的集群，遇到的问题：</p><ul><li>依赖管理：各本地版本不一致问题，Rebar3的lock为依赖的一致性提供了保证。</li><li>多节点部署：Rebar2.x需要为每个节点创建release(create-node)，需要维护N份reltool.config和一份rebar.config。在Rebar3中只需一个rebar.config文件。并且可以灵活定义各节点配置文件(vm.args, sys.config)路径，更有利于项目结构管理和可读性。</li><li>开发模式：在本地开发时，Rebar2.x的generate和upgrade太慢了，前者可用二进制发布自己写脚本替代(用erl_call和节点通信)，后者可用reloader实现热更，这样提高了部署速度，却要自己维护节点交互脚本。Rebar3的dev_mode完美解决了这个问题。</li><li>环境管理：这一块的用处还有待挖掘和摸索。</li></ul><p>Rebar3目前主要的缺点，在于relx文档匮乏，提供了很多好东西，但能传达到用户让用户理解和用上的很少。翻遍了<a href="https://github.com/erlware/relx/wiki" target="_blank" rel="external">relx wiki</a>，也没有找到应用独立配置环境(sys_config, vm_args等)的方法，最后是看了其配置解析模块<a href="hub.com/erlware/relx/blob/master/src/rlx_config.erl">rlx_config.erl</a>才猜出来的格式= =。</p><h3 id="五-参考："><a href="#五-参考：" class="headerlink" title="五. 参考："></a>五. 参考：</h3><ol><li><a href="http://www.rebar3.org/docs/getting-started" target="_blank" rel="external">Rebar3文档</a></li><li><a href="https://github.com/zyuyou/rebar3_docs" target="_blank" rel="external">Rebar3文档中文翻译(部分)</a></li><li><a href="https://github.com/erlware/relx/wiki" target="_blank" rel="external">relx wiki</a></li><li><a href="http://erlang.org/doc/design_principles/release_structure.html" target="_blank" rel="external">OTP Release 结构</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-依赖管理&quot;&gt;&lt;a href=&quot;#一-依赖管理&quot; class=&quot;headerlink&quot; title=&quot;一. 依赖管理&quot;&gt;&lt;/a&gt;一. 依赖管理&lt;/h3&gt;&lt;h4 id=&quot;1-包依赖和源码依赖&quot;&gt;&lt;a href=&quot;#1-包依赖和源码依赖&quot; class=&quot;headerlink&quot; title=&quot;1. 包依赖和源码依赖&quot;&gt;&lt;/a&gt;1. 包依赖和源码依赖&lt;/h4&gt;&lt;p&gt;Rebar3支持两种依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{deps,[
  %% 包依赖
  rebar,
  {rebar,&amp;quot;1.0.0&amp;quot;},
  {rebar, {pkg, rebar_fork}}, % rebar app under a different pkg name
  {rebar, &amp;quot;1.0.0&amp;quot;, {pkg, rebar_fork}},
  %% 源码依赖
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;}},
  {rebar, {git, &amp;quot;http://github.com/erlang/rebar3.git&amp;quot;}},
  {rebar, {git, &amp;quot;https://github.com/erlang/rebar3.git&amp;quot;}},
  {rebar, {git, &amp;quot;git@github.com:erlang/rebar3.git&amp;quot;}},
  {rebar, {hg, &amp;quot;https://othersite.com/erlang/rebar3&amp;quot;}},
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;, {ref, &amp;quot;aef728&amp;quot;}}},
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;, {branch, &amp;quot;master&amp;quot;}}},
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;, {tag, &amp;quot;3.0.0&amp;quot;}}}
  ]}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
</feed>
