<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wudaijun&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/eb575f4256a9fe4728b794090470955c</icon>
  <subtitle>Coding is Funny</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wudaijun.com/"/>
  <updated>2017-11-21T13:47:10.000Z</updated>
  <id>http://wudaijun.com/</id>
  
  <author>
    <name>wudaijun</name>
    <email>wdjlost@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker 网络模式</title>
    <link href="http://wudaijun.com/2017/11/docker-network/"/>
    <id>http://wudaijun.com/2017/11/docker-network/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-11-21T13:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>以Docker为平台部署服务器时，最应该理解透彻的便是网络配置。离上次学习，Docker网络又更新了不少内容，重新温习一下。</p><p>通过<code>docker run</code>的<code>--network</code>选项可配置容器的网络模式，Docker提供了多种网络工作模式，通过<code>docker network ls</code>可查看默认提供的三种网络模式: none, host, bridge</p><h3 id="none-模式"><a href="#none-模式" class="headerlink" title="none 模式"></a>none 模式</h3><p>不为Docker容器进行任何网络配置，容器将不能访问任何外部的路由(容器内部仍然有loopback接口)，需要手动为其配置网卡，指定IP等，否则与外部只能通过文件IO和标准输入输出交互，或通过<code>docker attach 容器ID</code>进入容器。</p><h3 id="host-模式"><a href="#host-模式" class="headerlink" title="host 模式"></a>host 模式</h3><p>与宿主机共用网络栈，IP和端口，容器本身看起来就像是个普通的进程，它暴露的端口可直接通过宿主机访问。相比于bridge模式，host模式有显著的性能优势(因为走的是宿主机的网络栈，而不是docker deamon为容器虚拟的网络栈)。</p><h3 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h3><p>默认网络模式，此模式下，容器有自己的独立的Network Namespace。简单来说，Docker在宿主机上虚拟了一个子网络，宿主机上所有容器均在这个子网络中获取IP，这个子网通过网桥挂在宿主机网络上。Docker通过NAT技术确保容器可与宿主机外部网络交互。</p><p><img src="/assets/image/tool/docker-bridge.png" alt=""></p><p>Docker服务默认会创建一个docker0网桥，并为网桥指定IP和子网掩码(通常为172.17.0.1/16)。当启动bridge模式的容器时，Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备。veth pair技术保证无论哪一个veth收到报文，都将转发给另一方。veth pair的一端默认挂在docker0网桥上，另一端添加到容器的namespace下，并重命名为eth0，保证容器独享eth0，做到网络隔离。连接在同一个Docker网桥上的容器可以通过IP相互访问。如此实现了宿主机到容器，容器与容器之间的联通性。</p><p>关于网桥:</p><ul><li><p>网桥(Bridges):<br>  工作在数据链路层，连接多个端口，负责转发数据帧。网桥知道它的各个端口的数据链路协议(目前几乎都是以太网)，将来自一个端口的数据帧转发到其它所有端口。有多个端口的网桥又叫做交换机，目前这两个概念没有本质区别。</p><p>  网桥可以用来连接不同的局域网(LAN)，按照最简单的方法，网桥会将某个端口收到的数据无脑转发给其它所有端口，这种泛洪(Flooding)算法效率过低，网桥依靠转发表来转发数据帧，通过自学习算法，记录各个Mac地址在对应哪个端口(转发表数据库)，辅之超时遗忘(Aging)和无环拓扑算法(Loop-Free Topology，典型地如Spanning Tree Protocol, STP)。</p></li><li><p>Linux网桥:</p><p>  Linux下网桥是一个虚拟设备，你可以通过命令创建它，并且为其挂载设备(物理或虚拟网卡)。可通过<code>brctl</code>命令来创建和Linux网桥。管理Linux bridge的具体用法参考: <a href="https://wiki.linuxfoundation.org/networking/bridge。" target="_blank" rel="external">https://wiki.linuxfoundation.org/networking/bridge。</a></p></li><li><p>Docker网桥:</p><p>  Docker网桥通过Linux网桥实现，加上NAT, veth pair, 网络命名空间等技术，实现网络隔离和容器互联。可通过<code>sudo docker network inspect bridge</code>查看Docker网桥配置以及状态。</p></li></ul><p>当容器需要和宿主机外部网络交互时，会在宿主机上分配一个可用端口，通过这个端口做SNAT转换(将容器IP:Port换为宿主机IP:Port)，再向外部网络发出请求。当外部响应到达时，Docker再根据这一层端口映射关系，将响应路由给容器IP:Port。</p><p>外部网络要访问容器Port0，需要先将Port0与宿主机Port1绑定(外部网络无法直接访问宿主机二级网络)，将宿主机IP:Port1暴露给外部网络，外部网络请求到达宿主机时，会进行DNAT转换(将宿主机IP:Port1换为容器IP:Port0)。</p><p>从实现上来讲，Docker的这种NAT(实际上是NATP，包含IP,Port的转换)规则，是Docker Daemon通过修改ipatables规则来实现的，ubuntu下可通过<code>sudo ipatbles -t nat -L</code>来查看和NAT相关的规则。</p><p>总之，Docker容器在bridge模式下不具有一个公有IP，即和宿主机的eth0不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。虽然NAT模式经过中间处理实现了这一点，但是NAT模式仍然存在问题与不便，如：容器均需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等。另外NAT模式会一定程度的影响网络传输效率。</p><p>默认设置下，Docker允许容器之间的互联，可通过<code>--icc=false</code>关闭容器互联(通过iptables DROP实现)，此时容器间相互访问只能通过<code>--link</code>选项链接容器来实现容器访问。<code>—link</code> 选项实际在链接容器的/etc/hosts中添加了一行被链接容器名和其IP的映射，并且会在被链接容器重启后更新该行(这样即使IP有变动也可以通过容器名正确连接)，此外还会添加一条针对两个容器允许连接的iptables规则。但Docker官方文档说<code>--link</code>已经是遗留的选项，更推荐自定义网络模式。</p><h3 id="自定义模式"><a href="#自定义模式" class="headerlink" title="自定义模式"></a>自定义模式</h3><h4 id="自定义bridge网络"><a href="#自定义bridge网络" class="headerlink" title="自定义bridge网络"></a>自定义bridge网络</h4><p>即创建一个新的bridge网络，它的行为和默认的bridge网络类似，可通过<code>docker network</code>创建一个docker网桥:</p><pre><code># 创建一个Docker网桥 命名为my_bridgedocker network create --driver bridge my_bridge# 查看当前Docker支持的所有网络模式 (会多出一个bridge网络模式，名为my_bridge)docker network ls# 将容器挂在my_bridge网桥上docker run --network=my_bridge -it --rm ubuntu# 查看 my_bridge网桥配置和状态docker network inspect my_bridge# 移除 my_bridge网桥docker network rm my_bridge</code></pre><p>自定义网桥通常用于创建一个小的容器网络，在自定义网桥中，<code>--link</code>选项不被支持。</p><h4 id="自定义overlay网络"><a href="#自定义overlay网络" class="headerlink" title="自定义overlay网络"></a>自定义overlay网络</h4><p>前面提到的网络模式，主要解决同一个主机上容器与容器，容器与主机，容器与外界的连接方案，如果要实现跨主机的容器与容器之间的通信方案，可以:</p><ol><li>端口映射</li><li>将物理网卡挂在Docker网桥上，将容器和宿主机配置在同一网段下，见参考3</li><li>使用<a href="http://docs.openvswitch.org/en/latest/howto/docker/" target="_blank" rel="external">OpenvSwich网桥</a>，如通过配置工具pipework，见参考4</li><li>在Docker1.9之后，可以使用原生解决方案Docker overlay</li></ol><p><img src="/assets/image/tool/docker-overlay.png" alt=""></p><p><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">图片出处</a></p><p>overlay网络可以实现跨主机的容器VLAN，具体使用可以参考<a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a>。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在使用Docker时，要注意平台之间实现的差异性，如[Docker For Mac]的实现和标准Docker规范有区别，Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的(而不是像Linux上那样作为进程运行于宿主机)，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。文档在这一点上并没有充分说明，容易踩坑。参考<a href="https://docs.docker.com/docker-for-mac/networking/" target="_blank" rel="external">Docker文档</a> 和 <a href="https://forums.docker.com/t/should-docker-run-net-host-work/14215" target="_blank" rel="external">这篇帖子</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>bridge模式的详细实现可参考[Docker源码分析(七)：Docker Container网络(上)][]</p><ol><li><a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part7" target="_blank" rel="external">Docker源码分析(七)：Docker Container网络(上)</a></li><li><a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="external">Docker networking</a></li><li><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a></li><li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="external">Docker网络详解及pipework源码解读与实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以Docker为平台部署服务器时，最应该理解透彻的便是网络配置。离上次学习，Docker网络又更新了不少内容，重新温习一下。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;docker run&lt;/code&gt;的&lt;code&gt;--network&lt;/code&gt;选项可配置容器的网络模式，Docker
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>探讨服务端回合制战斗系统</title>
    <link href="http://wudaijun.com/2017/09/ngs-battle/"/>
    <id>http://wudaijun.com/2017/09/ngs-battle/</id>
    <published>2017-09-25T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与大部分回合制游戏一样，需要服务器计算战斗，客户端以战报的方式回放。这里探讨一下服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。</p><h2 id="战斗流程"><a href="#战斗流程" class="headerlink" title="战斗流程"></a>战斗流程</h2><p>战斗地图是一个X*Y的矩阵，每个参与者(Fighter)初始位于其中一个格子上。战斗开始后，按照回合迭代，达到胜负条件或最大回合数则战斗结束。回合内，英雄按照出手顺序先后行动(Action)，英雄的Action包括移动，释放技能和普攻。</p><p>战斗流程是比较简明易懂的，整个战斗系统的难点在于多样的技能实现。每个英雄有N个技能，技能系统可以基于各类事件触发和更新，例如：</p><ul><li>SkillA: 英雄每回合前3次伤害有50%机率使伤害翻倍(最多生效2次)</li><li>SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1，造成伤害降低15%，持续两回合</li><li>SkillC: 英雄受到攻击有60%的几率进行反击(伤害率60%)</li></ul><p>以下我们主要围绕灵活的技能系统为主要需求，讨论如何实现一个稳定，可扩展的战斗系统。</p><h2 id="技能系统"><a href="#技能系统" class="headerlink" title="技能系统"></a>技能系统</h2><p>技能分为主动技能(概率触发)和被动技能(相当于战斗开始立即触发)。技能的效果分为瞬时性和持续性两种，前者即像普通一样立即造成伤害(其实普攻也可以看做技能的一种)，后者指技能效果包含状态性，有自己的生命周期和状态更新，如Dot伤害，无法移动，沉默等，这个状态通常叫做Buff，关于技能和Buff的区别我的理解是，技能是Buff的静态容器，是永久的，Buff是技能触发后的实现效果，是动态的。瞬时伤害的技能也可以通过Buff实现，只不过这个Buff生命周期很短，在造成伤害后就消失了。关于Buff的详细实现我们放到后面，我们先看技能系统本身。</p><p>考虑到技能以后的扩展性和可维护性，对其尽可能做抽象是有必要的，抽象出公共的流程，将可变量配置化，可以提升系统稳定性和扩展性，也方便后期做测试。技能本身包含几个阶段：技能触发(概率触发，战斗开始触发)，目标选取(敌军/友军，一个/多个)，技能作用(造成伤害，挂接Buff)，前两个是可抽离到配置的，通过通用的技能触发器和目标选取脚本得到技能所需要的信息传给技能作用模块，由于技能作用效果的多样性，目前我们没有对技能作用进行抽象，是通过脚本各个实现的。</p><h2 id="BUFF系统"><a href="#BUFF系统" class="headerlink" title="BUFF系统"></a>BUFF系统</h2><p>技能的各种复杂效果都通过BUFF实现，每个Buff都挂于战场某个参与者(Fighter)上，当Fighter阵亡，其上所有的Buff都会被移除(包括Event关联)。BUFF系统是由一个基于战场事件(Event)的回调系统驱动，整个战场在战斗流程中不断抛出各种Event(如回合开始/结束，Fighter普攻/受击/释放技能，伤害结算等)，BUFF注册这些Event并更新自己Owner(Fighter)的状态，来实现灵活强大的技能效果。</p><h3 id="1-BUFF生命周期"><a href="#1-BUFF生命周期" class="headerlink" title="1. BUFF生命周期"></a>1. BUFF生命周期</h3><ul><li>Start(): Buff开始，即Buff生效节点，注册BUFF的生命周期</li><li>Update(): Buff状态更新，更新Buff的状态并更新战场，对于次数性BUFF(如前N次免伤)，可能调用N次Update，复杂的技能也可能有多个Update函数(关心不同的Event)</li><li>Finish(): Buff的正常结束，当BUff结束条件满足(比如Update了N次，或者持续了N回合)调用</li><li>Cancel(): Buff被冲突(中断)时的处理</li></ul><p>以上阐述的是Buff的生命周期，而不是具体实现，在设计Buff时从这四个节点思考，加上事件注册回调机制，基本可以实现绝大部分各式的Buff效果。例如最开始提到的SkillA: 英雄前3次伤害有50%机率使伤害翻倍(最多生效2次)，这是一个持续整场战斗的Buff，它注册两个Update Event:</p><ul><li><code>BEFORE_DAMAGE</code>(英雄攻击伤害结算前): Update1 中判断如果本回合已触发次数小于2并且满足触发条件(50%概率)，则更新自己的状态(计数器+1)，并使<strong>伤害翻倍</strong>。</li><li><code>ROUND_START</code>(每回合开始): Update2 中重置Buff状态(计数器)。</li></ul><p>目前我们所讨论的Buff都是独立的，有自己生命周期的个体，通过Event注册回调与战斗主流程解耦，这看起来很好。但事与愿违，Buff之间是有相互关联的，主要分为两块：Buff属性作用和Buff冲突免疫关系。</p><h3 id="2-BUFF属性作用"><a href="#2-BUFF属性作用" class="headerlink" title="2. BUFF属性作用"></a>2. BUFF属性作用</h3><p>仍然是我们前面的SkillA技能，我们现在来看如何实现伤害翻倍这个Buff，该Buff是SkillA对应的Buff生成的子Buff，它应该被设计为可公用的伤害增加Buff，这个Buff的作用是影响伤害结算流程，按照我们之前的事件注册回调思路，我们可以注册伤害结算这个Event，接收当前算出的伤害，然后*200%并返回新伤害值。如BuffA提升10%伤害，BuffB增加20点真实伤害，BuffC降低20%的伤害，那么最终得到伤害为: <code>(基础伤害*110%+20)*80%</code>，这种方案默认公式计算的顺序与Buff挂载顺序一致，，而正确的伤害值应该为<code>(基础伤害+20)*(1+10%-20%)</code>，如果要处理这种优先级关系，需要遍历所有注册伤害结算Event的Handler，按照类型排序，再依次处理，如果一旦有同类Buff添加或移除，又要重新计算。这样公式与事件管理做到了一起，是不稳定的。</p><p>BuffA,BuffB,BuffC之所以会有复杂的公式计算，在于它们作用于同一属性的不同维度，BuffA,BuffC作用于伤害值的比例增加这一维度，而BuffB作用于伤害值的绝对值增长这一维度，我们可以将它们分开，作为Fighter两个独虚拟属性ATTR_DAMAGE_ADD, ATTR_DAMAGE_MUL来维护，允许Buff对其修改，但此时的修改是只有加减关系的，避免了优先级的问题，在伤害结算时，通过公式计算: (基础伤害+ATTR_DMAGE_ADD)*ATTR_DAMAGE_MUL即可。</p><p>整个作用链为: </p><ul><li>战斗流程抛出事件 -&gt; 事件系统 -&gt; Buff系统 -&gt; Fighter属性维度</li><li>战斗流程获取属性 -&gt; 属性系统 -&gt; 公式计算  -&gt; Fighter属性维度</li></ul><p>通过属性系统和事件系统，将战斗流程和Buff系统解耦，将组件职责降到最小，方便测试和扩展。</p><p>比如沉默，眩晕等效果，如果没有虚拟属性，沉默Buff会注册EVENT_BEFORE_SKILL(Fighter释放技能前)这个Event，并且返回false来告知战斗系统它当前不能释放技能。同样，眩晕Buff会注册Fighter EVENT_BEFORE_MOVE, EVENT_BEFORE_ATTACK, EVENT_BEFORE_SKILL三个Event来实现眩晕效果，一来整个战斗流程每次都要合并各类Event的各种返回值(并且EventHandler得不到统一的接口抽象)，效率低下，二来战斗流程不应该依赖外部EventHandler的实现，它只关心值本身(能否移动，能否施法等)，因此虚拟属性本身实际上起一个依赖倒置的作用。如果使用虚拟属性，那么沉默Buff会在ATTR_FORBIDEN_SKILL这个属性上+1，眩晕同理，这样战斗流程在Fighter尝试施放技能时，获取Fighter的ATTR_FORBIDEN_SKILL属性，如果&gt;0，则不能施法。一句话，Buff通过属性来影响战斗流程。</p><p>再回到我们的SkillA上，以下是伪码实现:</p><pre><code>// SkillA对应的技能Bufffunc (self *SkillABuff) Start() {    // 这里将Start和Update流程合并了    EventMgr.AddEventListener(EVENT_BEFORE_DAMAGE, fighter.Id, func() {        // 如果当前回合触发次数&lt;2 并且概率50%满足        if self.triggerCnt &lt;2 &amp;&amp; ProbHappen(0.5) {            b := NewAttrBuff(ATTR_DAMAGE_MUL, 1.0, fighter) // 伤害翻倍的子Buff            fighter.AddBuff(b)            // 注册Fighter伤害结算完成 因为伤害翻倍只生效一次            listenerId := EventMgr.AddEventListener(EVENT_AFTER_DAMAGE, fighter.Id, func() {                // RemoveBuff会调用buff的Finish流程                fighter.RemoveBuff(b)                EventMgr.DelEventListener(listenerId)            })            self.triggerCnt++        }    }}// 通用属性Buff的Start流程 直接更新Owner的属性func (b *AttrBuff) Start() {    b.fighter.UpdateAttr(b.AttrType, b.AttrValue)}func (b *AttrBuff) Finish() {    b.fighter.UpdateAttr(b.AttrType, -b.AttrValue)}// 战斗流程 伤害结算部分baseDmg := ...EventMgr.FireEvent(EVENT_BEFORE_DAMAGE, fighter.Id)add := fighter.GetAttr(ATTR_DAMAGE_ADD)mul := fighter.GetAttr(ATTR_DAMAGE_MUL)dmg := (baseDmg+add)*mul... // 计算对方免伤效果，算出最终伤害EventMgr.FireEvent(EVENT_AFTER_DAMAGE, fighter.Id)</code></pre><h3 id="3-BUFF相互关系"><a href="#3-BUFF相互关系" class="headerlink" title="3. BUFF相互关系"></a>3. BUFF相互关系</h3><ul><li>Buff 免疫:     即该BUFF生效时，后面来的哪些BUFF不能生效，如BKB免疫眩晕</li><li>Buff 冲突:  即该BUFF生效时，可以被后面的那些BUFF冲掉，如减速可以被眩晕打断</li><li>Buff 叠加:  两种同类增益或减益BUFF同时生效时，按照某个规则进行BUFF效果重新计算生成</li></ul><p>Buff的冲突免疫关系是一个可抽象的流程，每个Buff的冲突免疫关系可以配置化，在挂载Buff时统一处理，至于Buff叠加，在Buff B的Start节点中，判断是否有指定Buff A存在，如果存在，修正BuffB的效果(或移除已有BuffA)，是个特例流程。</p><p>最终，我们通过属性维度和公式计算来避免了作用于同一个属性的Buff的顺序依赖，通过公用流程来处理Buff的免疫和冲突，仅针对Buff叠加这类少见的特殊作用进行特例化处理，这样最大程度的提升了Buff的扩展性，Buff可以独立实现，Buff的关系可通过配置表配置，新加一个Buff无需修改已有的Buff系统，对其它模块的影响也降到最小。</p><h2 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h2><p>属性系统针对Fighter的各种属性进行管理，属性系统包括K-V Map和公式计算两部分，前面我们讲到通过虚拟属性来完成Buff与战斗流程间的解耦，那么K-V Map的Key有如下几种:</p><ul><li>固定属性: 当前不受Buff影响的属性，无需公式计算直接获取即可。如Fighter当前血量，位置信息等</li><li>基础属性: 受Buff影响的属性的基础值，如Fighter进入战斗时的初始攻击力，防御力等，基础属性在战斗过程中不变</li><li>Buff属性: 基础属性的可变维度，由各类Buff修改，如攻击力增加值(绝对值)，防御力加成(百分比)</li><li>虚拟属性: 如禁足，沉默，伤害加成等，这些属性原本Fighter上面没有，属于战斗系统需要，也由Buff修改</li></ul><p>我将属性管理器K-V Map保存的”属性”称为属性维度，它们是Buff操作属性的最小粒度，每个属性维度都是纯加减运算，不受Buff先后顺序的影响。对最终属性的计算，由公式计算系统，比如: 最终攻击力 = (攻击力基础值+攻击力增加值)*(1+攻击力加成值)，战斗流程关心Fighter最终攻击力，Buff系统关心其影响的某个属性维度(如攻击力增加值或攻击力加成值)，中间的这一块就是公式计算，将公式计算抽象出来的好处是公式系统可独立变化，甚至可以将公式配置化。属性的计算过程对战斗流程来说是透明的，这给属性维度和公式计算的变更带来的很大的灵活度。</p><h2 id="其它扩展"><a href="#其它扩展" class="headerlink" title="其它扩展"></a>其它扩展</h2><p>前面介绍了SkillA的实现，来看看SkillB和SkillC:</p><ul><li>SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1，造成伤害降低15%，持续两回合<ul><li>技能目标选取规则中，配置攻击范围内一个敌人，技能作用脚本中，获取到该目标周围九宫格所有的敌人，对它们施加两个持续两回合的属性Buff(攻击距离-1，造成伤害-15%)。</li></ul></li><li>SkillC: 英雄受到攻击有60%的几率进行反击(伤害率60%)<ul><li>BuffC注册Fighter受到攻击后的事件，判断是否产生反击效果(60%几率)，如果是，产生反击属性子Buff,将Fighter的反击属性+1，之后战斗流程通过反击属性完成反击，反击完成后BuffC移除子Buff。整体思路与SkillA类似，只不过SkillA通过伤害翻倍来影响战斗伤害计算，而SkillC通过反击属性来影响战斗后续流程。</li></ul></li></ul><p>到这里，战斗系统的主要组件就已经介绍得差不多了，总结起来，核心思路是将相对稳定的核心战斗流程和相对动态的技能Buff扩展隔离开来，战斗流程通过事件系统来解耦外部Buff脚本，Buff通过属性系统来反馈到战斗流程。在构建的过程中，还要时刻关注到哪些是易变的，比如计算公式(如伤害计算公式)，将这一块单独抽出来，封装成模块甚至抽离到配置，尽量将功能做到模块化，离线化，方便模块的扩展和测试。</p><p>目前我们的讨论战斗系统还比较简陋，技能效果还只针对于Fighter，如果有技能会影响到整个战场的全局信息(如地形，天气)，比如我们要实现一个技能，该技能效果是可以使九宫格地形陷入腐蚀状态5s，在此期间踏入该区域的敌人，会受到持续伤害，考虑到这类技能的可扩展性，我们目前的思路是，将该技能做成一个”Fighter”，该Fighter在创建后，注册所有Fighter的移动事件，当发现其它Fighter进入到它维护的腐蚀区域时，施加一个持续伤害Buff，当Fighter走出腐蚀区域时，移除该Buff，当5s结束后，销毁自身。之所以将其做成一个Fighter而不是一个Buff，是考虑到这类技能的扩展性，比如如果这团腐蚀区域是有AI的，那么它应该有出手速度和移动策略，这方面来讲，它应该是一个”Fighter”，从这个角度来看，所以Fighter能做的事情，Buff都能做到，也算是个终极的解决方案了。具体细节还没有实践，仅仅是思路。</p><p>我们没有展开的另一点是关于战斗流程的，前面我们一直讨论如何抽离变化，将战斗流程”固化”下来，不要交给Buff系统去任意递归迭代，但随着战斗系统功能增长，战斗流程仍然会逐渐膨胀，比如普攻流程，缴械，反击，吸血等子流程会越来越多，新加一个子流程会变得越来越不安全，在这一点上后续也需要考虑去模块化管理这些子流程，另一个前面提到过的思路是，将普攻作为特殊技能来实现，这样技能和普攻的很多效果(吸血，AOE等)可以通过一套代码来实现。这些都是我们还在探索中的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与大部分回合制游戏一样，需要服务器计算战斗，客户端以战报的方式回放。这里探讨一下服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。&lt;/p&gt;
&lt;h2 id=&quot;战斗流程&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
      <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>用context库规范化Go的异步调用</title>
    <link href="http://wudaijun.com/2017/08/go-conetxt-usage/"/>
    <id>http://wudaijun.com/2017/08/go-conetxt-usage/</id>
    <published>2017-08-18T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见并发模型"><a href="#常见并发模型" class="headerlink" title="常见并发模型"></a>常见并发模型</h3><p>之前对比过<a href="http://wudaijun.com/2017/05/go-vs-erlang/">Go和Erlang的并发模型</a>，提到了Go的优势在于流控，下面列举几种常见的流控:</p><h4 id="Ping-Pong"><a href="#Ping-Pong" class="headerlink" title="Ping-Pong"></a>Ping-Pong</h4><p>这通常针对于两个goroutine之间进行简单的数据交互和协作，我们常用的RPC也属于此类，通过channel的类型可以灵活实现交互方式:</p><ul><li>同步单工: 单个双向非缓冲channel</li><li>同步双工: 多个单向非缓冲channel</li><li>异步双工: 多个单向缓冲channel</li></ul><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>流水线如其词语，goroutine是”流水线工人”，channel则为”流水线”，衔接不同的goroutine的输入输出，每个goroutine有一个输入(inbound)channel和输出(outbound)channel:</p><pre><code>// 以下定义一个流水线工人 用于将inbound channel中数字求平方并放入outbound channelfunc sq(in &lt;-chan int) &lt;-chan int {    out := make(chan int)    go func() {        for n := range in {            out &lt;- n * n        }        close(out)    }()    return out}</code></pre><p>流水线goroutine有一些特质：它负责创建并关闭channel(在完成自己的工作后)，这样外部调用无需关心channel的创建和关闭，当channel被关闭，它的下游goroutine会读出零值的数据。我们还可以用链式调用来组装流水线：</p><pre><code>sq(sq(sq(ch)))</code></pre><p>在实际应用中，如DB读写，网络读写等外部阻塞操作通常都放到单独的流水线去做，下游主goroutine可以灵活处理IO结果(如通过select完成IO复用)。</p><h4 id="扇入扇出"><a href="#扇入扇出" class="headerlink" title="扇入扇出"></a>扇入扇出</h4><p>流水线工作通常是一对一的”工作对接”，通过select可以达成IO复用，比如GS同时处理网络消息，RPC调用，Timer消息等，这其实就是简单的扇入模型，扇出模型也比较常见，比如在对一些无状态的任务做分发时，可以让多个goroutine处理一个channel任务队列上的数据，最大程度地提升处理效率。</p><p>上面三个模式是应用最常用到的，因此不再举例具体说明，<a href="http://strucoder.com/2016/03/15/gozhong-de-bing-fa-ke-shi-hua/" target="_blank" rel="external">Go并发可视化</a>这篇文章很好地归纳和总结了这些模型，推荐一读。</p><h3 id="交互规范"><a href="#交互规范" class="headerlink" title="交互规范"></a>交互规范</h3><p>上面只所以提出这三种模型主要是为了导出接下来的问题，当用到多个goroutine时，如何协调它们的工作：</p><h4 id="如何正确关闭其它goroutine"><a href="#如何正确关闭其它goroutine" class="headerlink" title="如何正确关闭其它goroutine"></a>如何正确关闭其它goroutine</h4><p>这类问题的通常情形是：当某个goroutine遇到异常或错误，需要退出时，如何通知其它goroutine，或者当服务器需要停止时，如何正常终止整个并发结构，为了简化处理问题模型，以流水线模型为例，在正常情况下，它们会按照正常的流程结束并关闭channel(上游关闭channel，下游range停止迭代，如此反复)，但当某个下游的goroutine遇到错误需要退出，上游是不知道的，它会将channel写满阻塞，channel内存和函数栈内存将导致内存泄露，在常规处理方案中，我们会使用一个done channel来灵活地通知和协调其它goroutine，通过向done channel写入数据(需要知道要关闭多少个goroutine)或关闭channel(所有的读取者都会收到零值，range会停止迭代)。</p><h4 id="如何处理请求超时"><a href="#如何处理请求超时" class="headerlink" title="如何处理请求超时"></a>如何处理请求超时</h4><p>至于超时和请求放弃，通常我们可以通过select来实现单次请求的超时，比如 A -&gt; B -&gt; C 的Ping-Pong异步调用链，我们可以在A中select设置超时，然后在B调用C时也设置超时，这种机制存在如下问题:</p><ol><li>每次请求链中的单次调用都要启一个timer goroutine</li><li>调用链中的某个环节，并不知道上层设置的超时还有多少，比如B调用C时，如果发现A设置的超时剩余时间不足1ms，可以放弃调用C，直接返回</li><li>A-&gt;B的超时可能先于B-&gt;C的超时发生，从而导致其它问题</li></ol><h4 id="如何安全放弃异步请求"><a href="#如何安全放弃异步请求" class="headerlink" title="如何安全放弃异步请求"></a>如何安全放弃异步请求</h4><p>这个问题可以理解为如何提前结束某次异步调用，接上面提到的A-&gt;B-&gt;C调用链，如果A此时遇到了其它问题，需要提前结束整个调用链(如)，B是不知道的，A和B之间数据交互channel和done channel，没有针对某个请求的取消channel，尽管大部分时候不会遇到这种需求，但针对某个请求的协同机制是缺失的，还需要另行设计。</p><h4 id="如何保存异步调用上下文"><a href="#如何保存异步调用上下文" class="headerlink" title="如何保存异步调用上下文"></a>如何保存异步调用上下文</h4><p>异步调用通常会有上下文，这个上下文不只指调用参数，还包括回调处理参数(非处理结果)，请求相关上下文(如当前时间)等，这类数据从设计上可以通过包含在请求中，或者extern local value，或者每次请求的session mgr来解决，但并不通用，需要开发者自行维护。</p><h3 id="使用context"><a href="#使用context" class="headerlink" title="使用context"></a>使用context</h3><p>以上几个问题并不限于Go，而是异步交互会遇到的普遍问题，只是在Go应用和各类库会大量用到goroutine，所以这类问题比较突出。针对这些问题，Go的内部库(尤其是net,grpc等内部有流水线操作的库)作者开发了context(golang.org/x/net/context)包，用于简化单个请求在多个goroutie的请求域(request-scoped)数据，它提供了:</p><ol><li>请求的超时机制</li><li>请求的取消机制</li><li>请求的上下文存取接口</li><li>goroutine并发访问安全性</li></ol><p>context以组件的方式提供超时(WithTimeout/WithDeadline)，取消(WithCancel)和K-V(WithValue)存取功能，每次调用WithXXX都将基于当前的context(Background为根Context)继承一个Context,一旦父Context被取消，其子Context都会被取消，应用可通过&lt;-context.Done()和<br>context.Err()来判断当前context是否结束和结束的原因(超时/取消)。</p><p>比如针对我们前面的”sq流水线工人”，我们可以通过context让它知道当前流水线的状态，并及时终止:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">out</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</div><div class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</div><div class="line">        <span class="keyword">select</span>&#123;</div><div class="line">        <span class="keyword">case</span> &lt;-ctx.Done():<span class="comment">// 当前流水线被终止</span></div><div class="line">        <span class="built_in">close</span>(out)</div><div class="line">        <span class="keyword">return</span> ctx.Err() <span class="comment">// 终止原因: DeadlineExceeded or Canceled</span></div><div class="line">        <span class="keyword">case</span> out &lt;- n * n:</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">close</span>(out)</div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> out</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以将context在goroutine之间传递，并且针对当前调用通过WithXXX创建子context，设置新的超时，请求上下文等，一旦请求链被取消或超时，context的done channel会被关闭，当前context的所有<code>&lt;-ctx.Done()</code>操作都会返回，并且所有当前context的子context会以相同原因终止。</p><p>比如在A-&gt;B-&gt;C中，B基于A的context通过WithTimeout或WithValue创建子context，子Context的超时和上下文都可以独立于父context(但如果子context设置超时大于父context剩余时间，将不会创建timer)，通过context库内部的继承体系来完成对应用层调用链的记录，并执行链式的超时和取消。</p><p>关于context的进一步了解可参考<a href="https://segmentfault.com/a/1190000006744213" target="_blank" rel="external">Go语言并发模型：使用 context</a>，也可直接阅读源码，实现也比较简单，单文件不到300行代码，但本身的意义却是重大的，go的很多异步库(如net,grpc,etcd等)都用到了这个模块，context正在逐渐成为异步库的API规范，我们也可以从context这个库中得到一些启发，适当地用在自己的项目中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常见并发模型&quot;&gt;&lt;a href=&quot;#常见并发模型&quot; class=&quot;headerlink&quot; title=&quot;常见并发模型&quot;&gt;&lt;/a&gt;常见并发模型&lt;/h3&gt;&lt;p&gt;之前对比过&lt;a href=&quot;http://wudaijun.com/2017/05/go-vs-erlang
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go vs Erlang</title>
    <link href="http://wudaijun.com/2017/05/go-vs-erlang/"/>
    <id>http://wudaijun.com/2017/05/go-vs-erlang/</id>
    <published>2017-05-30T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>源于从Erlang到Go的一些思维碰撞，就像当初从C++到Erlang一样，整理下来记于此。</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor模型，又叫参与者模型，其”一切皆参与者(actor)”的理念与面向对象编程的“一切皆是对象”类似，但是面向对象编程中对象的交互通常是顺序执行的(占用的是调用方的时间片，是否并发由调用方决定)，而Actor模型中actor的交互是并行执行的(不占用调用方的时间片，是否并发由自己决定)。</p><p>在Actor模型中，actor执行体是第一类对象，每个actor都有自己的ID(类比人的身份证)，可以被传递。actor的交互通过发送消息来完成，每个actor都有一个通信信箱(mailbox，本质上是FIFO消息队列)，用于保存已经收到但尚未被处理的消息。actorA要向actorB发消息，只需持有actorB ID，发送的消息将被立即Push到actorB的消息信箱尾部，然后返回。因此Actor的通信原语是异步的。</p><p>从actor自身来说，它的行为模式可简化为:</p><ul><li>发送消息给其它的actor</li><li>接收并处理消息，更新自己的状态</li><li>创建其它的actor</li></ul><p>一个好的Actor模型实现的设计目标:</p><ul><li>调度器: 实现actor的公平调度</li><li>容错性: 具备良好的容错性和完善错误处理机制</li><li>扩展性: 屏蔽actor通信细节，统一本地actor和远程actor的通信方式，进而提供分布式支持</li><li>热更新? (还没弄清楚热更新和Actor模型，函数式范式的关联性)</li></ul><p>在Actor模型上，Erlang已经耕耘三十余载，以上提到的各个方面都有非常出色的表现，其OTP整合了在Actor模型上的最佳实践，是Actor模型的标杆。</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>顺序通信进程(Communicating sequential processes，CSP)和Actor模型一样，都由独立的，并发的执行实体(process)构成，执行实体间通过消息进行通信。但CSP模型并不关注实体本身，而关注发送消息使用的通道(channel)，在CSP中，channel是第一类对象，process只管向channel写入或读取消息，并不知道也不关心channel的另一端是谁在处理。channel和process是解耦的，可以单独创建和读写，一个process可以读写(订阅)个channel，同样一个channel也可被多个process读写(订阅)。</p><p>对每个process来说：</p><ul><li>从命名channel取出并处理消息</li><li>向命名channel写入消息</li><li>创建新的process</li></ul><p>Go语言并没有完全实现CSP理论(参见<a href="https://www.zhihu.com/question/26192499" target="_blank" rel="external">知乎讨论</a>)，只提取了CSP的process和channel的概念为并发提供理论支持。目前Go已经是CSP的代表性语言。</p><h3 id="CSP-vs-Actor"><a href="#CSP-vs-Actor" class="headerlink" title="CSP vs Actor"></a>CSP vs Actor</h3><ul><li>相同的宗旨：”不要通过共享内存来通信，而应该通过通信来共享内存”</li><li>两者都有独立的，并发执行的通信实体</li><li>Actor第一类对象为执行实体(actor)，CSP第一类对象为通信介质(channel)</li><li>Actor中实体和通信介质是紧耦合的，一个Actor持有一个Mailbox，而CSP中process和channel是解耦的，没有从属关系。从这一层来说，CSP更加灵活</li><li>Actor模型中actor是主体，mailbox是匿名的，CSP模型中channel是主体，process是匿名的。从这一层来说，由于Actor不关心通信介质，底层通信对应用层是透明的。因此在分布式和容错方面更有优势</li></ul><h3 id="Go-vs-Erlang"><a href="#Go-vs-Erlang" class="headerlink" title="Go vs Erlang"></a>Go vs Erlang</h3><ul><li>以上 CSP vs Actor</li><li>均实现了语言级的coroutine，在阻塞时能自动让出调度资源，在可执行时重新接受调度</li><li>go的channel是有容量限制的，因此只能一定程度地异步(本质上仍然是同步的)，erlang的mailbox是无限制的(也带来了消息队列膨胀的风险)，并且erlang并不保证消息是否能到达和被正确处理(但保证消息顺序)，是纯粹的异步语义，actor之间做到完全解耦，奠定其在分布式和容错方面的基础</li><li>erlang/otp在actor上扩展了分布式(支持异质节点)，热更和高容错，go在这些方面还有一段路要走(受限于channel，想要在语言级别支持分布式是比较困难的)</li><li>go在消息流控上要做得更好，因为channel的两个特性: 有容量限制并独立于goroutine存在。前者可以控制消息流量并反馈消息处理进度，后者让goroutine本身有更高的处理灵活性。典型的应用场景是扇入扇出，Boss-Worker等。相比go，erlang进程总是被动低处理消息，如果要做流控，需要自己做消息进度反馈和队列控制，灵活性要差很多。另外一个例子就是erlang的receive操作需要遍历消息队列(<a href="http://www.jianshu.com/p/41f2e943c795" target="_blank" rel="external">参考</a>)，而如果用go做同步调用，通过单独的channel来做则更优雅高效</li></ul><h3 id="Actor-in-Go"><a href="#Actor-in-Go" class="headerlink" title="Actor in Go"></a>Actor in Go</h3><p>在用Go写GS框架时，不自觉地会将goroutine封装为actor来使用:</p><ul><li>GS的执行实体(如玩家，公会)的逻辑具备强状态和功能聚合性，不易拆分，因此通常是一个实体一个goroutine</li><li>实体接收的逻辑消息具备弱优先级，高顺序性的特点，因此通常实体只会暴露一个Channel与其它实体交互(结合go的interface{}很容易统一channel类型)，这个channel称为RPC channel，它就像这个goroutine的ID，几乎所有逻辑goroutine之间通过它进行交互</li><li>除此之外，实体还有一些特殊的channel，如定时器，外部命令等。实体goroutine对这些channel执行select操作，读出消息进行处理</li><li>加上goroutine的状态数据之后，此时的goroutine的行为与actor相似：接收消息(多个消息源)，处理消息，更新状态数据，向其它goroutine发送消息(通过RPC channel)</li></ul><p>到目前为止，goroutine和channel解耦的优势并未体现出来，我认为主要的原因仍然是GS执行实体的强状态性和对异步交互流程的顺序性导致的。</p><p>在研究这个问题的过程中，发现已经有人已经用go实现了Actor模型: <a href="https://github.com/AsynkronIT/protoactor-go。" target="_blank" rel="external">https://github.com/AsynkronIT/protoactor-go。</a> 支持分布式，甚至supervisor，整体思想和用法和erlang非常像，真是有种他山逢知音的感觉。:)</p><p>参考：</p><ol><li><a href="http://jolestar.com/parallel-programming-model-thread-goroutine-actor/" target="_blank" rel="external">http://jolestar.com/parallel-programming-model-thread-goroutine-actor/</a></li><li><a href="https://www.zhihu.com/question/26192499" target="_blank" rel="external">https://www.zhihu.com/question/26192499</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源于从Erlang到Go的一些思维碰撞，就像当初从C++到Erlang一样，整理下来记于此。&lt;/p&gt;
&lt;h3 id=&quot;Actor&quot;&gt;&lt;a href=&quot;#Actor&quot; class=&quot;headerlink&quot; title=&quot;Actor&quot;&gt;&lt;/a&gt;Actor&lt;/h3&gt;&lt;p&gt;Acto
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Erlang+Lua的一次重构</title>
    <link href="http://wudaijun.com/2017/03/erlang-lua-reconstruction/"/>
    <id>http://wudaijun.com/2017/03/erlang-lua-reconstruction/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-30T03:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前所在的项目基于<a href="http://wudaijun.com/2015/08/erlang-server-design1-cluster-server/">erlang cluster</a>搭建框架，再接入lua用于写逻辑。由于之前有一些erlang+lua的开发经验，因此着手项目的重构和优化，过程中一些体会，记录于此。</p><p>先简述一下项目架构，erlang做集群，网络层，节点交互，DB交互等，lua层只写逻辑。一个erlang的Actor持有一个luastate，为了加速erlang和lua之间的交互效率：</p><ol><li>将逻辑数据置于lua中而不是erlang中，在落地时，以二进制格式丢给erlang进行DB操作</li><li>以<code>lual_ref</code>和msgid等方式，尽量用整数代理字符串</li><li>erlang和lua异步运行，lua跑在原生线程池中，这在<a href="http://wudaijun.com/2015/09/erlang-server-design2-erlang-lua-battle/">这篇博文</a>中介绍过</li></ol><p>除了这些，还需要注意lua的沙盒环境管理，错误处理，热更新等，这里不再详述。就目前这种结构而言，还有一些缺陷：</p><ol><li>原子线程池忙碌可能导致的erlang虚拟机假死，需要保证原生线程池最多占用的核数不超过erlang虚拟机能使用的核数</li><li>lua state本身带来的不稳定性，特别是内存，在Actor过多时将会非常明显</li></ol><p>第二点，也是目前我们遇到的最棘手的问题，我们知道，在lua中，模块，函数，均是一个闭包，闭包包含函数和外部环境(UpValue，ENV等)，因此在lua中，每个lua state都完整包含加载的所有模块和函数，并且很难共享。我们项目通过一个share lua state完成了对配置表这类静态数据的共享(跨系统进程级的共享可参考<a href="http://blog.codingnow.com/2012/07/dev_note_24.html" target="_blank" rel="external">云风blog</a>)，但本身逻辑代码占用内存仍然很大，随着逻辑和功能模块的增加，基本一个lua state加载完模块什么也不做，会占用6-7M内存。意味着如果一个玩家一个lua state，那么一台16G内存的服务器，基本只能容纳2000个玩家，内存吃紧，而CPU过剩。因此本次重构也只要针对这个问题。</p><p>之前项目组曾针对玩家进行了优化，将主城位于一个岛的玩家归位一组，再将岛按照<code>%M</code>的方式放到M个lua state容器上，这样得到一个复杂的，三层逻辑的lua state。针对玩家这一块的内存占用确实大大减少了，但调试难度也提升了，并且扩展性不好，不能将这种容器扩展到其它service(如Union)上。</p><p>按照系统本身的理想设计，一个service(player, union)对应一个lua state，由一个erlang process代理这个lua state，并且通过cluster注册/共享这个service的状态信息。但由于lua state的内存占用，不能再奢侈地将service和lua state 1:1调配，多service在逻辑代码中共用一个lua state已经无可避免，我们可以简单将整个系统分为几个层级，</p><table><thead><tr><th>service</th><th>lua state</th><th>erlang process</th><th>cluster</th></tr></thead><tbody><tr><td>N</td><td>1</td><td>?</td><td>?</td></tr></tbody></table><p>因此有以下几种可能的方案：</p><ol><li><code>N 1 N N</code>：每个service对应一个erlang process，多个erlang process将代理同一个lua state，这就需要lua state可以”被并发”，也就是同一个lua state只能绑定一个原生线程池上执行，这一点是可以实现的。这种方案在erlang层会获得更好的并发性能，并且cluster层语义不变。</li><li><code>N 1 1 N</code>：一个erlang process作为container的概念代理一个lua state，容纳N个service，并且将service和erlang process的映射关系写入cluster，cluster层对外提供的语义不变，但service的actor属性被弱化，service的一致性状态是个问题。</li><li><code>N 1 1 1</code>：与上种方案类似，只不过将service到container的映射通过算法算出来，而不写入cluster，container本身被编号（编号时，可考虑将serverid编入，这样开新服有一定的扩展性，PS: <a href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">一致性哈希</a>方案不适用于游戏这类强状态逻辑），某个service将始终分配在指定container上。这种方案减少了cluster负担，并且减少了service不一致性的BUG。但由于container有状态，在每次系统启动后，service和container的映射关系就确定了，因此整个集群的可伸缩性降低了。</li></ol><p>经过几番讨论，我们最终选择了第三个方案，虽然个人认为这类固定分配的方案，与分布式的理念是相悖的，但目前稳定性和一致性才是首要目标。由于采用计算而不是通过mnesia保存映射关系，mnesia的性能和系统一致性得到了提升。本次重构在某些方面与我上一个项目<a href="http://wudaijun.com/2016/01/erlang-server-design5-server-node/">针对cluster的优化</a>有点相似，一个对系统服务进行横向切割，另一个则纵向切割，前者的初衷是为了更好地交互效率，后者则是处于对lua state资源的复用，两者都降低了系统的可伸缩性，得到了”一个更大粒度”的service。</p><p>整个重构过程中，有几点感触：</p><p>erlang和lua结合本身不是一种好的解决方案，或者说，erlang接入其它语言写逻辑都不合适，异质化的系统会打乱erlang本身的调度(不管通过nif还是线程池)，并且给整个系统带来不稳定性(CPU，内存)。另外，接入其它语言可能破坏erlang的原子语义和并发性。拿lua来说，原生线程池会和erlang调度线程抢占CPU并且很难管控，加之lua有自己的GC，因此在内存和CPU这两块关键资源上，erlang失去了控制权，给系统带来不稳定性。再加之lua state的内存占用以及lua state不支持并发，你可能要花更多的时间来调整系统结构，最终得到一个相对稳定的系统。如果处理得不好，用erlang做底层的可靠性和并发性将荡然无存。</p><p>系统设计，是一个不断根据当前情况取舍的过程，想要一步到位是不可能的。简单，可控，开发效率高才是主要指标，才能最大程度地适应各种变化，快速响应需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前所在的项目基于&lt;a href=&quot;http://wudaijun.com/2015/08/erlang-server-design1-cluster-server/&quot;&gt;erlang cluster&lt;/a&gt;搭建框架，再接入lua用于写逻辑。由于之前有一些erlang+lua
      
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="lua" scheme="http://wudaijun.com/tags/lua/"/>
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Lua 闭包 环境 包管理</title>
    <link href="http://wudaijun.com/2017/02/lua-notes/"/>
    <id>http://wudaijun.com/2017/02/lua-notes/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2017-10-31T06:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><ul><li>访问一个不存在的全局变量得到nil</li><li>释放一个全局变量只需将其赋值为nil，效果与未定义该变量一样</li><li>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量</li><li>局部变量比全局变量访问更快</li></ul><a id="more"></a><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ol><li>多参数/返回值匹配：多余忽略，缺少用nil补足</li><li>可变参数：arg，table.pack，table.unpack</li><li>命名参数：参数的非顺序填充方式</li><li>正确处理尾调用：Lua能够高效正确处理尾调用，而不会导致栈溢出</li></ol><h3 id="2-第一类函数"><a href="#2-第一类函数" class="headerlink" title="2. 第一类函数"></a>2. 第一类函数</h3><p>函数是第一类值，函数可以像其它值（string, number）样用于赋给变量，作为函数参数或返回值。函数定义实际上是一个赋值语句，将类型为function的变量赋给一个变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.bar</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></div><div class="line"><span class="comment">-- 等价于</span></div><div class="line">foo.bar = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></div></pre></td></tr></table></figure><p>从这个角度来看，自然，与变量一样，Lua有全局函数和局部函数之分。</p><h3 id="3-词法闭包"><a href="#3-词法闭包" class="headerlink" title="3. 词法闭包"></a>3. 词法闭包</h3><p>词法闭包是指当在一个函数内部嵌套定义另一个函数时，内部函数体可以访问到外部函数的局部变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> i = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>     <span class="comment">-- anonymous function</span></div><div class="line">        i = i + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> i</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">c1 = newCounter()</div><div class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 1</span></div><div class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 2</span></div><div class="line">c2 = newCounter()</div><div class="line"><span class="built_in">print</span>(c2())  <span class="comment">--&gt; 1</span></div><div class="line"></div><div class="line"><span class="comment">-- 打印c1所有的upvalue 输出: i</span></div><div class="line"><span class="keyword">local</span> i=<span class="number">1</span></div><div class="line"><span class="keyword">local</span> up = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(c1, i)</div><div class="line"><span class="keyword">while</span>(up ~= <span class="literal">nil</span>) <span class="keyword">do</span></div><div class="line">    <span class="built_in">print</span>(up, <span class="string">"  "</span>)</div><div class="line">    i = i+<span class="number">1</span></div><div class="line">    up = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(c1, i)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="built_in">print</span>(c1, c2) <span class="comment">-- function: 0x7f8df1d02100        function: 0x7f8df1d02160</span></div></pre></td></tr></table></figure><p>这种情况下，我们称i为匿名函数的外部局部变量(external local variable)或upvalue。在这里，newCounter函数返回了一个闭包(closure)。闭包是指一个函数和它的upvalues，闭包机制保证了即使upvalue已经超出了其作用域(newCounter返回)，仍然能正确被闭包函数引用而不会释放(由Lua GC管理)。在上例中，我们说c1和c2是建立在同一个函数上，但作用于同一个局部变量(i)不同实例的两个不同的闭包。</p><p>通过打印的upvalues可以看到，只有被闭包函数引用的外部局部变量，才算作该闭包函数的upvalue，Lua会按照闭包函数引用的顺序为upvalue编号，该编号与upvalue定义顺序无关。</p><p>最后一点是，闭包函数都是动态生成的，这和<a href="http://wudaijun.com/2016/09/go-basic/">Go中的闭包</a>有所不同，Go的闭包函数是在编译时生成的，不同的闭包可以共享闭包函数(同一个函数地址)。Lua的闭包函数动态生成会一定程度地影响运行效率和内存占用。</p><p>Lua闭包除了用于高级函数，回调函数，迭代器等上下文环境中以外，在完全不同的上下文环境，可用于重定义或预定义函数，通过这种方法，可以为代码创建一个安全的执行环境(也叫沙箱，sandbox)。</p><p>Lua还提供了对C闭包的支持，每当你在Lua中创建一个新的C函数，你可以将这个函数与任意多个upvalues联系起来，每一个upvalue 可以持有一个单独的Lua值。当函数被调用的时候，可以通过假索引(<code>lua_upvalueindex</code>)自由的访问任何一个upvalues。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> val = lua_tonumber(L, lua_upvalueindex(<span class="number">1</span>));</div><div class="line">    lua_pushnumber(L, ++val);   <span class="comment">/* new value */</span></div><div class="line">    lua_pushvalue(L, <span class="number">-1</span>);       <span class="comment">/* duplicate it */</span></div><div class="line">    lua_replace(L, lua_upvalueindex(<span class="number">1</span>));  <span class="comment">/* update upvalue */</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* return new value */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">newCounter</span> <span class="params">(lua_State *L)</span> </span>&#123;</div><div class="line">    lua_pushnumber(L, <span class="number">0</span>);</div><div class="line">    lua_pushcclosure(L, &amp;counter, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C闭包与Lua闭包在概念上很相似，但有两点不同：</p><ol><li>C函数的upvalues是显示push到栈中的，而Lua则可通过闭包函数引用确定哪些是upvalues</li><li>C闭包不能共享upvalues，每个闭包在栈中都有独立的变量集，但你可以通过将upvalues指向同一个table来实现共享</li></ol><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Chunk是一系列语句，Lua执行的每一块语句，比如一个文件或者交互模式下的每一行都是一个Chunk。</p><p>当我们执行loadfile(“test.lua”)时，便将test.lua的内容编译后的Chunk作为一个函数返回，如果出现编译错误，则返回nil和错误信息。而dofile相当于:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofile</span> <span class="params">(filename)</span></span></div><div class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(filename))</div><div class="line">    <span class="keyword">return</span> f()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>loadstring和dostring的关系类似，只是接收字符串而不是文件名为参数。</p><p>再看require，require和dofile完成同样的功能，但主要有几点不同：</p><ol><li>require会搜索Lua环境目录来加载文件</li><li>require会判断文件是否已经加载而避免重复加载统一文件</li><li>require可以用于加载C .so库，功能类似loadlib，参考<a href="http://wudaijun.com/2014/12/lua-C/">这里</a></li></ol><p>一个lua模块编译后的Chunk被作为匿名函数被执行，那么定义于模块中函数对模块局部变量的引用就形成了闭包，所以说Lua中的闭包真是无处不在。</p><h2 id="Enviroment"><a href="#Enviroment" class="headerlink" title="Enviroment"></a>Enviroment</h2><p>Lua中的环境用table来表示，这简化了环境处理也带来了不少灵活性。</p><p>在Lua5.1及之前，Lua将环境本身存储在一个全局变量_G中，其中包含了全局变量，内置函数，内置模块等。我们在使用任何符号x时，如果在当前函数的局部变量和upvalues无法找到符号定义(PS: Lua查找变量定义的规则为：局部变量 -&gt; 外部局部变量(upvalue) -&gt; 全局变量)，则会返回_G.x的值。由于_G是一个table，因此我们可以用它实现一些有意思的功能：</p><ol><li>通过动态名字访问全局变量： <code>_G[varname]</code></li><li>通过_G的metatable改变对未定义全局变量的读(<code>__index</code>)和写(<code>__newindex</code>)行为</li><li>通过setfenv改变指定函数的_G环境，制造函数执行的沙盒环境</li></ol><p>现在再回头来看闭包，实际上，Lua闭包除了函数和upvalues，还包括函数环境，这三者组成了一个完整的执行沙盒。</p><p>在Lua5.2及之后，Lua取消了setfenv函数，用_ENV方案替代了_G方案：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- before Lua 5.1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">  <span class="built_in">setfenv</span>(<span class="number">1</span>, &#123;&#125;)</div><div class="line">  <span class="comment">-- code here</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">-- after Lua 5.2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">local</span> <span class="built_in">_ENV</span> = &#123;&#125;</div><div class="line">  <span class="comment">-- code here</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">or</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> <span class="built_in">_ENV</span> = &#123;&#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>_ENV有三个特性：</p><ol><li>对全局变量x的引用，将转换为_ENV.x</li><li>每个编译后的Chunk，都有一个_ENV upvalue(哪怕并未使用)，作为Chunk环境，并作用于其内定义的函数</li><li>在初始化时，_ENV=_G</li></ol><p>除了以上三点外，_ENV和普通变量并无区别。因此我们可以直接通过<code>local _ENV = {}</code>来覆盖接下来的代码的环境。将环境(_ENV)作为一个普通的upvalue来处理，这样做的好处是简化了闭包的概念，闭包等于函数加upvalues(没有了全局变量_G)，为闭包优化(如合并相同upvalues的闭包)提供更好的支持，同时也减少了<code>setfenv(f, env)</code>带来的不确定性和不安全性(函数的_ENV upvalue在闭包返回时就已经确定了)。</p><p>有_ENV还是一个table，因此对全局变量的访问控制等trick，仍然很容易实现。Lua目前仍然保留_G，但理解它们的别是比较重要的：</p><p>我们都知道Lua有一个全局注册表(Registry)，其中包含整个Lua虚拟机的信息，在Registry的<code>LUA_RIDX_GLOBALS</code>索引中，保存了Globals(也就是_G)，在创建Globals时，会生成<code>_G._G=_G</code>的自引用。在引入_ENV后，初始时，<code>_ENV=_G</code>，一旦编译器将_ENV放入Chunk的upvalue后，_ENV将作为普通upvalue被看待，因此我们可以对其重新赋值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">1</span> <span class="comment">-- 此时 _ENV.i == _G.i == 1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> <span class="built_in">_ENV</span>=&#123;i=<span class="number">2</span>, <span class="built_in">print</span>=<span class="built_in">print</span>, <span class="built_in">_G</span>=<span class="built_in">_G</span>&#125;</div><div class="line">    <span class="built_in">print</span>(i, <span class="built_in">_ENV</span>.i, <span class="built_in">_G</span>.i)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">()</span></span></div><div class="line">    <span class="built_in">print</span>(i, <span class="built_in">_ENV</span>.i, <span class="built_in">_G</span>.i)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">f() <span class="comment">-- 2 2 1</span></div><div class="line">g() <span class="comment">-- 1 1 1</span></div></pre></td></tr></table></figure><p>因此，_ENV除了在创建时和_G都指向Registry[LUA_RIDX_GLOBALS]之外，和_G并没有直接联系(<code>_G={}</code>不会影响函数环境，<code>_G.x=1</code>仍然会影响注册表中的Globals)，Lua5.2及之后的环境都由_ENV指定，_G出于历史原因保留，但实际上Lua并不在内部再使用：</p><blockquote><p>Lua keeps a distinguished environment called the global environment. This value is kept at a special index in the C registry (see §4.5). In Lua, the global variable _G is initialized with this same value. (_G is never used internally.)</p></blockquote><ul><li>参考<a href="http://lua-users.org/lists/lua-l/2014-08/msg00345.html" target="_blank" rel="external">_ENV vs _G</a>，<a href="http://stackoverflow.com/questions/14290527/recreating-setfenv-in-lua-5-2" target="_blank" rel="external">setfenv in Lua5.2</a></li></ul><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>在Lua中，有闭包，灵活的table和环境管理，想要实现包管理有非常多的方法：</p><h3 id="1-基本方法"><a href="#1-基本方法" class="headerlink" title="1. 基本方法"></a>1. 基本方法</h3><p>最简单的方法就是直接使用table和第一类函数特性：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">complex = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex.new</span><span class="params">(r,i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex.add</span><span class="params">(c1,c2)</span></span> ... <span class="keyword">end</span></div><div class="line">...</div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure><p>执行这个Chunk后，便可以通过<code>complex.xxx()</code>使用complex中定义的API了。这种方案主要的缺点是包内包外的调用都必须加上前缀，并且不能很好地隐藏私有成员。</p><h3 id="2-局部函数"><a href="#2-局部函数" class="headerlink" title="2. 局部函数"></a>2. 局部函数</h3><p>通过局部函数再导出的方式，我们可以解决包内调用前缀和隐藏私有成员(不导出即可)的问题。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c1,c2)</span></span> ... <span class="keyword">end</span></div><div class="line">...</div><div class="line">complex = &#123;new = new, add = add&#125;</div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure></p><p>但这样容易忘了local，造成全局命名空间污染。</p><h3 id="3-独立环境"><a href="#3-独立环境" class="headerlink" title="3. 独立环境"></a>3. 独立环境</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">complex = &#123;&#125;</div><div class="line"><span class="comment">-- before Lua5.1: setfenv(1, complex)</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = complex</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,  i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(c1, c2)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure><p>现在，包内所有全局符号new, add都会被转换为complex.new, complex.add，并且我们为包创建了一个独立沙盒环境，如果要在包内访问全局符号，也有多种方法:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 方案1: 保存老的全局环境 之后访问全局符号需要加上 _G.前缀</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">_G</span> = <span class="built_in">_G</span></div><div class="line"><span class="comment">-- 方案2: 通过metatable 效率低一些，并且外部可通过complex.print访问_G.print</span></div><div class="line"><span class="built_in">setmetatable</span>(complex, &#123;<span class="built_in">__index</span> = <span class="built_in">_G</span>&#125;)</div><div class="line"><span class="comment">-- 方案3: 只导出要使用的函数 这种方法隔离型更好，并且更快</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">sqrt</span> = <span class="built_in">math</span>.<span class="built_in">sqrt</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">print</span> = <span class="built_in">print</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Variables&quot;&gt;&lt;a href=&quot;#Variables&quot; class=&quot;headerlink&quot; title=&quot;Variables&quot;&gt;&lt;/a&gt;Variables&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;访问一个不存在的全局变量得到nil&lt;/li&gt;
&lt;li&gt;释放一个全局变量只需将其赋值为nil，效果与未定义该变量一样&lt;/li&gt;
&lt;li&gt;Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量&lt;/li&gt;
&lt;li&gt;局部变量比全局变量访问更快&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="lua" scheme="http://wudaijun.com/categories/lua/"/>
    
    
      <category term="lua" scheme="http://wudaijun.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X下的资源限制</title>
    <link href="http://wudaijun.com/2017/02/max-osx-ulimit/"/>
    <id>http://wudaijun.com/2017/02/max-osx-ulimit/</id>
    <published>2017-02-06T16:00:00.000Z</published>
    <updated>2017-02-08T04:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>系统的资源是有限的(如CPU，内存，内核所能打开的最大文件数等)，资源限制对针对进程能使用的系统资源设定上限。防止恶意进程无限制地占用系统资源。</p><p>资源限制分为两种，硬限制(Hard Limit)和软限制(Soft Limit)，软限制作用于实际进程并且可以修改，但不能超过硬限制，硬限制只有Root权限才能修改。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>在Mac OS X下，有如下三个命令与系统资源有关。</p><h3 id="launchctl"><a href="#launchctl" class="headerlink" title="launchctl"></a>launchctl</h3><p>launchctl管理OS X的启动脚本，控制启动计算机时需要开启的服务(通过后台进程launchd)。也可以设置定时执行特定任务的脚本，类似Linux cron。</p><p>例如，开机时自动启动Apache服务器：</p><pre><code>$ sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist</code></pre><p>关于launchctl的plist格式和用法参考:</p><ol><li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/launchctl.1.html" target="_blank" rel="external">launchctl man page</a></li><li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html" target="_blank" rel="external">launchd plist man page</a></li><li><a href="http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/" target="_blank" rel="external">mac-os-x-launchd-is-cool</a></li><li><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="external">creating launchd jobs</a></li></ol><p>简单来说，plist文件用类似XML格式定义了一个命令(及启动参数)和该命令的执行方式(定时执行，系统启动执行，用户登录执行等)。我们这里不着重讨论，我们关心launchctl中如何查看/更改系统资源限制。</p><pre><code># Usage: launchctl limit [&lt;limit-name&gt; [&lt;both-limits&gt; | &lt;soft-limit&gt; &lt;hard-limit&gt;]# 查看文件描述符限制launchctl limit maxfilesmaxfiles    256            unlimited # 修改软限制为512 系统重启失效sudo launchctl limit maxfiles 512 unlimited# 可将launchctl子命令写入/etc/launchd.conf中# 在launchd启动时 会执行该文件中的命令limit maxfiles 512 unlimited</code></pre><p>通过将更改命令写入plist文件，并在启动时执行，也可永久更改资源限制：</p><ol><li><p>新建Library/LaunchDaemons/limit.maxfiles.plist文件，写入</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;          &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;    &lt;dict&gt;    &lt;key&gt;Label&lt;/key&gt;    &lt;string&gt;limit.maxfiles&lt;/string&gt;    &lt;key&gt;ProgramArguments&lt;/key&gt;    &lt;array&gt;      &lt;string&gt;launchctl&lt;/string&gt;      &lt;string&gt;limit&lt;/string&gt;      &lt;string&gt;maxfiles&lt;/string&gt;      &lt;string&gt;64000&lt;/string&gt;      &lt;string&gt;524288&lt;/string&gt;    &lt;/array&gt;    &lt;key&gt;RunAtLoad&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ServiceIPC&lt;/key&gt;    &lt;false/&gt;  &lt;/dict&gt;&lt;/plist&gt;</code></pre></li><li><p>修改文件权限</p><pre><code>sudo chown root:wheel /Library/LaunchDaemons/limit.maxfiles.plistsudo chmod 644 /Library/LaunchDaemons/limit.maxfiles.plist</code></pre></li><li><p>加载plist文件(或重启系统后生效 launchd在启动时会自动加载该目录的plist)</p><pre><code>sudo launchctl load -w /Library/LaunchDaemons/limit.maxfiles.plist</code></pre></li><li><p>确认更改后的限制</p><pre><code>launchctl limit maxfiles</code></pre></li></ol><h3 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h3><p>大多数类Unix系统都通过(Linux/*BSD/OS X)都提供该命令来更改资源限制和内核配置：</p><pre><code># 查看当前内核和进程能打开的文件描述符限制$ sysctl -A | grep kern.maxfileskern.maxfiles: 12288             # 系统级的限制kern.maxfilesperproc: 10240    # 内核级的限制# 通过sysctl命令热更改 系统重启后失效$ sysctl -w kern.maxfilesperproc=20480# 通过配置文件永久更改 重启生效# 在/etc/sysctl.conf中写入kern.maxfiles=20480 kern.maxfilesperproc=24576</code></pre><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>ulimit是shell的内置命令，用于查看/更改当前shell及其创建的子进程的资源限制。使用比较简单：</p><pre><code># 查看当前shell(及其子进程)的所有限制ulimit -a# 改变进程能打开的最大文件描述符数软限制 当shell关闭后失效# 将其写入对应shell的startup文件(如~/.bashrc, ~/.zshrc)，可保留更改ulimit -S -n 1024</code></pre><h2 id="区别联系"><a href="#区别联系" class="headerlink" title="区别联系"></a>区别联系</h2><p>这三个命令的关系在Mac OS X各版本中尤其混乱，先说说本人的一些试验(Mac OS X 10.10.3)：</p><ul><li>在默认配置下(不配置plist和sysctl.conf)，launchctl的maxfiles默认值为(256, unlimited)，sysctl的maxfiles默认值为(12288, 10240)，而ulimit -n得到的值为4864。</li><li>当不定义plist而定义sysctl.conf，那么重启后launchctl和ulimit看到的上限仍为默认值，sysctl看到的上限与sysctl.conf定义的一致。</li><li>当同时在<code>/etc/sysctl.conf</code>和<code>/Library/LaunchDaemons/limit.maxfiles.plist</code>中定义maxfiles时，plist文件中的配置会覆盖sysctl.conf中的配置。如果通过系统重启应用plist，三个命令看到的上限均为plist配置。如果通过launchctl load加载plist，则会同步影响sysctl看到的上限，而不会影响shell下的ulimit上限。</li><li>如果通过launchctl配置的软上限和硬上限分别为S和H(非unlimited)，那么通过launchctl应用配置后最终得到软上限和硬上限都为S。如果设定的上限为S和unlimited，实际上应用的参数为S和10240(sysctl中kern.maxfilesperproc默认值)，当S&gt;10240时，会设置失败，S&lt;10240时，会得到(S, 10240)</li><li><code>ulimit -H -n 1000</code> 降低硬上限无需Root权限，升高则需要</li></ul><p>趁着头大，还可以看看这几篇文章:</p><ol><li><a href="http://superuser.com/questions/827984/open-files-limit-does-not-work-as-before-in-osx-yosemite" target="_blank" rel="external">open files limit does not work as before in osx yosemite</a></li><li><a href="http://krypted.com/mac-os-x/maximum-files-in-mac-os-x/" target="_blank" rel="external">maximum files in mac os x</a></li><li><a href="http://unix.stackexchange.com/questions/108174/how-to-persist-ulimit-settings-in-osx-mavericks" target="_blank" rel="external">how to persist ulimit settings in osx mavericks</a></li><li><a href="https://docs.basho.com/riak/kv/2.2.0/using/performance/open-files-limit/#mac-os-x" target="_blank" rel="external">open files limit in max os x</a></li><li><a href="http://superuser.com/questions/302754/increase-the-maximum-number-of-open-file-descriptors-in-snow-leopard" target="_blank" rel="external">increase the maximum number of open file descriptors in snow leopard</a></li></ol><p>网上对Mac OS X各版本的解决方案各不相同，并且对这三个命令(特别是launchctl和sysctl)在资源限制上的联系与区别也没有清晰的解释。</p><p>按照我的理解和折腾出来的经验：</p><ol><li>ulimit只影响当前Shell下的进程，并且受限于kern.maxfilesperproc</li><li>如果配置了plist，那么重启后，ulimit和sysctl均会继承plist中的值</li><li>热修改sysctl上限值不会影响launchctl，而反之，launchctl会影响sysctl上限值</li></ol><p>综上，在Mac OS X 10.10(我的版本，没试过之前的)之后，使用plist是最合理的方案(但launchctl貌似只能设定一样的软限制和硬限制，如果将硬限制设为ulimited，则会使用kern.maxfilesperproc值)。在系统重启后，kern.maxfilesperproc和ulimit -n都会继承plist maxfiles的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统的资源是有限的(如CPU，内存，内核所能打开的最大文件数等)，资源限制对针对进程能使用的系统资源设定上限。防止恶意进程无限制地占用系统资源。&lt;/p&gt;
&lt;p&gt;资源限制分为两种，硬限制(Hard Limit)和软限制(Soft Limit)，软限制作用于实际进程并且可以修改
      
    
    </summary>
    
      <category term="system" scheme="http://wudaijun.com/categories/system/"/>
    
    
      <category term="system" scheme="http://wudaijun.com/tags/system/"/>
    
      <category term="macosx" scheme="http://wudaijun.com/tags/macosx/"/>
    
  </entry>
  
  <entry>
    <title>Go 常用命令</title>
    <link href="http://wudaijun.com/2017/01/go-command-notes/"/>
    <id>http://wudaijun.com/2017/01/go-command-notes/</id>
    <published>2017-01-19T16:00:00.000Z</published>
    <updated>2017-02-06T08:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><ul><li>Go版本管理: <a href="https://github.com/moovweb/gvm" target="_blank" rel="external">gvm</a>(go version manager)</li><li>GOPATH管理: <a href="https://github.com/pote/gvp" target="_blank" rel="external">gvp</a>(go version package)</li><li>依赖版本管理: <a href="https://github.com/pote/gpm" target="_blank" rel="external">gpm</a>(go package manager)</li></ul><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p>用于编译指定的源码文件或代码包以及它们的依赖包。</p><blockquote><p>import导入路径中的最后一个元素是路径名而不是包名，路径名可以和包名不一样，但同一个目录只能定义一个包(包对应的_test测试包除外)</p></blockquote><a id="more"></a><p>编译包:</p><pre><code># 当前路径方式cd src/foo &amp;&amp; go build# 包导入路径方式go build foo bar# 本地代码包路径方式go build ./src/foo</code></pre><p>go build 在编译只包含库源码文件的代码包时，只做检查性的编译，不会输出任何结果文件。如果编译的是main包，则会将编译结果放到执行命令的目录下。</p><p>编译源码文件:</p><pre><code># 指定源码文件使用文件路径# 指定的多个源码文件必须属于同一个目录(包)go build src/foo/foo1.go src/foo/foo2.go</code></pre><p>当执行以上编译时，编译命令在分析参数的时候如果发现第一个参数是Go源码文件而不是代码包时，会在内部生成一个名为“command-line-arguments”的虚拟代码包。也就是当前的foo1.go foo2.go属于”command-line-arguments”包，而不是foo包，因此除了指定的源码文件和它们所依赖的包，其它文件(如foo3.go)不会被编译。</p><p>同样，对于库源码文件，build不会输出任何结果文件。对于main包的源文件，go build要求有且只能有一个main函数声明，并将生成结果(与指定的第一个源码文件同名)放在执行该命令的当前目录下。</p><p>构建与<code>go build</code>之上的其它命令(如<code>go run</code>，<code>go install</code>)，在编译包或源码文件时，过程和特性是一样的。</p><p>常用选项:</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-v</td><td>打印出那些被编译的代码包的名字。</td></tr><tr><td>-n</td><td>打印编译期间所用到的其它命令，但是并不真正执行它们。</td></tr><tr><td>-x</td><td>打印编译期间所用到的其它命令。注意它与-n标记的区别。</td></tr><tr><td>-a</td><td>强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。</td></tr><tr><td>-work</td><td>打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。</td></tr></tbody></table><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>go run编译(通过go build)并运行命令源码文件(main package)，查看过程:</p><pre><code>go run -x -work src/main/main.go# build 临时目录WORK=/var/folders/n5/j8y6skrx1xn3_ls64gl1lrsmmp53rv/T/go-build979313546# main.go依赖foo包  先编译foo包mkdir -p $WORK/foo/_obj/mkdir -p $WORK/cd /Users/wudaijun/Work/test/src/foo/usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/compile -o $WORK/foo.a -trimpath $WORK -p foo -complete -buildid cd61b5a9f3c8eba0f3088adca894fc9bf695826b -D _/Users/wudaijun/Work/test/src/foo -I $WORK -pack ./foo.go# 在虚拟包 command-line-arguments 中编译 main.gomkdir -p $WORK/command-line-arguments/_obj/mkdir -p $WORK/command-line-arguments/_obj/exe/cd /Users/wudaijun/Work/test/src/main/usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/compile -o $WORK/command-line-arguments.a -trimpath $WORK -p main -complete -buildid 9131b7dd9f64a85bb423da7f8a7d408c089a23e8 -D _/Users/wudaijun/Work/test/src/main -I $WORK -I /Users/wudaijun/Work/test/pkg/darwin_amd64 -pack ./main.go# 链接cd ./usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/link -o $WORK/command-line-arguments/_obj/exe/main -L $WORK -L /Users/wudaijun/Work/test/pkg/darwin_amd64 -w -extld=clang -buildmode=exe -buildid=9131b7dd9f64a85bb423da7f8a7d408c089a23e8 $WORK/command-line-arguments.a# 从临时目录运行可执行文件$WORK/command-line-arguments/_obj/exe/mainCall Foo()</code></pre><p>可看到<code>go run</code>的执行结果都在WORK临时目录中完成，由于使用了<code>-work</code>选项，因此WORK目录会在<code>go run</code>执行完成后保留。<code>go run</code>只接受命令源文件而不接收包路径作为参数，并且不会在当前目录生成任何文件。</p><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>只比<code>go build</code>多干一件事：安装编译后的结果文件到指定目录。</p><h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h3><p><code>go test</code>编译指定包或源文件，并执行所在包对应的测试用例。一个符合规范的测试文件指：</p><ul><li>文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码</li><li>你必须import testing这个包</li><li>所有的测试用例函数必须是Test开头</li><li>测试用例会按照源代码中写的顺序依次执行</li><li>测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态</li><li>测试格式：<code>func TestXxx (t *testing.T)</code>,Xxx部分可以为任意的字母数字的组合，但是- - 首字母不能是小写字母[a-z]，例如Testingdiv是错误的函数名</li><li>函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息</li></ul><p>测试分为包内测试和包外测试，即测试源码文件可于被测试源码文件位于同一个包(目录)，或者测试源码文件声明的包名可以是被测试包名+”_test”后缀。</p><p>另外，可以用一些插件来辅助编写测试用例，如<a href="https://github.com/cweill/gotests/" target="_blank" rel="external">gotest</a>(支持sublime, emacs, vim)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境管理&quot;&gt;&lt;a href=&quot;#环境管理&quot; class=&quot;headerlink&quot; title=&quot;环境管理&quot;&gt;&lt;/a&gt;环境管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go版本管理: &lt;a href=&quot;https://github.com/moovweb/gvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gvm&lt;/a&gt;(go version manager)&lt;/li&gt;
&lt;li&gt;GOPATH管理: &lt;a href=&quot;https://github.com/pote/gvp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gvp&lt;/a&gt;(go version package)&lt;/li&gt;
&lt;li&gt;依赖版本管理: &lt;a href=&quot;https://github.com/pote/gpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gpm&lt;/a&gt;(go package manager)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;go-build&quot;&gt;&lt;a href=&quot;#go-build&quot; class=&quot;headerlink&quot; title=&quot;go build&quot;&gt;&lt;/a&gt;go build&lt;/h3&gt;&lt;p&gt;用于编译指定的源码文件或代码包以及它们的依赖包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;import导入路径中的最后一个元素是路径名而不是包名，路径名可以和包名不一样，但同一个目录只能定义一个包(包对应的_test测试包除外)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>CSS 笔记</title>
    <link href="http://wudaijun.com/2017/01/css-notes/"/>
    <id>http://wudaijun.com/2017/01/css-notes/</id>
    <published>2017-01-08T16:00:00.000Z</published>
    <updated>2017-10-31T06:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-选择器"><a href="#一-选择器" class="headerlink" title="一. 选择器"></a>一. 选择器</h2><h3 id="1-普通选择器"><a href="#1-普通选择器" class="headerlink" title="1. 普通选择器"></a>1. 普通选择器</h3><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>标签选择器</td><td>div</td><td>以HTML 标签类型来选择元素,又叫类型选择器</td></tr><tr><td>类选择器</td><td>.span1</td><td>以class属性值来选择元素,可在页面中出现多个</td></tr><tr><td>ID选择器</td><td>#inst</td><td>以id属性值来选择元素,在页面中只能出现一次</td></tr></tbody></table><a id="more"></a><h3 id="2-并列选择器"><a href="#2-并列选择器" class="headerlink" title="2. 并列选择器"></a>2. 并列选择器</h3><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>并列选择器</td><td>div1,span1</td><td>同时定义多个样式,即该CSS有多个名称,简化CSS书写</td></tr></tbody></table><h3 id="3-层级选择器"><a href="#3-层级选择器" class="headerlink" title="3. 层级选择器"></a>3. 层级选择器</h3><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>后代选择器</td><td>body .span1</td><td>选择指定祖先元素内的后代元素</td></tr><tr><td>直接子元素选择器</td><td>body &gt; .span1</td><td>选择指定父元素内的直接子元素</td></tr></tbody></table><p>例子:</p><pre><code>/* body .span1 影响元素E1 E2 *//* body &gt; .span1 只影响元素E2 */ &lt;body&gt;    &lt;span class=&quot;span1&quot;&gt; E1 &lt;/span&gt;    &lt;div&gt; &lt;span class=&quot;span1&quot;&gt; E2 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="4-兄弟选择器"><a href="#4-兄弟选择器" class="headerlink" title="4. 兄弟选择器"></a>4. 兄弟选择器</h3><table><thead><tr><th>类别</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>普通兄弟选择器</td><td>div ~ p</td><td>选择第一个元素后的兄弟元素,两者拥有相同的父元素</td></tr><tr><td>相邻兄弟选择器</td><td>div + p</td><td>选择第一个元素后紧跟的元素,两者拥有相同的父元素</td></tr></tbody></table><p>例子:</p><pre><code>/* div + p 影响 Three Six *//* div ~ p 影响 Three Six Seven */&lt;div&gt;    &lt;p&gt;One&lt;/p&gt;    &lt;div&gt;Two&lt;/div&gt;    &lt;p&gt;Three&lt;/p&gt;&lt;/div&gt;&lt;div&gt;    &lt;div&gt;Four&lt;/div&gt;    &lt;div&gt;&lt;p&gt;Five&lt;/p&gt;&lt;/div&gt;    &lt;p&gt;Six&lt;/p&gt;    &lt;p&gt;Seven&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="5-伪类-伪元素"><a href="#5-伪类-伪元素" class="headerlink" title="5. 伪类/伪元素"></a>5. 伪类/伪元素</h3><ul><li>伪类: 用于定义同一样式的不同状态</li><li><p>伪元素: 用来添加一些选择器的特殊效果</p><pre><code>/* 常见伪类 */a:link {color:#FF0000;} /* 未访问的链接 */a:visited {color:#00FF00;} /* 已访问的链接 */a:hover {color:#FF00FF;} /* 鼠标划过链接 */a:active {color:#0000FF;} /* 已选中的链接 */p:first-child{color:blue;} /* 改变当p作为父元素第一个子元素时的样式*/ /* 常见伪元素 */h1:before{content:url(smiley.gif);} /* 在元素内容之前插入图片 */h1:after{content:url(smiley.gif);} /* 在元素内容之后插入图片 */p:first-line {color:#ff0000;} /* 为文本的首行设置特殊样式 */p:first-letter {color:#ff0000;} /* 为文本的首字母设置特殊样式 */</code></pre></li></ul><h3 id="6-优先级"><a href="#6-优先级" class="headerlink" title="6. 优先级"></a>6. 优先级</h3><p><code>!import</code> &gt; 元素内嵌样式 &gt; ID选择器 &gt; Class选择器 &gt; 类型选择器 &gt; 父元素继承值，如果一个选择器应用的多个样式重复定义了某一属性，则样式在CSS中定义顺序越后面优先级越高。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">...</div><div class="line">h1 &#123;color: red; &#125;</div><div class="line">  .pink-text &#123; color: pink; &#125;</div><div class="line">  .blue-text &#123; color: blue; &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"orange-text"</span> <span class="attr">class</span>=<span class="string">"blue-text pink-text"</span> <span class="attr">style</span>=<span class="string">"color: white"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">应用color属性的优先级为: style="color:white" &gt; .orange-text &gt; .pink-text &gt; blue-text &gt; h1类型选择器 &gt; 从body继承color值</div><div class="line"></div><div class="line">如果对pink-text的color属性应用了!important，那么应用important的属性优先级将始终最高!</div></pre></td></tr></table></figure><h2 id="二-内外边距"><a href="#二-内外边距" class="headerlink" title="二. 内外边距"></a>二. 内外边距</h2><h3 id="1-元素结构"><a href="#1-元素结构" class="headerlink" title="1. 元素结构"></a>1. 元素结构</h3><p> <img src="/assets/image/css/css-padding-margin.gif" alt=""></p><h3 id="2-padding"><a href="#2-padding" class="headerlink" title="2. padding"></a>2. padding</h3><p>内边距，定义元素边框和元素内容之间的留白</p><ul><li>可填充背景</li><li>相邻元素的内边距会叠加(15px + 20px=35px)</li></ul><h3 id="3-margin"><a href="#3-margin" class="headerlink" title="3. margin"></a>3. margin</h3><p>外边距，元素周围生成额外的空白区。“空白区”通常是指其他元素不能出现且父元素背景可见的区域。</p><ul><li>不可填充背景</li><li>边界是完全透明的(父元素背景可见)</li><li>相邻元素的边界会被折叠15px + 20px=20px)</li></ul><p>margin可为负数，当static元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。例如：</p><pre><code>/* 元素向上移10px*/#mydiv1 {margin-top:-10px;}</code></pre><p>但如果你设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。</p><pre><code>/* #mydiv1后续元素向上移10px, #mydiv1 本身不移动 */#mydiv1 {margin-bottom:-10px;}</code></pre><p>关于负margin的更多用法: <a href="https://www.w3cplus.com/css/the-definitive-guide-to-using-negative-margins.html" target="_blank" rel="external">https://www.w3cplus.com/css/the-definitive-guide-to-using-negative-margins.html</a></p><h3 id="4-外边距合并"><a href="#4-外边距合并" class="headerlink" title="4. 外边距合并"></a>4. 外边距合并</h3><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><p>垂直外边距合并问题常见于第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距。如:</p><pre><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;title&gt;垂直外边距合并&lt;/title&gt;    &lt;style&gt;        .top{width:160px; height:50px; background:#ccf;}        .middle{width:160px; background:#cfc;}        .middle .firstChild{margin-top:20px;}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;middle&quot;&gt;        &lt;div class=&quot;firstChild&quot;&gt;我其实只是想和我的父元素隔开点距离。&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>原因：根据CSS规范，当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距会发生合并。因此firstChild和其父元素middle的上外边距重叠，并顶开了middle和top间的外边距。解决方案是为middle定义边框或者内边距。参考<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">CSS外边距合并</a>，<a href="http://www.hicss.net/use-margin-or-padding/" target="_blank" rel="external">padding or margin</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-选择器&quot;&gt;&lt;a href=&quot;#一-选择器&quot; class=&quot;headerlink&quot; title=&quot;一. 选择器&quot;&gt;&lt;/a&gt;一. 选择器&lt;/h2&gt;&lt;h3 id=&quot;1-普通选择器&quot;&gt;&lt;a href=&quot;#1-普通选择器&quot; class=&quot;headerlink&quot; title=&quot;1. 普通选择器&quot;&gt;&lt;/a&gt;1. 普通选择器&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;标签选择器&lt;/td&gt;
&lt;td&gt;div&lt;/td&gt;
&lt;td&gt;以HTML 标签类型来选择元素,又叫类型选择器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;类选择器&lt;/td&gt;
&lt;td&gt;.span1&lt;/td&gt;
&lt;td&gt;以class属性值来选择元素,可在页面中出现多个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ID选择器&lt;/td&gt;
&lt;td&gt;#inst&lt;/td&gt;
&lt;td&gt;以id属性值来选择元素,在页面中只能出现一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="web" scheme="http://wudaijun.com/categories/web/"/>
    
    
      <category term="web" scheme="http://wudaijun.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Erlang 内存问题诊断</title>
    <link href="http://wudaijun.com/2016/12/erlang-memory-debug/"/>
    <id>http://wudaijun.com/2016/12/erlang-memory-debug/</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2016-12-27T09:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过<code>erlang:memory()</code>查看节点内存占用总览，需要通过静态和动态两个维度对内存进行考核：</p><ul><li>静态: 各类内存占用比例，是否有某种类的内存占用了节点总内存的绝大部分</li><li>动态: 各类内存增长特性，如增长速度，或是否长期增长而不回收(atom除外)</li></ul><p>找出有疑似内存泄露的种类后，再进行下一步分析</p><h3 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h3><p>atom不会被GC，这意味着我们应该对atom内存增长更加重视而不是忽略。在编写代码时，尽量避免动态生成atom，因为一旦你的输入源不可靠或受到攻击(特别针对网络消息)，atom内存增长可能导致节点crash。可以考虑将atom生成函数替换为更安全的版本：</p><pre><code>list_to_atom/1 -&gt; list_to_existing_atom/1binary_to_atom/2 -&gt; binary_to_existing_atom/2binary_to_term(Bin) -&gt; binary_to_term(Bin,[safe])</code></pre><h3 id="ets"><a href="#ets" class="headerlink" title="ets"></a>ets</h3><p>ets内存占用通常是由于表过大，通过<code>ets:i().</code>查看ets表条目数，大小，占用内存等。</p><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>进程内存占用过高可能有两方面原因，进程数量过大和进程占用内存过高。针对于前者，首先找出那些没有被链接或监控的”孤儿进程”：</p><pre><code>[P || P&lt;-processes(),    [{_,Ls},{_,Ms}] &lt;- [process_info(P,[links,monitors])],    []==Ls,[]==Ms].</code></pre><p>或通过<code>supervisor:count_children/1</code>查看sup下进程数量和状态。</p><p>而如果是进程所占内存过高，则可将内存占用最高的几个进程找出来进行检查:</p><pre><code>recon:proc_count(memory, 10). % 打印占用内存最高的10个进程recon:proc_count(message_queue_len, 10). % 打印消息队列最长的10个进程</code></pre><h3 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h3><p>erlang binary大致上分为两种，heap binary(&lt;=64字节)和refc binary(&gt;64字节)，分别位于进程堆和全局堆上，进程通过ProBin持有refc binary的引用，当refc binary引用计数为0时，被GC。关于binary的详细实现，参考<a href="http://wudaijun.com/2015/12/erlang-datastructures/">Erlang常用数据结构实现</a>。</p><p>recon提供的关于binary问题检测的函数有：</p><pre><code>% 打印出引用的refc binary内存最高的N个进程recon:proc_count(binary_memory, N)% 对所有进程执行GC 打印出GC前后ProcBin个数减少数量最多的N个进程recon:bin_leak(N)</code></pre><p>以上两个函数，通常可以找出有问题的进程，然后针对进程的业务逻辑和上下文进行优化。通常来说，针对于refc binary，有如下思路：</p><ul><li>每过一段时间手动GC(高效，不优雅)</li><li>如果只持有大binary中的一小段，用<code>binary:copy/1-2</code>(减少refc binary引用)</li><li>将涉及大binary的工作移到临时一次性进程中，做完工作就死亡(变相的手动GC)</li><li>对非活动进程使用hibernate调用(该调用将进程挂起，执行GC并清空调用栈，在收到消息时再唤醒)</li></ul><p>一种典型地binary泄露情形发生在当一个生命周期很长的中间件当作控制和传递大型refc binary消息的请求控制器或消息路由器时，因为ProcBin仅仅只是个引用，因此它们成本很低而且在中间件进程中需要花很长的时间去触发GC，所以即使除了中间件其他所有进程都已经GC了某个refc binary对应的ProcBin，该refc binary也需要保留在共享堆里。因此中间件进程成为了主要的泄漏源。</p><p>针对这种情况，有如下解决方案：</p><ul><li>避免中间件接触到refc binary，由中间件进程返回目标进程的Pid，由原始调用者来进行binary转发</li><li>调整中间件进程的GC频率(fullsweep_after)</li></ul><h3 id="driver-nif"><a href="#driver-nif" class="headerlink" title="driver/nif"></a>driver/nif</h3><p>另一部分非Erlang虚拟机管制的内存通常来自于第三方Driver或NIF，要确认是否是这部分内存出了问题，可通过<code>recon_alloc:memory(allocated).</code>和OS所报告的内存占用进行对比，可以大概得到C Driver或NIF分配的内存，再根据该部分内存的增长情况和占用比例来判断是否出现问题。</p><p>如果是纯C，那么内存使用应该是相对稳定并且可预估的，如果还挂接了Lua这类动态语言，调试起来要麻烦一些，在我们的服务器中，Lua部分是无状态的，可以直接重新加载Lua虚拟机。其它的调试手段，则要透过Lua层面的GC机制去解决问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;code&gt;erlang:memory()&lt;/code&gt;查看节点内存占用总览，需要通过静态和动态两个维度对内存进行考核：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态: 各类内存占用比例，是否有某种类的内存占用了节点总内存的绝大部分&lt;/li&gt;
&lt;li&gt;动态: 各类内存增长特性，如增长
      
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Erlang Unicode编码</title>
    <link href="http://wudaijun.com/2016/12/unicode-in-erlang/"/>
    <id>http://wudaijun.com/2016/12/unicode-in-erlang/</id>
    <published>2016-12-16T16:00:00.000Z</published>
    <updated>2017-02-22T02:45:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unicode基础"><a href="#Unicode基础" class="headerlink" title="Unicode基础"></a>Unicode基础</h2><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>定义字符集中每个字符的<strong>codepoint(数字编码)</strong></p><ul><li>ASCII: 不用多说，编码空间为7位(0-127)</li><li><a href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="external">ISO 8859-1</a>: 又称Latin-1，以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号。编码空间为8位(0-255)</li><li>UCS-2: 16位编码空间 又称基本多文种平面或零平面</li><li>UCS-4: 32位编码空间 在UCS-2基本上，加入辅助平面(目前有16个辅助平面，至少需要21位)</li><li>注1: UCS(Universal Character Set, <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="external">通用字符集</a>)</li><li>注2: 以上四种编码都是向前兼容的，通常我们所说的Unicode编码指UCS-2和UCS-4，目前广泛运用的是UCS-2</li></ul><a id="more"></a><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>实现方式将字符的数字编码存储在计算机字节中，由于节省空间和平台差异性等，衍生不同的实现方式</p><ul><li><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">UTF-8</a>: 一种变长编码，使用1-3个字节编码UCS-2字符集，1-6个字节可编码UCS-4字符集(目前只用最多四个字节即可表示UCS-4所定义的17个平面)。优点是兼容ASCII，节省空间，并且不存在字节序的问题</li><li><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="external">UTF-16</a>: 和UTF-8类似，使用2个字节来编码UCS-2字符集(UCS-2中有预留的位用于实现UTF-16扩展多字节)，使用4个字节来编码UCS-4字符集。由于使用两个字节作为基本编码单位，UTF-16存在字节序的问题，通常使用BOM来解决</li><li><a href="https://zh.wikipedia.org/wiki/UTF-32" target="_blank" rel="external">UTF-32</a>: 32位定长编码，能够表示UCS-4字符集所有字符，但空间占用大，因此很少见</li><li>注1: UTF(Unicode Transformation Format, Unicode转换格式)</li><li>注2: BOM(byte-order mark, <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank" rel="external">字节顺序标记</a>)</li></ul><h2 id="Erlang中的Unicode"><a href="#Erlang中的Unicode" class="headerlink" title="Erlang中的Unicode"></a>Erlang中的Unicode</h2><h3 id="Unicode表示"><a href="#Unicode表示" class="headerlink" title="Unicode表示"></a>Unicode表示</h3><pre><code>%% 环境 Mac OSX Yosemite &amp; Erlang OTP/19Eshell V8.1  (abort with ^G)1&gt; L = &quot;中文&quot;.[20013,25991] % Erlang lists存放的是字符的Unicode编码2&gt; B = &lt;&lt;&quot;中文&quot;&gt;&gt;.&lt;&lt;45,135&gt;&gt; % Erlang只知&quot;中文&quot;的Unicode编码[20013,25991]，并不知应该用何种实现方式(UTF8或其他)，默认它会将Unicode编码 rem 256，产生0-255间的编码(并按照Lantin-1解码)% 下面我们将考虑将&quot;中文&quot;转换为binary% 方案一. erlang:list_to_binary -&gt; error3&gt; list_to_binary(L). % 该函数支持的list只能是iolist(见后面术语参考)，否则Erlang并不知道你想将字符串转换为何种编码格式的binary** exception error: bad argument     in function  list_to_binary/1        called as list_to_binary([20013,25991])% 方案二. unicode:characters_to_binary -&gt; ok4&gt; UTF8 = unicode:characters_to_binary(L).% 将L中的unicode编码转换为UTF8 binary&lt;228,184,173,230,150,135&gt;&gt;5&gt; UTF16Big = unicode:characters_to_binary(UTF8,utf8,utf16).&lt;&lt;78,45,101,135&gt;&gt; % 默认为Big Endian6&gt; UTF16Little = unicode:characters_to_binary(UTF8,utf8,{utf16,little}).&lt;&lt;45,78,135,101&gt;&gt;% 方案三. 利用binary构造语法构建7&gt; UTF8 = &lt;&lt;&quot;中文&quot;/utf8&gt;&gt;.&lt;&lt;228,184,173,230,150,135&gt;&gt;8&gt; UTF8 = &lt;&lt;L/utf8&gt;&gt;. % Why ?** exception error: bad argument</code></pre><p>在Erlang中，字符串就是整数列表，并且这个整数可以无限大，lists将保存其中每个字符的Unicode编码，只要lists中的整数是有效的Unicode codepoint，就可以找到对应的字符。因此也就不存在UTF8/UTF16格式的lists字符串一说。而binary的处理则要麻烦一些，Erlang用UTF8作为Unicode在binary上的实现方式，unicode模块提供了这方面丰富的unicode编码处理接口。</p><h3 id="Unicode使用"><a href="#Unicode使用" class="headerlink" title="Unicode使用"></a>Unicode使用</h3><pre><code>8&gt; io:format(&quot;~s&quot;, [L]).** exception error: bad argument in function  io:format/3    called as io:format(&lt;0.50.0&gt;,&quot;~s&quot;,[[20013,25991]])9&gt; io:format(&quot;~p&quot;, [L]).[20013,25991]ok10&gt; io:format(&quot;~ts&quot;, [L]).中文ok11&gt; io:format(&quot;~s&quot;, [UTF8]).ä¸­æok12&gt; io:format(&quot;~p&quot;, [UTF8]).&lt;&lt;228,184,173,230,150,135&gt;&gt;ok13&gt; io:format(&quot;~ts&quot;, [UTF8]).中文ok</code></pre><p>先解释几个Erlang术语：</p><ul><li><a href="http://www.cnblogs.com/me-sa/archive/2012/01/31/erlang0034.html" target="_blank" rel="external">iolist</a>: 0-255编码(Latin-1)的lists，binary，或它们的嵌套，如<code>[[&quot;123&quot;,&lt;&lt;&quot;456&quot;&gt;&gt;],&lt;&lt;&quot;789&quot;&gt;&gt;]</code></li><li>unicode binary: UTF8编码的binary(Erlang默认使用UTF8 binary编码unicode)</li><li>charlist: UTF8编码的binary，或包含有效unicode codepoint的lists，或它们的嵌套，如<code>[&lt;&lt;&quot;hello&quot;&gt;&gt;, &quot;中国&quot;]</code></li></ul><p><code>~s</code>只能打印iolist，binary，或atom，因此不能直接打印中文lists(无法解码超过255的codepoint)或UTF8 binary(会按字节解释，出现乱码)。</p><p><code>~ts</code>则可打印charlist和unicode binary。</p><p><code>~p</code>如果不能打印出ASCII(0-127)字符，则直接打印出原生Term，不会对Unicode编码进行处理。</p><p>参考：</p><ol><li><a href="http://erlang.org/doc/man/unicode.html" target="_blank" rel="external">http://erlang.org/doc/man/unicode.html</a></li><li><a href="http://erlang.org/doc/apps/stdlib/unicode_usage.html" target="_blank" rel="external">http://erlang.org/doc/apps/stdlib/unicode_usage.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Unicode基础&quot;&gt;&lt;a href=&quot;#Unicode基础&quot; class=&quot;headerlink&quot; title=&quot;Unicode基础&quot;&gt;&lt;/a&gt;Unicode基础&lt;/h2&gt;&lt;h3 id=&quot;编码方式&quot;&gt;&lt;a href=&quot;#编码方式&quot; class=&quot;headerlink&quot; title=&quot;编码方式&quot;&gt;&lt;/a&gt;编码方式&lt;/h3&gt;&lt;p&gt;定义字符集中每个字符的&lt;strong&gt;codepoint(数字编码)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASCII: 不用多说，编码空间为7位(0-127)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/ISO/IEC_8859-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ISO 8859-1&lt;/a&gt;: 又称Latin-1，以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号。编码空间为8位(0-255)&lt;/li&gt;
&lt;li&gt;UCS-2: 16位编码空间 又称基本多文种平面或零平面&lt;/li&gt;
&lt;li&gt;UCS-4: 32位编码空间 在UCS-2基本上，加入辅助平面(目前有16个辅助平面，至少需要21位)&lt;/li&gt;
&lt;li&gt;注1: UCS(Universal Character Set, &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;通用字符集&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;注2: 以上四种编码都是向前兼容的，通常我们所说的Unicode编码指UCS-2和UCS-4，目前广泛运用的是UCS-2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>探索Docker在Erlang集群中的应用</title>
    <link href="http://wudaijun.com/2016/11/docker-erlang/"/>
    <id>http://wudaijun.com/2016/11/docker-erlang/</id>
    <published>2016-11-04T16:00:00.000Z</published>
    <updated>2016-11-14T08:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>接<a href="http://0.0.0.0:4444/2016/11/docker-basic/" target="_blank" rel="external">上篇</a>，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。</p><h2 id="简单Docker交互"><a href="#简单Docker交互" class="headerlink" title="简单Docker交互"></a>简单Docker交互</h2><p>下面是个简单的echo server：</p><pre><code>-module(server_echo).-export([start/0]).start() -&gt;     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),     {ok, Listen} = gen_tcp:listen(2345, [ binary                                         , {packet, 0}                                         , {reuseaddr, true}                                         , {active, true}                                         ]),     io:format(&quot;SERVER Listening on port 2345\n&quot;),     accept(Listen). accept(Listen) -&gt;     {ok, Socket} = gen_tcp:accept(Listen),     WorkerPid = spawn(fun() -&gt; echo(Socket) end),     gen_tcp:controlling_process(Socket, WorkerPid),     accept(Listen). echo(Socket) -&gt;     receive         {tcp, Socket, Bin} -&gt;             io:format(&quot;SERVER Received: ~p\n&quot;, [Bin]),             gen_tcp:send(Socket, Bin),             echo(Socket);         {tcp_closed, Socket} -&gt;             io:format(&quot;SERVER: The client closed the connection\n&quot;)     end.</code></pre><p>简单起见，我们直接用<code>telnet</code>命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。</p><a id="more"></a><h3 id="容器中运行"><a href="#容器中运行" class="headerlink" title="容器中运行"></a>容器中运行</h3><pre><code>sudo docker run -it --rm -v ~/docker:/code -w /code erlang erlErlang/OTP 19 [erts-8.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.1  (abort with ^G)1&gt; c(server_echo).{ok,server_echo}2&gt; server_echo:start().SERVER Trying to bind to port 2345SERVER Listening on port 2345</code></pre><p>在<code>docker run</code>中，我们将本地代码路径挂载到容器的/code目录，并且将/code作为容器的工作目录，此后对本地代码的修改，将直接反映在容器中，而无需拷贝。运行容器后会进入erl shell，并且当前路径(/code)即为本地代码路径(~/docker)，之后编译运行server即可。</p><h3 id="宿主机访问容器"><a href="#宿主机访问容器" class="headerlink" title="宿主机访问容器"></a>宿主机访问容器</h3><p>如下方案可以让宿主机能访问容器端口：</p><ul><li>在<code>docker run</code>中指定<code>-p 2345:2345</code>导出2345端口，之后访问宿主机的2345端口等同于访问容器2345端口</li><li>在<code>docker run</code>中指定<code>--network host</code>使容器和宿主机共享网络栈，IP和端口</li><li>通过<code>docker inspect</code>查询容器IP地址(如:<code>172.17.0.2</code>)，可在宿主机上通过该IP访问容器</li></ul><h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器间交互方式主要有三种：</p><ul><li>通过<code>docker inspect</code>得到容器IP地址，通过IP地址进行容器间的交互</li><li>通过<code>docker run</code>中指定<code>--network container:&lt;name or id&gt;</code>，将新创建的容器与一个已经存在的容器的共享网络栈，IP和端口</li><li>通过<code>docker run</code>的<code>--link &lt;name or id&gt;</code>选项链接两个容器，之后可以将容器名或容器ID作为Hostname来访问容器，注意<code>--link</code>选项仅在<code>--network bridge</code>下有效</li></ul><h3 id="定义Dockerfile"><a href="#定义Dockerfile" class="headerlink" title="定义Dockerfile"></a>定义Dockerfile</h3><p>前面我是通过挂载目录的方式将本地代码映射到容器中，这种方式在本地开发中比较方便，但是在项目部署或环境配置比较复杂时，我们需要通过Dockerfile来构建自己的镜像(而不是基于官方Erlang镜像)，初始化项目环境，就本例而言，Dockerfile非常简单：</p><pre><code>FROM erlangRUN mkdir codeCOPY server_echo.erl code/server_echo.erlRUN cd code &amp;&amp; erlc server_echo.erlWORKDIR /codeENTRYPOINT [&quot;erl&quot;, &quot;-noshell&quot;, &quot;-run&quot;, &quot;server_echo&quot;, &quot;start&quot;]</code></pre><h2 id="Erlang多节点通信"><a href="#Erlang多节点通信" class="headerlink" title="Erlang多节点通信"></a>Erlang多节点通信</h2><h3 id="再谈Erlang分布式通信"><a href="#再谈Erlang分布式通信" class="headerlink" title="再谈Erlang分布式通信"></a>再谈Erlang分布式通信</h3><p>Erlang的分布式节点有自己的通信机制，这套通信机制对上层用户是透明的，我们只需一个节点名(<code>node@host</code>)，即可访问这个节点，而无需关心这个节点是在本机上还是在其它主机上。在这之上封装的Pid，进一步地屏蔽了节点内进程和跨节点进程的差异。</p><p>在<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>中，我提到了Erlang的分布式设施，其中epmd扮演着重要的角色：它维护了本机上所有节点的节点名到节点监听地址的映射，并且由于epmd进程本身的监听端口在集群内是周知的(默认为4369)，因此可以根据节点名<code>node@host</code>得到节点所在主机上epmd的监听地址(<code>host:4369</code>)，进而从epmd进程上查询到节点名<code>node</code>所监听的地址，实现节点间通信。</p><h3 id="在同主机不同容器中部署集群"><a href="#在同主机不同容器中部署集群" class="headerlink" title="在同主机不同容器中部署集群"></a>在同主机不同容器中部署集群</h3><p>现在回到Docker，我们先尝试在同一个主机，不同容器上建立集群：</p><pre><code># 容器A 启动后通过docker inspect查询得到IP地址: 172.17.0.2sudo docker run -it erlang /bin/bashroot@4453d880b5a5:/# erl -name n1@172.17.0.2 -setcookie 123Eshell V8.1  (abort with ^G)(n1@172.17.0.2)1&gt; # 容器B 启动后通过docker inspect查询得到IP地址: 172.17.0.4sudo docker run -it erlang /bin/bashroot@dd0f30178036:/# erl -name n2@172.17.0.4 -setcookie 123Eshell V8.1  (abort with ^G)(n2@172.17.0.4)1&gt; net_kernel:connect_node(&apos;n1@172.17.0.2&apos;).true(n2@172.17.0.4)2&gt; nodes().[&apos;n1@172.17.0.2&apos;]</code></pre><p>和在宿主机上一样，我们可以直接通过容器IP架设集群。这里使用的是<code>-name node@host</code>指定的longname，而如果使用shortname：</p><pre><code># 容器Aroot@4453d880b5a5:/# erl -sname n1 -setcookie 123Eshell V8.1  (abort with ^G)(n1@4453d880b5a5)1&gt;# 容器Broot@dd0f30178036:/# erl -sname n2 -setcookie 123Eshell V8.1  (abort with ^G)(n2@dd0f30178036)1&gt; net_kernel:connect_node(&apos;n1@4453d880b5a5&apos;).false</code></pre><p>在shortname方案中，我们并不能通过nodename访问节点，本质上是因为<code>n2</code>节点不能通过<code>4453d880b5a5:4369</code>访问到<code>n1</code>节点所在主机上的epmd进程。我们测试一下网络环境：</p><pre><code># 通过容器A名字pingping 4453d880b5a5ping: unknown host# 直接ping容器A IPping 172.17.0.2PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.099 ms64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.089 ms</code></pre><p>发现是hostname解析出了问题，容器链接来解决这个问题：</p><pre><code># 重新启动容器B 并链接到容器Adocker run -it --link 4453d880b5a5 erlang /bin/bashroot@7692c8c71218:/# erl -sname n2 -setcookie 123Eshell V8.1  (abort with ^G)(n2@dd0f30178036)1&gt; net_kernel:connect_node(&apos;n1@4453d880b5a5&apos;).true</code></pre><p>有个有趣的问题是，当容器B link了容器A，那么容器B能通过容器A的Id或名字访问容器B，而反过来，容器A却不能以同样的方式访问容器B。也就是说link是单向的，这同样可以通过ping来验证。</p><h3 id="在不同的主机上部署集群"><a href="#在不同的主机上部署集群" class="headerlink" title="在不同的主机上部署集群"></a>在不同的主机上部署集群</h3><p>在不同的主机上部署集群，问题开始变得复杂：</p><ol><li>不同的主机上的Docker容器处于不同的子网(一台主机对应一个子网)，因此不同主机上的容器不能直接访问，需要先发布(publish)Erlang节点监听端口</li><li>Erlang节点在Docker容器中的监听地址是由Erlang VM启动时分配的，因此我们无法在启动容器时就获知Erlang节点监听端口(从而发布该端口)</li><li>假定我们预配置了Erlang节点的监听端口xxx，如果我们使用<code>-p xxx:xxx</code>将可能导致端口争用(亦即一台物理机只能运行一个Docker容器)，如果我们使用<code>-p xxx</code>将该端口发布到主机任意一个端口，那么这个发布的主机端口，将只能通过Docker Daemon获取到(命令行下可通过<code>docker port</code>查看)</li><li>再来看epmd，每个Docker容器中都会跑一个epmd进程，它记录的是节点名到<strong>节点在容器中的监听地址</strong>，因此，epmd本身返回的地址是不能直接被其它主机上的节点使用的</li></ol><h4 id="Erlang-In-Docker"><a href="#Erlang-In-Docker" class="headerlink" title="Erlang In Docker"></a>Erlang In Docker</h4><p>基于上面的种种限制，有人给出了一套解决方案：<a href="https://github.com/Random-Liu/Erlang-In-Docker" target="_blank" rel="external">Erlang In Docker</a>。这套方案对Erlang集群做了如下制约：</p><ol><li>每个Docker容器只能运行一个Erlang节点</li><li>预配置Erlang节点的监听端口</li><li>Erlang节点名格式为<code>DockerContainerID@HostIP</code></li><li>使用Docker Daemon而不是epmd来获取节点监听端口</li></ol><p>这套方案的核心思路是用Docker Daemon替换epmd做节点监听的服务发现，原因有二：</p><ul><li>Docker Daemon运行于主机同级网络中</li><li>维护了容器端口和主机端口的映射关系</li></ul><p>如果节点A想要访问节点B，则节点A需要提供：</p><ul><li>节点B所在主机地址: Host</li><li>节点B所在主机上Docker Daemon的监听端口: DaemonPort</li><li>节点B所在容器ID: ContainerID</li><li>节点B在所在容器中的监听端口: Port0</li></ul><p>之后就可以通过Docker Daemon(<code>Host:DaemonPort</code>)查询到<code>ContainerID</code>容器的<code>Port0</code>端口在主机上对应的发布端口<code>Port1</code>，之后节点A即可通过<code>Host:Port1</code>与节点B通信。</p><p>然而节点A只有节点B的名字，要在节点B中编码这四条信息是非常困难的，因此Erlang In Docker的做法是，预配置Port0(12345)和DaemonPort(4243)，剩下的主机地址和容器ID则编码在节点名中：<code>DockerContainerID@HostIP</code>。</p><p>EID代码并不复杂，得益于Erlang可替换的分布式通信协议，EID只自定义了<code>eid_tcp_dist</code>(替换默认的<code>inet_tcp_dist</code>模块)和dpmd(通过与Docker Daemon交互模拟epmd的功能)两个模块。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>将Erlang应用到Docker上比较困难的主要原因是Erlang已经提供了非常完备的分布式设施(参见<a href="http://wudaijun.com/2016/03/erlang-distribution-2/">Erlang分布式系统(2)</a>)，并且这一套对上层都是透明的。EID这套方案看起来限制很多，但细想也没多大问题，具体还要看在生产环境中的表现，目前我比较顾虑它的通信效率(NAT)和<code>eid_tcp_dist</code>是否足够健壮。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接&lt;a href=&quot;http://0.0.0.0:4444/2016/11/docker-basic/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上篇&lt;/a&gt;，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。&lt;/p&gt;
&lt;h2 id=&quot;简单Docker交互&quot;&gt;&lt;a href=&quot;#简单Docker交互&quot; class=&quot;headerlink&quot; title=&quot;简单Docker交互&quot;&gt;&lt;/a&gt;简单Docker交互&lt;/h2&gt;&lt;p&gt;下面是个简单的echo server：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-module(server_echo).
-export([start/0]).

start() -&amp;gt;
     io:format(&amp;quot;SERVER Trying to bind to port 2345\n&amp;quot;),
     {ok, Listen} = gen_tcp:listen(2345, [ binary
                                         , {packet, 0}
                                         , {reuseaddr, true}
                                         , {active, true}
                                         ]),
     io:format(&amp;quot;SERVER Listening on port 2345\n&amp;quot;),
     accept(Listen).

 accept(Listen) -&amp;gt;
     {ok, Socket} = gen_tcp:accept(Listen),
     WorkerPid = spawn(fun() -&amp;gt; echo(Socket) end),
     gen_tcp:controlling_process(Socket, WorkerPid),
     accept(Listen).

 echo(Socket) -&amp;gt;
     receive
         {tcp, Socket, Bin} -&amp;gt;
             io:format(&amp;quot;SERVER Received: ~p\n&amp;quot;, [Bin]),
             gen_tcp:send(Socket, Bin),
             echo(Socket);
         {tcp_closed, Socket} -&amp;gt;
             io:format(&amp;quot;SERVER: The client closed the connection\n&amp;quot;)
     end.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单起见，我们直接用&lt;code&gt;telnet&lt;/code&gt;命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。&lt;/p&gt;
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习</title>
    <link href="http://wudaijun.com/2016/11/docker-basic/"/>
    <id>http://wudaijun.com/2016/11/docker-basic/</id>
    <published>2016-10-31T16:00:00.000Z</published>
    <updated>2017-11-21T13:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-理解-Docker"><a href="#一-理解-Docker" class="headerlink" title="一. 理解 Docker"></a>一. 理解 Docker</h2><p>Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：</p><ul><li>隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势</li><li>一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。</li></ul><a id="more"></a><p>Docker和其它虚拟机或容器技术相比，一是轻量，开销很小，二是发展迅速， 平台兼容性增长很快。虽然Docker的应用场景很多，但都是基于虚拟化和容器技术的这两种特性在特定问题下提出的解决方案。</p><p>下面来看看Docker的基本概念：</p><ol><li>Docker是C/S模式的，包括docker CLI和docker daemon两部分，它们之间通过RESTful API交互，Docker CLI就是我们用的docker命令</li><li>镜像(Image)：是一个只读的模板，包含了系统和运行程序，是用于创建容器的一系列指令(Dockfile)，相当于一份虚拟机的磁盘文件。</li><li>容器(Container)：当镜像启动后就转化为容器，容器是运行着的镜像，在容器内的修改不会影响镜像，程序的写入操作都保存在容器中。容器可被启动，停止和删除，由docker daemon管理。</li><li>仓库(Registry)：Docker镜像可通过公有和私有的仓库来进行共享和分发，仓库是存放和分享镜像文件的场所，功能类似于Github。Docker仓库有免费的<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>和付费的<a href="https://store.docker.com/" target="_blank" rel="external">Docker Store</a>。</li></ol><h2 id="二-Docker-容器"><a href="#二-Docker-容器" class="headerlink" title="二. Docker 容器"></a>二. Docker 容器</h2><h3 id="1-容器操作"><a href="#1-容器操作" class="headerlink" title="1. 容器操作"></a>1. 容器操作</h3><p>通常我们都使用docker CLI和docker daemon交互完成docker操作，随着docker日渐完善，docker所提供的功能和参数也更复杂，以下只列举几个常用的。</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>从镜像中创建并启动容器，常用Options有：</p><ul><li><code>-d</code>：后台运行</li><li><code>-t</code>：为容器分配一个伪终端，通常于-i一起使用</li><li><code>-i</code>：以交互模式运行容器，如果开了-i而没有指定-t，可以通过管道与容器交互</li><li><code>-v</code>：为容器挂载目录，冒号前为宿主机目录，其后为容器目录</li><li><code>-p</code>： [hip:]hport:cport 端口映射，将容器端口绑定到指定主机端口</li><li><code>--name</code>：为容器命名</li><li><code>--link</code>：链接到其它容器，之后可通过容器ID或容器名访问该容器(只针对bridge)</li><li><code>--ip</code>：指定容器的IP</li><li><code>--network</code>：配置容器的网络</li><li><code>--rm</code>：当容器退出时，删除容器</li></ul><p>完整的命令可通过<code>docker run --help</code>查看。</p><p>例如：</p><pre><code>docker run -it ubuntu:14.04 /bin/bash </code></pre><p>我们就以<code>ubuntu:14:04</code>镜像启动了一个容器，并进入到bash交互模式。docker所做的事情为，先在本地查找ubuntu镜像，如果没有，将从<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>中拉取到本地，解析镜像文件，创建容器，并运行<code>/bin/bash</code>命令。</p><p>每个容器在创建时，docker daemon都会为其生成一个Container ID，容器在运行结束后，为<code>STOP</code>状态，可以通过Container ID或容器名字再次启动/停止或删除。可通过<code>docker ps</code>来查看容器状态。以下是其它常用的容器管理命令：</p><pre><code>// 查看容器， 默认只显示运行中的容器，-a选项可显示所有容器docker ps [OPTIONS]// 启动容器docker start/stop [OPTIONS] CONTAINER [CONTAINER...]// 停止容器docker rm CONTAINER// 把后台容器调到前端docker attach [OPTIONS] CONTAINER// 查询容器的详细信息，也可用于镜像docker inspect [OPTIONS] CONTAINER/IMAGE// 在容器内执行指定命令 如:  docker exec -it CONTAINER bashdocker exec [OPTIONS] CONTAINER COMMAND [ARG...]也可使用第三方工具如nsenter来进入容器</code></pre><h3 id="2-容器持久化"><a href="#2-容器持久化" class="headerlink" title="2. 容器持久化"></a>2. 容器持久化</h3><p>镜像是分层存储的，容器也一样，每一个容器以镜像为基础层，在其上构建一个当前容器的可读可写层，容器对文件的所有更改都基于这一层。容器的可读可写层的生命周期与容器一样，当容器消亡时，容器在可读可写层作出的任何更改都将丢失(容器不能对基础镜像作出任何更改)。</p><p>有几种方式可以持久化容器作出的更改:</p><ol><li>通过<code>docker commit</code>以镜像构建的方式将可读可写层提交为一个新的镜像(<code>docker commit</code>是<code>docker run</code>的逆操作)。这种方式并不推荐，因为手动commit构建的镜像没有Dockerfile说明，是”隐晦”的，使用者并不知道你对镜像作出了何种修改。</li><li>在运行容器时指定<code>docker run -v hostdir:containerdir</code>来将宿主机上的某个目录挂载到容器的指定目录下，这样容器对该目录作出的所有更改，都直接写入到宿主机上，效率也更高。这通常用于在容器中导出应用日志和数据，这样容器消亡后，日志和数据信息不会丢失。</li><li>通过网络IO，将数据持久化到其它地方，如mongo，redis等。</li></ol><p>我们在运行容器时，要尽量保证容器的运行是”无状态”的，即容器可以随时被终止而重要数据不会丢失。</p><h2 id="三-Docker-镜像"><a href="#三-Docker-镜像" class="headerlink" title="三. Docker 镜像"></a>三. Docker 镜像</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1. Dockerfile"></a>1. Dockerfile</h3><p>Docker的镜像通过一个Dockerfile构建，我们可以通过编Dockerfile来创建自定义镜像：</p><pre><code># 这是注释INSTRUCTION args</code></pre><p>Dockerfile不区分大小写，但惯例是将指令大写，下面介绍几个Dockerfile中常用的指令：</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>FROM命令必须是Dockerfile的第一条指令，用于指明基础镜像(镜像基础层)：</p><pre><code># 格式：FROM &lt;image&gt;[:&lt;tag&gt;]FROM ubuntu:14:04FROM erlang</code></pre><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>在当前镜像的顶层执行命令(比如安装一个软件包)，将执行结果commit到当前镜像层。</p><p>RUN有两种格式：</p><pre><code># shell 格式，相当于 /bin/sh -c &lt;command&gt;# 意味着可以访问shell环境变量 如$HOMERUN &lt;command&gt;# exec 格式，推荐格式，直接执行命令，不会打开shell# 这种格式更灵活，强大RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# 以下两种写法完全等价RUN echo &quot;hello&quot;RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></pre><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD指令的主要目的是为容器提供默认值，这些默认值可以包含容器执行入口和参数，也可以只指定参数，这种情况下，容器入口由ENTRYPOINT指出。CMD有三种定义方式：</p><pre><code># exec 格式 指定了执行入口和参数# 可被docker run &lt;image&gt;后的参数覆盖CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]# 当ENTRYPOINT存在时，exec格式退化为默认参数格式# 此时CMD提供的参数将被附加到ENTRYPOINT指定的入口上# 可被docker run &lt;image&gt;后的参数覆盖CMD [&quot;param1&quot;, &quot;param2&quot;]# shell 格式 这种格式不能为ENTRYPOINT提供默认参数  只能提供默认执行入口# 会被ENTRYPOINT或docker run &lt;image&gt;指定的入口覆盖CMD command param1 param2</code></pre><p>Dockerfile中只能有一个CMD命令(如果有多个，只有最后一个生效)，如果CMD要作为ENTRYPOINT的默认参数(即第二种定义方式)，那么CMD和ENTRYPOINT都必须以Json数组的方式指定。</p><p>CMD和RUN的区别：RUN在<code>docker build</code>构建镜像时执行，将执行结果写入新的镜像层(实际上也是通过容器写入的，详见后面<code>docker build</code>命令)，而CMD在<code>docker run</code>时执行，执行结果不会写入镜像。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>ENTRYPOINT用于设置在容器启动时执行命令，ENTRYPOINT有两种定义方式：</p><pre><code># exec格式 推荐格式ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# shell格式 以这种方式定义，CMD和docker run提供的参数均不能附加给command命令参数ENTRYPOINT command param1 param2</code></pre><p><code>docker run &lt;image&gt;</code>后面的参数将会附加在ENTRYPOINT指定的入口上，如：</p><pre><code>FROM ubuntu:14.04ENTRYPOINT [&quot;echo&quot;, &quot;hello&quot;]CMD [&quot;world&quot;]</code></pre><p>构建镜像<code>docker build -t echo_img .</code>，之后如果我们以<code>docker run --rm echo_img</code>启动容器，CMD指定的默认参数将附加在ENTRYPOINT的入口上，因此相当于执行<code>echo hello world</code>。而如果我们以<code>docker run --rm echo_img wudaijun</code>启动容器，此时<code>docker run</code>提供的参数将覆盖CMD指定的默认参数，相当于执行<code>echo hello wudaijun</code>。</p><p>再举个例子：</p><pre><code>FROM ubuntu:14.04CMD [&quot;echo&quot;, &quot;hello&quot;]</code></pre><p>由于没有指定ENTRYPOINT，因此CMD指定了默认的执行入口<code>echo hello</code>，如果<code>docker run &lt;image&gt;</code>未指定任何参数，则执行<code>echo hello</code>，否则<code>docker run &lt;image&gt;</code>的参数将覆盖CMD指定的执行入口。如果我们再加上Dockerfile中再加一行<code>ENTRYPOINT [&quot;echo&quot;]</code>，并且<code>docker run &lt;image&gt;</code>后未指定参数，那么将执行<code>echo echo hello</code>，输出<code>echo hello</code>。</p><p>和CMD一样，ENTRYPOINT在Dockerfile中最多只能生效一个，如果定义了多个，只有最后一个生效，在docker run中可通过<code>docker run --entrypoint</code>覆盖ENTRYPOINT。</p><p>CMD和ENTRYPOINT的区别：CMD和ENTRYPOINT都可用于设置容器执行入口，但CMD会被<code>docker run &lt;image&gt;</code>后的参数覆盖；而ENTRYPOINT会将其当成参数附加给其指定的命令（不会对命令覆盖）。另外CMD还可以单独作为ENTRYPOINT的所接命令的可选参数。如果容器是Execuatble的，通常用法是，用ENTRYPOINT定义不常变动的执行入口和参数(exec格式)，用CMD提供额外默认参数(exec格式)，再用<code>docker run &lt;image&gt;</code>提供的参数来覆盖CMD。另外，ENTRYPOINT指定的入口也可以是shell script，用于实现更灵活的容器交互。</p><p>ENTRYPOINT，CMD，RUN在定义时，均推荐使用Json数组方式。参见<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices" target="_blank" rel="external">Dockerfile Best Practices</a></p><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><pre><code>ENV: 定义环境变量，该变量可被后续其它指令引用，并且在生成的容器中同样有效ADD: src dst 将本地文件拷贝到镜像，src可以是文件路径或URL，ADD支持自动解压tar文件COPY: 和ADD类似，但不支持URL并且不能自动解压EXPOSE: port, 指定容器在运行时监听的端口WORKDIR: path, 指定容器的工作目录(启动之后的当前目录)VOLUME: [path], 在容器中设置一个挂载点，用于挂载宿主机或其它容器的目录 </code></pre><p>关于Dockerfile的语法参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile Reference</a>。</p><h3 id="2-docker-build-原理"><a href="#2-docker-build-原理" class="headerlink" title="2. docker build 原理"></a>2. docker build 原理</h3><p><code>docker build</code>的核心机制包括<code>docker commit</code>和<code>build cache</code>两部分。</p><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>写好Dockerfile之后，通过<code>docker build</code>即可构建镜像：</p><pre><code>docker build -t 镜像名[:tag]  Dockerfile所在目录或URL</code></pre><p><code>docker build</code>将按照指令顺序来逐层构建镜像，每一条指令的执行结果将会commit为一个新的镜像层，并用于下一条指令。理解镜像层和commit的概念，是理解Docker镜像构建的关键。</p><p>镜像是被一层一层地”commit”上去的，而commit操作本身是由Docker容器执行的。<code>docker build</code>在执行一条指令时，会根据当前镜像层启动一个容器，Docker会在容器的层级文件系统最上层建立一层空的可读可写层(镜像层的内容对于容器来说是readonly的)，之后Docker容器执行指令，将执行结果写入可读可写层(并更新镜像Json文件)，最后再通过<code>docker commit</code>命令将可读可写层提交为一个新的镜像层。</p><p>Docker镜像层与镜像层之间是存在层级关系的，<code>docker build</code>会为Dockerfile每一条指令建立(commit)一个镜像层，并最终产生一个带标签(tag)的镜像，之前Dockerfile指令得到的镜像层(不会在构建完成后删除)是这个含标签镜像的祖先镜像。这样做的好处是最大化地复用镜像，不同的镜像之间可以共享镜像层，组成树形的镜像层级关系。</p><h4 id="build-cache"><a href="#build-cache" class="headerlink" title="build cache"></a>build cache</h4><p>在<code>docker build</code>过程中，如果发现本地有镜像与即将构建出来的镜像层一致时，则使用已有镜像作为Cache，充当本次构建的结果。从而加快build过程，并且避免构建重复的镜像。</p><p>那么docker是如何知道当前尚未构建的镜像的形态，并且与本地镜像进行比较呢？</p><p>Docker镜像由镜像文件系统内容和镜像Json文件两部分构成，前者即为<code>docker commit</code>提交的可读可写层，而镜像Json文件的作用为：</p><ul><li>记录镜像的父子关系，以及父子间的差异信息</li><li>弥补镜像本身以及镜像到容器转换所需的额外信息</li></ul><p>比如镜像Json文件中记录了当前镜像的父镜像，以及当前镜像与父镜像的差异(比如执行了哪条指令)，<code>docker build</code>则在这个基础上进行预测：</p><ul><li>判断已有镜像和目标镜像(当前正在构建的镜像)是父镜像ID是否相同</li><li>评估已有镜像的Json文件(如执行了那条命令，有何变动)，与目标镜像是否匹配</li></ul><p>如果条件满足，则可将已有镜像作为目标镜像的Cache，当然这种机制是并不完善的，比如当你执行的指令有外部动态依赖，此时可通过<code>docker build --no-cache</code>禁止使用Cache。</p><p>另外，基于build cache的机制，我们在写Dockerfile的时候，应该将静态安装，配置命令等尽可能放在Dockerfile前面，这样才能最大程度地利用cache，加快build过程。因为一旦Dockerfile前面有指令更新了并导致新的镜像层生成，那么该指令之后的镜像层cache也就完全失效了(树结构长辈节点更新了，子节点当然就不一样了)。</p><h3 id="3-docker-build-示例"><a href="#3-docker-build-示例" class="headerlink" title="3. docker build 示例"></a>3. docker build 示例</h3><p>Dcokerfile:</p><pre><code>FROM ubuntu:14.04# 创建一个100M的文件 /testRUN dd if=/dev/zero of=/test bs=1M count=100RUN rm /testRUN dd if=/dev/zero of=/test bs=1M count=100# 在根目录统计容器大小ENTRYPOINT [&quot;du&quot;, &quot;-sh&quot;]</code></pre><p>build镜像：</p><pre><code>▶ docker build . Sending build context to Docker daemon   599 kBStep 1 : FROM ubuntu:14.04 ---&gt; 1e0c3dd64ccdStep 2 : RUN dd if=/dev/zero of=/test bs=1M count=100 ---&gt; Running in d98f674c46f2100+0 records in100+0 records out104857600 bytes (105 MB) copied, 0.0980112 s, 1.1 GB/s ---&gt; f3a606172d91Removing intermediate container d98f674c46f2Step 3 : RUN rm /test ---&gt; Running in 14544c0dc6a0 ---&gt; 7efc0655e95dRemoving intermediate container 14544c0dc6a0Step 4 : RUN dd if=/dev/zero of=/test bs=1M count=100 ---&gt; Running in 387be027ef2f100+0 records in100+0 records out104857600 bytes (105 MB) copied, 0.0852024 s, 1.2 GB/s ---&gt; 38e3ea5c1412Removing intermediate container 387be027ef2fStep 5 : ENTRYPOINT du -sh ---&gt; Running in e190adcbcce2 ---&gt; baec9103f182Removing intermediate container e190adcbcce2Successfully built baec9103f182</code></pre><p>可以看到build过程为不断基于当前镜像启动中间容器(如d98f674c46f2容器基于1e0c3dd64ccd镜像层执行指令<code>RUN dd if=/dev/zero of=/test bs=1M count=100</code>并提交f3a606172d91镜像层)。通过<code>docker history &lt;image&gt;</code>可查看镜像层级关系：</p><pre><code>docker history baec9103f182                                                                                IMAGE               CREATED             CREATED BY                                      SIZE                COMMENTbaec9103f182        4 minutes ago       /bin/sh -c #(nop)  ENTRYPOINT [&quot;du&quot; &quot;-sh&quot;]      0 B38e3ea5c1412        4 minutes ago       /bin/sh -c dd if=/dev/zero of=/test bs=1M cou   104.9 MB7efc0655e95d        4 minutes ago       /bin/sh -c rm /test                             0 Bf3a606172d91        4 minutes ago       /bin/sh -c dd if=/dev/zero of=/test bs=1M cou   104.9 MB1e0c3dd64ccd        3 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0 B&lt;missing&gt;           3 weeks ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc   7 B&lt;missing&gt;           3 weeks ago         /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   1.895 kB&lt;missing&gt;           3 weeks ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B&lt;missing&gt;           3 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   194.6 kB&lt;missing&gt;           3 weeks ago         /bin/sh -c #(nop) ADD file:bc2e0eb31424a88aad   187.7 MB</code></pre><p>注意到其中一些镜像层的SIZE为0，这是因为该镜像层执行的命令不会影响到镜像的文件系统大小，这些命令会单独记录在镜像Json文件中。由于镜像的层级原理，Docker在执行<code>RUN rm /test</code>指令时，并没有真正将其当前镜像f3a606172d91中的/test文件真正删掉，而是将rm操作记录在镜像Json文件中(容器只能在其上层的可读写层进行更改操作)，最终我们得到的镜像大小约为400M。</p><p>然后我们基于得到镜像启动容器：</p><pre><code>docker run --rm baec9103f182du: cannot access &apos;./proc/1/task/1/fd/4&apos;: No such file or directorydu: cannot access &apos;./proc/1/task/1/fdinfo/4&apos;: No such file or directorydu: cannot access &apos;./proc/1/fd/4&apos;: No such file or directorydu: cannot access &apos;./proc/1/fdinfo/4&apos;: No such file or directory296M    .</code></pre><p>我们的容器大小只是近300M，因此Docker镜像的大小和容器中文件系统内容的大小是两个概念。镜像的大小等于其包含的所有镜像层之和，并且由于镜像层共享技术的存在(比如我们再构建一个基于ubuntu14:04的镜像，将直接复用本地已有的ubuntu镜像层)，极大节省了磁盘空间。</p><ol><li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices" target="_blank" rel="external">Dockerfile Best Practices</a></li><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile Reference</a></li><li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="external">Docker run Reference</a></li><li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker 从入门到实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-理解-Docker&quot;&gt;&lt;a href=&quot;#一-理解-Docker&quot; class=&quot;headerlink&quot; title=&quot;一. 理解 Docker&quot;&gt;&lt;/a&gt;一. 理解 Docker&lt;/h2&gt;&lt;p&gt;Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势&lt;/li&gt;
&lt;li&gt;一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记(7) 记线上一次回档BUG</title>
    <link href="http://wudaijun.com/2016/10/erlang-server-design7-cluster-bug-note/"/>
    <id>http://wudaijun.com/2016/10/erlang-server-design7-cluster-bug-note/</id>
    <published>2016-10-16T16:00:00.000Z</published>
    <updated>2016-10-18T06:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有十几个玩家报告被回档，几小时到一两天不等</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在我们的<a href="http://wudaijun.com/2016/01/erlang-server-design5-server-node/">集群架构</a>中，集群有若干GS节点，每个GS节点可部署N个GS服务器，整个集群所有的玩家进程注册于cluster，我们通过为每个服开一个player_mgr来维护单服玩家状态，player_mgr维护{player_id, agent_pid, player_pid}三元组，用户处理多点登录，单服逻辑，离线玩家LRU等。cluster本身只提供服务注册/注销，如果做服务替换(如agent)，确保服务的唯一性(如player)应该由外部逻辑来确保，cluster并不知晓内部各种服务的特性。player进程启动/终止时，会向player_mgr和cluster分别注册/注销自己。</p><a id="more"></a><h3 id="问题追踪"><a href="#问题追踪" class="headerlink" title="问题追踪"></a>问题追踪</h3><ol><li>error日志中出现几十个rewrite player process(重写cluster中player服务)的错误日志，并且这些玩家基本都属于一个公会</li><li>所有玩家进程的启动(login, get_fork)均由player_mgr控制，player_mgr确保玩家进程唯一，依赖的是自身的State数据，而不是cluster，问题可能出在player_mgr 和 cluster 状态不一致上</li><li>写了个检查脚本，查出仍有有个别玩家存在于cluster而不在player_mgr中，这类玩家在get_fork或login时，player_mgr会重新开一个player进程，导致rewrite player process，此时同一时刻就存在两个player进程(老玩家进程Pid0，新玩家进程Pid1)，已有Agent消息会被重新路由(通过cluster服务查找)到Pid1进程上，而Pid0不在cluster和player_mgr中，不会被终止，但会不断写盘，称第三方进程，这是导致玩家回档的根本原因</li><li>现在问题焦点：为什么player_mgr维护的数据和cluster不一致(比cluster少)</li><li>在player_mgr LRU剔除玩家进程时，是先在自己State中删除玩家进程，再cast消失让玩家进程终止，最后在player_server:terminate中，再向player_mgr和cluster注销自己。那么存在这样一种情况：player_mgr LRU剔除玩家进程Pid0到 player_server:terminate从cluster中注销自己之间，新的login或get_fork请求到来，此时player_mgr再启动了Pid1，并且rewrite player process，那么当Pid0 terminate时，检查到cluster中当前服务不是自己，不会更新cluster，之后，Pid0还会向player_mgr注销自己，并且没有带上Pid进行Pid检查，因此将Pid1从player_mgr中删除了！至此，player_mgr和cluster出现了不一致，cluster中存在Pid1程，而player_mgr中没有。下一次玩家login或get_fork一个新的Pid2时，Pid1被rewrite，Pid1也就成了第三方进程</li><li>上面的概率看起来很小，但由于公会等组逻辑，可能导致N个玩家同时被get_fork起来，而LRU又是player_mgr统一定期(10分钟)清理的，因此如果alliance前后10分钟get_fork两次，问题出现的概率就被放大了，这也是本次出问题的玩家基本都在一个公会的原因</li></ol><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ol><li>player_mgr在没有确认玩家进程已经退出时(此时可能还有一堆消息没处理完)，就删除了它</li><li>玩家进程在向player_mgr注销自己时，没有做Pid检查，注销了其它进程(没有考虑容错)</li></ol><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>线上热更的方案：</p><ol><li>player_mgr和cluster均在player terminate时才确认注销</li><li>服务注销时做Pid检查</li><li>在玩家进程定期存盘时检查其cluster和player_mgr状态，并stop掉第三方进程</li></ol><h3 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h3><p> 本质上来说，这次的问题源于：</p><ol><li>数据冗余导致短暂的不一致状态(player_mgr和cluster不一致)</li><li>在这种不一致状态下的特定事件(player login/get_fork)，导致不一致的影响被放大(存在第三方玩家进程)</li><li>对这种不一致状态缺乏检查和处理，导致BUG(玩家回档)</li></ol><p>在Code Review的过程中，还发现一些其它并发和异步问题。在多Actor异步交互模型中，调度时序，网络时延都可能导致状态不一致。在分布式系统中，想要从根本上杜绝不一致，是几乎不可能的(我们对同步和事务非常敏感)，因此我们不只是要从问题预防上考虑，还要从错误恢复上着手，让系统具备一定程度的”自愈能力”：</p><p>预防：减少不一致的可能性</p><ol><li>减少数据冗余，将cluster作为数据的第一参照，player_mgr的优先级降低，并只用于全服逻辑</li><li>简化player_mgr的功能，如将离线玩家的LRU移到player自身去管理</li></ol><p>恢复：检查并修复不一致</p><ol><li>在服务启动/运行/终止时，加上检查和修复机制，并记录日志</li><li>跑定时脚本检查player_mgr和cluster的一致性，并予以临时修复和报警</li></ol><p>最后，总结出的经验是，在分布式系统中，对问题的检查和修复，和问题的预防同样重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;有十几个玩家报告被回档，几小时到一两天不等&lt;/p&gt;
&lt;h3 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h3&gt;&lt;p&gt;在我们的&lt;a href=&quot;http://wudaijun.com/2016/01/erlang-server-design5-server-node/&quot;&gt;集群架构&lt;/a&gt;中，集群有若干GS节点，每个GS节点可部署N个GS服务器，整个集群所有的玩家进程注册于cluster，我们通过为每个服开一个player_mgr来维护单服玩家状态，player_mgr维护{player_id, agent_pid, player_pid}三元组，用户处理多点登录，单服逻辑，离线玩家LRU等。cluster本身只提供服务注册/注销，如果做服务替换(如agent)，确保服务的唯一性(如player)应该由外部逻辑来确保，cluster并不知晓内部各种服务的特性。player进程启动/终止时，会向player_mgr和cluster分别注册/注销自己。&lt;/p&gt;
    
    </summary>
    
      <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
      <category term="distribution" scheme="http://wudaijun.com/tags/distribution/"/>
    
  </entry>
  
  <entry>
    <title>goa - go web框架</title>
    <link href="http://wudaijun.com/2016/09/goa-intro/"/>
    <id>http://wudaijun.com/2016/09/goa-intro/</id>
    <published>2016-09-19T16:00:00.000Z</published>
    <updated>2016-09-20T14:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h3><p><a href="https://github.com/goadesign/goa" target="_blank" rel="external">goa</a>是基于微服务的go语言框架，能够有效帮助开发人员快速开发基于微服务的系统。它通过DSL和代码生成器来生成样板代码和辅助套件(如文档，客户端模块，客户端工具等)。这些生成数据均基于服务的设计描述，goa遵循<strong>单一数据源</strong>(Single Source of Truth, SSOT)原则，任何对设计的改变，都将自动反映到系统各处，</p><p>goa可以分为三个部分：</p><ul><li>goa的设计语言是内置DSL，用于描述微服务的设计</li><li>goa代码生成器，用于根据DSL描述生成代码模块，辅助工具，和文档等</li><li>goa利用生成代码和用户代码来实现一个服务，并提供一个完全可插拨的框架</li></ul><a id="more"></a><p>goa的特点：</p><ul><li>重视框架设计(Design-Based)，将框架，文档，胶水代码和辅助工具作为一个整体来设计和描述</li><li>为用户生成了大量的代码(框架代码，胶水代码，测试代码，客户端工具等等)，上手快速</li><li>DSL，代码生成器，用户代码均使用Go语言编写，并且前两者使用plugin实现，可以替换</li><li>基于微服务，对<a href="http://www.infoq.com/cn/articles/rest-introduction#anch82429" target="_blank" rel="external">RESTful</a> API有非常好的支持，方便构建更高效，易于扩展的HTTP服务器</li></ul><h3 id="二-使用"><a href="#二-使用" class="headerlink" title="二. 使用"></a>二. 使用</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><pre><code>// 获取goago get github.com/goadesign/goago get github.com/goadesign/goa/goagen// 安装goagengo install github.com/goadesign/goa/goagen</code></pre><h4 id="2-DSL-服务设计"><a href="#2-DSL-服务设计" class="headerlink" title="2. DSL 服务设计"></a>2. DSL 服务设计</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> design                         <span class="comment">// The convention consists of naming the design</span></div><div class="line">                                                   <span class="comment">// package "design"</span></div><div class="line"><span class="keyword">import</span> (</div><div class="line">        . <span class="string">"github.com/goadesign/goa/design"</span>        <span class="comment">// Use . imports to enable the DSL</span></div><div class="line">        . <span class="string">"github.com/goadesign/goa/design/apidsl"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = API(<span class="string">"cellar"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                     <span class="comment">// API defines the microservice endpoint and</span></div><div class="line">        Title(<span class="string">"The virtual wine cellar"</span>)           <span class="comment">// other global properties. There should be one</span></div><div class="line">        Description(<span class="string">"A simple goa service"</span>)        <span class="comment">// and exactly one API definition appearing in</span></div><div class="line">        Scheme(<span class="string">"http"</span>)                             <span class="comment">// the design.</span></div><div class="line">        Host(<span class="string">"localhost:8080"</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = Resource(<span class="string">"bottle"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                <span class="comment">// Resources group related API endpoints</span></div><div class="line">        BasePath(<span class="string">"/bottles"</span>)                       <span class="comment">// together. They map to REST resources for REST</span></div><div class="line">        DefaultMedia(BottleMedia)                  <span class="comment">// services.</span></div><div class="line"></div><div class="line">        Action(<span class="string">"show"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                    <span class="comment">// Actions define a single API endpoint together</span></div><div class="line">                Description(<span class="string">"Get bottle by id"</span>)    <span class="comment">// with its path, parameters (both path</span></div><div class="line">                Routing(GET(<span class="string">"/:bottleID"</span>))         <span class="comment">// parameters and querystring values) and payload</span></div><div class="line">                Params(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                    <span class="comment">// (shape of the request body).</span></div><div class="line">                        Param(<span class="string">"bottleID"</span>, Integer, <span class="string">"Bottle ID"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">                                Minimum(<span class="number">0</span>) <span class="comment">// Do not allow for negative values.</span></div><div class="line">                        &#125;)</div><div class="line">                &#125;)</div><div class="line">                Response(OK)                       <span class="comment">// Responses define the shape and status code</span></div><div class="line">                Response(NotFound)                 <span class="comment">// of HTTP responses.</span></div><div class="line">        &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// BottleMedia defines the media type used to render bottles.</span></div><div class="line"><span class="keyword">var</span> BottleMedia = MediaType(<span class="string">"application/vnd.goa.example.bottle+json"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        Description(<span class="string">"A bottle of wine"</span>)</div><div class="line">        Attributes(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                         <span class="comment">// Attributes define the media type shape.</span></div><div class="line">                Attribute(<span class="string">"id"</span>, Integer, <span class="string">"Unique bottle ID"</span>)</div><div class="line">                Attribute(<span class="string">"href"</span>, String, <span class="string">"API href for making requests on the bottle"</span>)</div><div class="line">                Attribute(<span class="string">"name"</span>, String, <span class="string">"Name of wine"</span>)</div><div class="line">                Required(<span class="string">"id"</span>, <span class="string">"href"</span>, <span class="string">"name"</span>)</div><div class="line">        &#125;)</div><div class="line">        View(<span class="string">"default"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                    <span class="comment">// View defines a rendering of the media type.</span></div><div class="line">                Attribute(<span class="string">"id"</span>)                     <span class="comment">// Media types may have multiple views and must</span></div><div class="line">                Attribute(<span class="string">"href"</span>)                   <span class="comment">// have a "default" view.</span></div><div class="line">                Attribute(<span class="string">"name"</span>)</div><div class="line">        &#125;)</div><div class="line">&#125;)</div><div class="line"></div></pre></td></tr></table></figure>    <p>上面的DSL主要用到的接口：</p><ul><li>API: 描述一个Service及其地址，协议规范等</li><li>Resource: 定义一个资源及其一系列相关的操作(Action)，以及这些操作所共用的一些属性</li><li>Action: 定义针对于某个资源的操作，包括方法(GET,POST等)，URL(可有多个)，参数(goa自动做类型检查，值检查等)等</li><li>Response: 定义一个响应，包括响应模板和承载内容(payload)，在代码中决定调用那个响应模板</li><li>MediaType: 定义Response返回的数据结构，一个Media可以有多个View，可在Response中指定返回的View</li></ul><p>goa本身DSL设计是<a href="http://www.infoq.com/cn/articles/rest-introduction#anch82429" target="_blank" rel="external">RESTful</a>的，通过Go的匿名函数，提供了非常强大的描述能力，如参数定义，参数检查，传输媒体，响应模板等。goa基于服务提供功能，每个API定义一个服务(Service)，每个服务有若干资源(Resource)，每个资源对应若干操作(Action)，每个操作(Action)有多种响应(Response)，每个响应可能返回不同媒介(Media)的不同视图(View)。当然goa提供了更好的层级控制和继承关系(如上例，Response返回的视图继承于Resource中定义的默认媒介(BottleMedia)的默认视图(default))。更详细的DSL设计文档参考<a href="https://goa.design/design/overview/" target="_blank" rel="external">goa dsl design</a>和<a href="https://goa.design/reference/goa/design/apidsl" target="_blank" rel="external">goa dsl api</a>。</p><h4 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3. 生成代码"></a>3. 生成代码</h4><p>通过goa根据单个DSL文件，即可生成一整套框架代码：</p><pre><code>cd src/cellargoagen bootstrap -d cellar/design</code></pre><p>goa会生成一堆代码，主要包括四个目录两个文件：</p><ul><li>app目录: 根据DSL，生成若干类，并将底层的HTTP服务器和DSL中的资源，路由结合起来</li><li>client目录:  配套的client包，包含对媒介类型的定义，和对请求响应的编解码</li><li>tool目录：根据client包生成的控制台工具，用于模拟客户端发送请求</li><li>swagger目录：包含对整个服务(API)的总体描述(Json和Yaml格式)</li><li>main.go文件：主文件，挂载资源路由(BottleController)，启动服务</li><li>bottle.go文件：bottle资源的逻辑处理，即BottleController的Action实现</li></ul><p>当改变DSL文件并再次用goagen生成代码时，goagen只会重新生成框架代码(app,client,tool,swagger)，而不会覆盖逻辑代码(main.go和bottle.go以及其它自定义文件)，做到框架与逻辑分离。</p><p>得到这些文件之后，我们直接编辑bottle.go，完善bottle资源的Action逻辑即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Show runs the show action.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *BottleController)</span> <span class="title">Show</span><span class="params">(ctx *app.ShowBottleContext)</span> <span class="title">error</span></span> &#123;</div><div class="line"><span class="comment">// BottleController_Show: start_implement</span></div><div class="line"></div><div class="line"><span class="comment">// Put your logic here</span></div><div class="line">    <span class="keyword">if</span> ctx.BottleID == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> ctx.NotFound()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bottle := app.GoaExampleBottle&#123;</div><div class="line">        ID : ctx.BottleID,</div><div class="line">        Name : fmt.Sprintf(<span class="string">"Bottle #%d"</span>, ctx.BottleID),</div><div class="line">        Href : app.BottleHref(ctx.BottleID),</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// BottleController_Show: end_implement</span></div><div class="line"><span class="keyword">return</span> ctx.OK(&amp;bottle)</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><p>至此，服务器就已经设计好了，剩下的HTTP Server，消息编解码，参数检查，路由，响应模板，甚至测试工具，gagen都已经为你做好了。</p><h4 id="4-运行和测试"><a href="#4-运行和测试" class="headerlink" title="4. 运行和测试"></a>4. 运行和测试</h4><p>运行服务器：</p><pre><code>cd src/cellargo build -o cellar./cellar2016/09/20 00:26:41 [INFO] mount ctrl=Bottle action=Show route=GET /bottles/:bottleID2016/09/20 00:26:41 [INFO] listen transport=http addr=:8080</code></pre><p>通过curl测试：</p><pre><code># 404 NOT FOUNDcurl -i localhost:8080/bottles/0# 200 一个有效的BottleMedia Viewcurl -i localhost:8080/bottles/1# 400 无效参数 得到参数检查错误提示curl -i localhost:8080/bottles/n</code></pre><p>通过celler-cli工具测试：</p><pre><code>cd src/cellar/tool/cellar-cligo build -o cellar-cli# 使用帮助./cellar-cli # show bottle 命令的用法./cellar-cli show bottle# 发送HTTP请求 cellar-cli中集成了服务的地址信息./cellar-cli show bottle /bottles/1</code></pre><p>最终我们只写了几十行的DSL和几行逻辑代码，就得到了一个基于微服务，RESTful风格的HTTP服务器，附以完整的客户端代码，测试工具，甚至服务API描述。更关键的是，这一套环境是SSOT(Single Source of Truth)的，更改一份DSL服务描述文件，整个服务器底层代码，胶水代码，测试环境，甚至API描述都会重新生成(不会影响到已有的逻辑代码)，这让整个服务保持高度一致性和可控性。</p><p>最后，以一段<a href="https://github.com/goadesign/goa" target="_blank" rel="external">goa github</a>上的描述收尾：</p><blockquote><blockquote><p>There are a number of good Go packages for writing modular web services out there so why build another one? Glad you asked! The existing packages tend to focus on providing small and highly modular frameworks that are purposefully narrowly focused. The intent is to keep things simple and to avoid mixing concerns.</p><p>This is great when writing simple APIs that tend to change rarely. However there are a number of problems that any non trivial API implementation must address. Things like request validation, response media type definitions or documentation are hard to do in a way that stays consistent and flexible as the API surface evolves.</p><p>goa takes a different approach to building these applications: instead of focusing solely on helping with implementation, goa makes it possible to describe the design of an API in an holistic way. goa then uses that description to provide specialized helper code to the implementation and to generate documentation, API clients, tests, even custom artifacts.</p></blockquote></blockquote><p>完整示例参考<a href="https://goa.design/learn/guide/" target="_blank" rel="external">goa learn guide</a>和<a href="https://github.com/goadesign/goa" target="_blank" rel="external">goa github</a>。</p><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>goa的优点：</p><ul><li>先进的理念：Design-Based, DSL, Micro-Service, RESTful API，Plugins等</li><li>DSL，代码生成器，用户代码，辅助工具等一整套环境都用Go实现</li><li>一份服务设计(DSL文件)，生成了包括框架代码，辅助(胶水)代码，测试代码，客户端工具等一整套环境(SSOT)</li><li>上手简单，功能强大</li><li>文档齐全，社区活跃度高</li></ul><p>后续会继续关注这个框架，尽快拿到实践中用用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一. 简介&quot;&gt;&lt;/a&gt;一. 简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/goadesign/goa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;goa&lt;/a&gt;是基于微服务的go语言框架，能够有效帮助开发人员快速开发基于微服务的系统。它通过DSL和代码生成器来生成样板代码和辅助套件(如文档，客户端模块，客户端工具等)。这些生成数据均基于服务的设计描述，goa遵循&lt;strong&gt;单一数据源&lt;/strong&gt;(Single Source of Truth, SSOT)原则，任何对设计的改变，都将自动反映到系统各处，&lt;/p&gt;
&lt;p&gt;goa可以分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;goa的设计语言是内置DSL，用于描述微服务的设计&lt;/li&gt;
&lt;li&gt;goa代码生成器，用于根据DSL描述生成代码模块，辅助工具，和文档等&lt;/li&gt;
&lt;li&gt;goa利用生成代码和用户代码来实现一个服务，并提供一个完全可插拨的框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
      <category term="goa" scheme="http://wudaijun.com/tags/goa/"/>
    
  </entry>
  
  <entry>
    <title>Rebar3 Erlang/OTP构建利器</title>
    <link href="http://wudaijun.com/2016/09/erlang-rebar3/"/>
    <id>http://wudaijun.com/2016/09/erlang-rebar3/</id>
    <published>2016-09-09T16:00:00.000Z</published>
    <updated>2016-09-09T18:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-依赖管理"><a href="#一-依赖管理" class="headerlink" title="一. 依赖管理"></a>一. 依赖管理</h3><h4 id="1-包依赖和源码依赖"><a href="#1-包依赖和源码依赖" class="headerlink" title="1. 包依赖和源码依赖"></a>1. 包依赖和源码依赖</h4><p>Rebar3支持两种依赖：</p><pre><code>{deps,[  %% 包依赖  rebar,  {rebar,&quot;1.0.0&quot;},  {rebar, {pkg, rebar_fork}}, % rebar app under a different pkg name  {rebar, &quot;1.0.0&quot;, {pkg, rebar_fork}},  %% 源码依赖  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;}},  {rebar, {git, &quot;http://github.com/erlang/rebar3.git&quot;}},  {rebar, {git, &quot;https://github.com/erlang/rebar3.git&quot;}},  {rebar, {git, &quot;git@github.com:erlang/rebar3.git&quot;}},  {rebar, {hg, &quot;https://othersite.com/erlang/rebar3&quot;}},  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;, {ref, &quot;aef728&quot;}}},  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;, {branch, &quot;master&quot;}}},  {rebar, {git, &quot;git://github.com/erlang/rebar3.git&quot;, {tag, &quot;3.0.0&quot;}}}  ]}</code></pre><a id="more"></a><p>Rebar3通过<a href="https://hex.pm" target="_blank" rel="external">hex.pm</a>来管理包依赖，在使用之前，需要通过<code>rebar3 update</code>从hex.pm更新包索引，并将包索引信息缓存到本地(<code>~/.cache/rebar3/</code>)。之后Rebar3便能正确解析包依赖，对应用程序使用上来说，两者没有明显区别。</p><h4 id="2-升级依赖"><a href="#2-升级依赖" class="headerlink" title="2. 升级依赖"></a>2. 升级依赖</h4><p>在使用Rebar2的时候，如果项目依赖一个指向分支的dep，就会出现这种情况：</p><ul><li>这个dep有远程分支更新时，rebar get-deps不会自动拉取更新，通常你只能进入dep目录执行<code>git pull</code>，或者删除该dep重新执行rebar get-deps。</li><li>项目成员各自的工作目录deps版本可能不一致，并且一些很久没更新的依赖可能在你部署新环境时(此时所有依赖都指向最新)出现问题。</li></ul><p>所以在Rebar2的reabr.config中定义deps，都应该尽量使用tag, commitid来指定，而不是直接指向分支。那么Rebar3是如何解决这个问题的呢？</p><p>Rebar3解决此问题的核心在rebar.lock文件，该文件内容如下：</p><pre><code>{&quot;1.1.0&quot;,[{&lt;&lt;&quot;goldrush&quot;&gt;&gt;,{pkg,&lt;&lt;&quot;goldrush&quot;&gt;&gt;,&lt;&lt;&quot;0.1.8&quot;&gt;&gt;},1}, {&lt;&lt;&quot;lager&quot;&gt;&gt;,{pkg,&lt;&lt;&quot;lager&quot;&gt;&gt;,&lt;&lt;&quot;3.2.1&quot;&gt;&gt;},0}]}.[{pkg_hash,[ {&lt;&lt;&quot;goldrush&quot;&gt;&gt;, &lt;&lt;&quot;2024BA375CEEA47E27EA70E14D2C483B2D8610101B4E852EF7F89163CDB6E649&quot;&gt;&gt;}, {&lt;&lt;&quot;lager&quot;&gt;&gt;, &lt;&lt;&quot;EEF4E18B39E4195D37606D9088EA05BF1B745986CF8EC84F01D332456FE88D17&quot;&gt;&gt;}]}].</code></pre><p>该文件是项目当前使用依赖库的一个版本快照。当一个依赖被获取和锁定，Rebar3将从依赖中提取版本信息并写入rebar.lock文件中，该文件应该加入GIt仓库，并且由专人维护，这样只要rebar.lock一致，各本地仓库的依赖库版本就是一致的。</p><p>依赖升级分为两种，一种是直接通过<code>rebar upgrade [dep]</code>进行源码更新或包更新(只能更新Top Level依赖)。另一种是rebar.config发生变动，比如去除了某个依赖，此时需要<code>rebar unlock [dep]</code>命令来清理rebar.lock文件。</p><p>相关命令：</p><pre><code>rebar3 update  // 更新包索引rebar3 pkgs // 列出所有可用的包rebar3 deps  // 列出所有一级(Top Level)依赖rebar3 tree  // 以树形结构查看依赖rebar3 compile // 获取并编译依赖rebar3 upgrade [dep] // 升级依赖rebar3 lock [dep] // 锁定依赖rebar3 unlock [dep] // 解锁依赖</code></pre><h3 id="二-构建"><a href="#二-构建" class="headerlink" title="二. 构建"></a>二. 构建</h3><pre><code>rebar3 new app [appname]rebar3 new lib [libname]</code></pre><p>Rebar3建议应用程序按照OTP规范目录进行组织：</p><pre><code>├── LICENSE├── README.md├── apps│   └── myapp│       └── src│           ├── myapp.app.src│           ├── myapp_app.erl│           └── myapp_sup.erl├── config│   ├── sys.config│   └── vm.args├── lib│   └── mylib│       ├── LICENSE│       ├── README.md│       ├── rebar.config│       └── src│           ├── mylib.app.src│           └── mylib.erl└── rebar.config</code></pre><p>这样无需在rebar.config中指定sub_dirs，Rebar3会自动将lib和apps作为搜索路径。</p><p>Rebar3没有get-deps命令，通过<code>rebar3 compile</code>即可编译项目，并自动获取和编译不存在的依赖，Rebar3将所有编译文件和Release信息都置于<code>_build</code>目录下。默认apps，deps和lib下的应用都被编译到<code>_build/default/lib</code>中。要指定应用目录和输出目录等选项，请参考：<a href="http://www.rebar3.org/docs/configuration" target="_blank" rel="external">Rebar3配置</a>。</p><h3 id="三-发布"><a href="#三-发布" class="headerlink" title="三. 发布"></a>三. 发布</h3><h4 id="1-发布环境"><a href="#1-发布环境" class="headerlink" title="1. 发布环境"></a>1. 发布环境</h4><p>Rebar3放弃了<a href="http://erlang.org/doc/man/reltool.html" target="_blank" rel="external">reltool</a>而使用<a href="https://github.com/erlware/relx" target="_blank" rel="external">relx</a>作为发布工具。并且将relx.config内容集成到rebar.config当中，通过<code>rebar new release [appname]</code>可创建一个发布，rebar.config内容如下：</p><pre><code>{erl_opts, [debug_info]}.{deps, []}.%% 定义默认发布环境(default环境){relx, [{release, { myapp, &quot;0.1.0&quot; },         [myapp,          sasl]},        {sys_config, &quot;./config/sys.config&quot;},        {vm_args, &quot;./config/vm.args&quot;},    %% 当dev_mode==true时 _build/default/rel/myapp/lib/目录下的库其实是_build/default/lib目录下对应lib的软链接，这样重新编译后，无需重新发布，重启或热加载代码即可        {dev_mode, true},        %% 是否在发布目录中包含虚拟机 即为一个独立的运行环境        {include_erts, false},        {extended_start_script, true}]}.%% 定义其它发布环境%% 参数使用覆盖(override)机制，即这里面没有定义的参数，将使用默认发布环境(default)配置{profiles, [{prod, [{relx, [{dev_mode, false},                            {include_erts, true}]}]            }]}</code></pre><p>Rebar3中有发布环境(profiles)的概念，如开发环境(default)，生产环境(prod)，它们可以独立定义编译参数(erl_opts)，发布参数(dev_mode, include_erts)，甚至依赖应用(deps)。目前Rebar3支持四种环境定义：</p><ul><li>default：默认环境，也就是rebar.config中最外部定义的环境</li><li>prod：生产环境，通常在此环境下将使用库的完整发布包(而不是软链接)，有更严格的编译选项，并且可能还要包含Erlang运行时所需要的所有环境</li><li>native：原生环境，强制使用<a href="http://erlang.org/doc/man/HiPE_app.html" target="_blank" rel="external">HiPE</a>编译，从而得到更快的编译速度</li><li>test：测试环境，将加载一些额外的库(如<a href="https://github.com/eproxus/meck" target="_blank" rel="external">meck</a>)，打开调试信息，用于跑测试代码</li></ul><p>不同发布环境将发布在不同的目录下，如prod环境默认将生成在<code>_build/prod/</code>下，无论顶层应用采用何种发布环境，依赖将始终只能使用prod环境发布。并且只有顶层依赖的default环境，可以被保存到rebar.lock中。</p><p><code>rebar3 release</code>将按照default环境发布应用，通过<code>rebar3 as prod release</code>可以将应用在生产环境发布。具体环境配置及命令参考<a href="http://www.rebar3.org/docs/profiles" target="_blank" rel="external">Rebar3环境</a>。</p><h4 id="2-发布多个应用"><a href="#2-发布多个应用" class="headerlink" title="2. 发布多个应用"></a>2. 发布多个应用</h4><p>Rebar3支持在rebar.config中定义多个应用的发布，多个应用可以共享配置：</p><pre><code>{relx, [{release, {myapp1, &quot;0.0.1&quot;},     [myapp1]},    {release, {myapp2, &quot;0.1.0&quot;},     [myapp2]},     % 共用配置{sys_config, &quot;config/sys.config&quot;},{vm_args, &quot;config/vm.args&quot;},    {dev_mode, true},    {include_erts, false},    {extended_start_script, true}]}.</code></pre><p>也可以独立配置：</p><pre><code>{relx, [    {release, {myapp1, &quot;0.0.1&quot;},             [myapp1],             % 注意配置顺序和格式 各应用的独立配置是一个PropList             [{sys_config, &quot;config/sys1.config&quot;},        {vm_args, &quot;config/vm1.args&quot;}]    },        {release, {myapp2, &quot;0.1.0&quot;},             [myapp2],             [{sys_config, &quot;config/sys1.config&quot;},        {vm_args, &quot;config/vm1.args&quot;},        {overlay}]    },        {dev_mode, true},    {include_erts, false},    {extended_start_script, true}]}.</code></pre><h4 id="3-应用依赖"><a href="#3-应用依赖" class="headerlink" title="3. 应用依赖"></a>3. 应用依赖</h4><p>定义于rebar.config deps中的依赖被获取后放在<code>_build/default/lib</code>目录下，默认并不会打包到应用的发布目录<code>_build/default/rel/myapp/lib</code>中，你需要在relbar.config的relx中指定应用依赖：</p><pre><code>{relx, [{release, { myapp, &quot;0.1.0&quot; },         [         % 指定应用依赖 mylib会先于myapp被启动         mylib,          myapp]         },        {sys_config, &quot;./config/sys.config&quot;},        {vm_args, &quot;./config/vm.args&quot;},        {dev_mode, true},        {include_erts, false},        {extended_start_script, true}]}.</code></pre><p>那么对于一些辅助lib呢，我们希望它被打包在应用发布目录中，但不希望它们被启动(它们可能根本不能启动)，一种方法是将mylib指定为<code>{mylib, load}</code>(参见<a href="https://github.com/erlware/relx/issues/483" target="_blank" rel="external">Issue1</a>, <a href="https://github.com/erlware/relx/issues/149" target="_blank" rel="external">Issue2</a>)，列表中的依赖项默认被relx解释为<code>{mylib, permanent}</code>，即以常驻的方式启动应用。</p><h4 id="4-Overlays"><a href="#4-Overlays" class="headerlink" title="4. Overlays"></a>4. Overlays</h4><p>Overlay允许用户定义一些文件模板和部署准备工作，如拷贝文件，创建文件夹等：</p><pre><code>{relx, [    {overlay_vars, &quot;vars.config&quot;},    {overlay, [{mkdir, &quot;log/sasl&quot;},               {template, &quot;priv/app.config&quot;, &quot;etc/app.config&quot;}，               % root_dir是relx提供的变量 代表项目根目录               {copy, &quot;\{\{root_dir\}\}/configures&quot;, &quot;./&quot;}]}]}.</code></pre><p>Overlay可以如sys_config和vm_config一样，放在各应用的独立发布配置中。</p><p>更多关于Rebar3发布流程，发布配置，以及库升级等，参考<a href="http://www.rebar3.org/v3/docs/releases" target="_blank" rel="external">Rebar3发布</a>。</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h3><p>Rebar3无疑是个好东西，更先进的依赖管理，多节点发布，发布环境的概念，都是Rebar2 + Reltool所不能实现的，当前我们项目就使用的Rebar2.x，用于部署一个多节点的集群，遇到的问题：</p><ul><li>依赖管理：各本地版本不一致问题，Rebar3的lock为依赖的一致性提供了保证。</li><li>多节点部署：Rebar2.x需要为每个节点创建release(create-node)，需要维护N份reltool.config和一份rebar.config。在Rebar3中只需一个rebar.config文件。并且可以灵活定义各节点配置文件(vm.args, sys.config)路径，更有利于项目结构管理和可读性。</li><li>开发模式：在本地开发时，Rebar2.x的generate和upgrade太慢了，前者可用二进制发布自己写脚本替代(用erl_call和节点通信)，后者可用reloader实现热更，这样提高了部署速度，却要自己维护节点交互脚本。Rebar3的dev_mode完美解决了这个问题。</li><li>环境管理：这一块的用处还有待挖掘和摸索。</li></ul><p>Rebar3目前主要的缺点，在于relx文档匮乏，提供了很多好东西，但能传达到用户让用户理解和用上的很少。翻遍了<a href="https://github.com/erlware/relx/wiki" target="_blank" rel="external">relx wiki</a>，也没有找到应用独立配置环境(sys_config, vm_args等)的方法，最后是看了其配置解析模块<a href="hub.com/erlware/relx/blob/master/src/rlx_config.erl">rlx_config.erl</a>才猜出来的格式= =。</p><h3 id="五-参考："><a href="#五-参考：" class="headerlink" title="五. 参考："></a>五. 参考：</h3><ol><li><a href="http://www.rebar3.org/docs/getting-started" target="_blank" rel="external">Rebar3文档</a></li><li><a href="https://github.com/zyuyou/rebar3_docs" target="_blank" rel="external">Rebar3文档中文翻译(部分)</a></li><li><a href="https://github.com/erlware/relx/wiki" target="_blank" rel="external">relx wiki</a></li><li><a href="http://erlang.org/doc/design_principles/release_structure.html" target="_blank" rel="external">OTP Release 结构</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-依赖管理&quot;&gt;&lt;a href=&quot;#一-依赖管理&quot; class=&quot;headerlink&quot; title=&quot;一. 依赖管理&quot;&gt;&lt;/a&gt;一. 依赖管理&lt;/h3&gt;&lt;h4 id=&quot;1-包依赖和源码依赖&quot;&gt;&lt;a href=&quot;#1-包依赖和源码依赖&quot; class=&quot;headerlink&quot; title=&quot;1. 包依赖和源码依赖&quot;&gt;&lt;/a&gt;1. 包依赖和源码依赖&lt;/h4&gt;&lt;p&gt;Rebar3支持两种依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{deps,[
  %% 包依赖
  rebar,
  {rebar,&amp;quot;1.0.0&amp;quot;},
  {rebar, {pkg, rebar_fork}}, % rebar app under a different pkg name
  {rebar, &amp;quot;1.0.0&amp;quot;, {pkg, rebar_fork}},
  %% 源码依赖
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;}},
  {rebar, {git, &amp;quot;http://github.com/erlang/rebar3.git&amp;quot;}},
  {rebar, {git, &amp;quot;https://github.com/erlang/rebar3.git&amp;quot;}},
  {rebar, {git, &amp;quot;git@github.com:erlang/rebar3.git&amp;quot;}},
  {rebar, {hg, &amp;quot;https://othersite.com/erlang/rebar3&amp;quot;}},
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;, {ref, &amp;quot;aef728&amp;quot;}}},
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;, {branch, &amp;quot;master&amp;quot;}}},
  {rebar, {git, &amp;quot;git://github.com/erlang/rebar3.git&amp;quot;, {tag, &amp;quot;3.0.0&amp;quot;}}}
  ]}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Go 笔记(1) 常用数据结构及实现</title>
    <link href="http://wudaijun.com/2016/09/go-notes-1-datastructures/"/>
    <id>http://wudaijun.com/2016/09/go-notes-1-datastructures/</id>
    <published>2016-09-08T16:00:00.000Z</published>
    <updated>2017-06-13T10:46:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下go中常用的几种数据结构，结合源码了解其实现原理。</p><h2 id="一-类型系统"><a href="#一-类型系统" class="headerlink" title="一. 类型系统"></a>一. 类型系统</h2><h3 id="1-array"><a href="#1-array" class="headerlink" title="1. array"></a>1. array</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x [2]<span class="keyword">int</span>)</span></span>&#123;</div><div class="line">x[<span class="number">1</span>] = <span class="number">9</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line">b := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">f(a) <span class="comment">// error: cannot use a (type [3]int) as type [2]int in argument to f</span></div><div class="line">f(b) <span class="comment">// 数组是值语义 因此f无法改变b中元素内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>array的特性:</p><ul><li>固定大小，且大小为类型的一部分</li><li>数组元素在内存中连续存放</li><li>值语义: 数组本身(传参会完整拷贝数组)</li></ul><h3 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice"></a>2. slice</h3><h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><p>slice(切片)，提供描述array部分连续元素的能力。</p><blockquote><blockquote><p>A slice is a data structure describing a contiguous section of an array stored separately from the slice variable itself. A slice is not an array. A slice describes a piece of an array.</p></blockquote></blockquote><p>slice只持有array的引用，而不会拷贝元素，因此它在实现上只需持有指向array元素的pointer和slice长度length即可。但由于slice的length可以收缩或扩张，因此slice还需要一个字段capacity来保存其最初引用的array的size，当length &gt; capacity时，说明对array的访问越界，触发panic错误。</p><p>因此slice一共有三个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> sliceHeader&#123;</div><div class="line">Length <span class="keyword">int</span><span class="comment">// slice长度</span></div><div class="line">Capacity <span class="keyword">int</span> <span class="comment">// slice引用的array size</span></div><div class="line">Elem  *ElemType <span class="comment">// 指向slice第一个元素array中的地址</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接创建slice 等价于:</span></div><div class="line"><span class="comment">// tmp := [5]int&#123;2,3,5,7,11&#125;</span></div><div class="line"><span class="comment">// a := tmp[0:5]</span></div><div class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>&#125;</div><div class="line">b := a[<span class="number">1</span>:<span class="number">3</span>]</div></pre></td></tr></table></figure><p>此时a,b的sliceHeader示意图为:</p><p><img src="/assets/image/go/go-slice-implement.png" alt=""></p><p>由于slice b在slice a中的起始偏移为1，因此 cap(b) = cap(a)-1 = 4。但b只能访问到a[1],a[2]两个元素:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 尝试访问&gt;=length(2)的元素，会触发panic error</span></div><div class="line">fmt.Println(b[<span class="number">2</span>])</div><div class="line"><span class="comment">// 等价于 c := b[0:len(b)] c和b引用完全相同的数组切片</span></div><div class="line">c := b[:]</div><div class="line"><span class="comment">// 虽然b只能访问数组[1],[2]两个元素，但d可以在[0,cap(b)]再次切片扩展引用的数组范围</span></div><div class="line">d := b[<span class="number">0</span>:<span class="built_in">cap</span>(b)]</div><div class="line">fmt.Println(d[<span class="number">3</span>]) <span class="comment">// 11</span></div></pre></td></tr></table></figure><p>那么slice这种数组切片的概念，究竟带来了什么好处？比如我们有一个操作，要去掉数组的首尾元素，在C中，我们会创建(动态分配)一个新数组，然后将arr[1,n-1)拷贝出来。在C++中，有vector会方便一些，但移除元素会导致后续元素移动拷贝开销。而在Go中，<code>slice = slice[1:len(slice)-1]</code>即可完成操作，这中间不会涉及到内存分配，移动拷贝等，是个非常高效的操作。当然，由于slice是引用的数组元素，因此slice修改数组元素时，对其它引用到该元素的slice也是可见的。</p><p>下面来说说slice的值语义。前面提到的sliceHeader，实际就是slice的值语义，我们创建一个slice，在底层就创建了一个sliceHeader结构体。在参数传递时，将会拷贝sliceHeader，但由于sliceHeader中持有指针，因此在调用函数内可修改数组元素，但无法修改sliceHeader结构体的成员值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Extend</span><span class="params">(slice []<span class="keyword">int</span>, element <span class="keyword">int</span> )</span></span>&#123;</div><div class="line">n := <span class="built_in">len</span>(slice)</div><div class="line">slice = slice[<span class="number">0</span> : n+<span class="number">1</span>] <span class="comment">// 不会影响到传入的slice的length</span></div><div class="line">slice[n] = element <span class="comment">// 修改了数组内容，对传入的slice可见</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再次摘录一段<a href="https://blog.golang.org/slices" target="_blank" rel="external">golang blog</a>关于slice值语义的描述:</p><blockquote><blockquote><p>It’s important to understand that even though a slice contains a pointer, it is itself a value. Under the covers, it is a struct value holding a pointer and a length. It is not a pointer to a struct.</p></blockquote></blockquote><p>BTW，在Go里面的参数传递都是值传递的，只是针对各种类型，其值语义不同，比如int,array它们的值语义就是数据本身，不包含对外的引用(指针)，因此在传参时会完整拷贝整个数据，是没有副作用的。而对slice来说，其值语义中包含对数组的引用，因此在传参时，其引用内容可能被修改，但其值语义(sliceHeader)本身仍然是完整拷贝的。</p><h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>前面提到slice本质上是数组切片，但slice本身也可以作为动态数组:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">s := a[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line"><span class="comment">// len=3 cap=5 capacity足够 无需重新分配 因此修改会作用于a之上</span></div><div class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line"><span class="comment">// len=5 cap=5 append通过make()重新分配新的slice 并通过copy()拷贝已有元素</span></div><div class="line"><span class="comment">// 此后s不再指向a 而指向新分配的连续内存空间</span></div><div class="line">s = <span class="built_in">append</span>(s, <span class="number">8</span>)</div><div class="line">fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line"><span class="comment">// 对s的修改将不在作用于a上</span></div><div class="line">s[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">fmt.Println(<span class="string">"cap: "</span>,<span class="built_in">cap</span>(s),<span class="string">"len: "</span>,<span class="built_in">len</span>(s),<span class="string">"slice: "</span>,s,<span class="string">"array: "</span>,a)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出:</span></div><div class="line"><span class="built_in">cap</span>:  <span class="number">5</span> <span class="built_in">len</span>:  <span class="number">3</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</div><div class="line"><span class="built_in">cap</span>:  <span class="number">5</span> <span class="built_in">len</span>:  <span class="number">5</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</div><div class="line"><span class="built_in">cap</span>:  <span class="number">10</span> <span class="built_in">len</span>:  <span class="number">6</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</div><div class="line"><span class="built_in">cap</span>:  <span class="number">10</span> <span class="built_in">len</span>:  <span class="number">6</span> slice:  [<span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</div></pre></td></tr></table></figure><p>append会在<strong>len(s)+添加的元素个数&gt;cap(s)时</strong>，重新分配(make)一个slice，拷贝(copy)已有元素，添加新元素，最后返回这个新的slice。在使用append时，需要保存其返回值，因为append传入的是slice的值，也就是sliceHeader结构体，当slice capacity扩展时，append函数内不能修改sliceHeader中的Length和Capacity字段，因此需要返回一个新的sliceHeader。</p><p>为了避免混淆，不要像上例一样将slice的切片特性和动态数组特性混用，使用动态数组时，使用空的slice(<code>var s []int</code>)或make(<code>make([]int, len, cap)</code>)初始化一个slice会比较好。</p><h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p>Go中的string更像是C中的字符串字面量，而不是字符数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">str := <span class="string">"Hello, 世界"</span></div><div class="line"><span class="comment">//str[0] = 'X' // error 不可改变字符串(类似字面常量)</span></div><div class="line"></div><div class="line"><span class="comment">// 字符串可通过 + 进行拼接</span></div><div class="line">str += <span class="string">" !"</span></div><div class="line"></div><div class="line"><span class="comment">// 以ANSI字符遍历 ch是一个byte n=15(每个中文在UTF-8中占3个字节)</span></div><div class="line">n := <span class="built_in">len</span>(str)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; n; i++ &#123;</div><div class="line">    ch := str[i]</div><div class="line">    fmt.Println(i, ch)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 以Unicode字符遍历 ch是一个rune 而不是byte 此时遍历得到11个Unicode字符</span></div><div class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> str&#123;</div><div class="line">    fmt.Println(i, ch)                </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在实现上，string是个read-only byte slice，另外，string的”sliceHeader”没有capacity字段：</p><p><img src="/assets/image/go/go-string-implement.png" alt=""></p><pre><code>s := &quot;hello&quot;t := s[2:3] // &quot;l&quot;v := t[0:2] // 没有capacity字段，无法扩展，触发panic error: out of range</code></pre><p>由于string的slice特性，len(s)操作非常高效，字符串切割也给代码处理带来很高的灵活度，如官方runtime/string.go的atoi函数是这样写的:</p><pre><code>func atoi(s string) int{    n := 0       for len(s) &gt; 0 &amp;&amp; &apos;0&apos; &lt;= s[0] &amp;&amp; s[0] &lt;= &apos;9&apos; {        n = n*10 + int(s[0]) - &apos;0&apos;        s = s[1:]    }    return n}</code></pre><p>PS，slice的这种切片特性，与Erlang的<a href="http://wudaijun.com/2015/12/erlang-datastructures/#refc-bianry">refc binary和sub binary</a>实现有相似之处，这种高效的处理方案有个老大难问题，那就是slice string未释放，那么它引用的string本身也不会被GC，哪怕只引用了很小一部分。</p><h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map通过hash表实现，实现位于runtime/hashmap.go，以下是主要字段:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">bucketCntBits = <span class="number">3</span></div><div class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</div><div class="line">)</div><div class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</div><div class="line">count <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></div><div class="line">flags <span class="keyword">uint8</span></div><div class="line">B     <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></div><div class="line"></div><div class="line">buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></div><div class="line">oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></div><div class="line"></div><div class="line">evacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// A bucket for a Go map.</span></div><div class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</div><div class="line">tophash [bucketCnt]<span class="keyword">uint8</span></div><div class="line"><span class="comment">// Followed by bucketCnt keys and then bucketCnt values.</span></div><div class="line"><span class="comment">// Followed by an overflow pointer.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>摘自源码注释：</p><blockquote><blockquote><p>A map is just a hash table.  The data is arranged into an array of buckets.  Each bucket contains up to 8 key/value pairs.  The low-order bits of the hash are used to select a bucket.  Each bucket contains a few high-order bits of each hash to distinguish the entries within a single bucket.</p><p>If more than 8 keys hash to a bucket, we chain on extra buckets.</p><p>When the hashtable grows, we allocate a new array of buckets twice as big.  Buckets are incrementally copied from the old bucket array to the new bucket array.</p></blockquote></blockquote><p>hmap的buckets数组大小为2^B，通过取余(<code>hash(key)&amp;(1&lt;&lt;B-1)</code>)可得到key对应的bucket在buckets数组中的下标，每个bucket可以容纳2^bucketCntBits=8个key/value对，落到该桶的key个数超过8个时，会在堆上分配一个新的bucket，并挂在链表末，因此go hashmap通过链表(8个元素一组)来解决hash碰撞问题。</p><p>go的hash map使用的是可扩展hash算法，在负载因子loadFactor(<code>hmap.count/(1&lt;&lt;B)</code>)大于某个值(这个值太大会导致overflow buckets过多，查找效率降低，过小会浪费存储空间，经源码作者测试确认为6.5)时，进行hash扩展。此时B=B&lt;&lt;1，原有buckets由oldbuckets指向，新的buckets重新分配，此时由于hash表大小变更，部分key得到的buckets下标也会改变，因此需要将oldbuckets中的数据按照新的hash表大小重新迁移(evacuate)，出于效率考虑，这个操作是增量进行的，在hash map每次写入时，都会尝试迁移两个bucket(以及后续overflow bucket)，一个是写入的目标bucket(局部迁移)，一个是hmap.evacuate指向的bucket(增量迁移)，这样兼顾局部性和全局性，同时也能保证在新的buckets loadFacotr到达6.5前，所有迁移工作一定能完成。迁移工作完成后，oldbucket置为nil。PS: hash map通过bucket的tophash[0]来标记bucket的迁移状态，保留的标记值为0-3，key的tophash在这个范围内时，会被+4修正</p><p>上述是基于go1.5 hashmap实现，在go1.8中，添加了sameSizeGrow，当overflow buckets的数量超过一定数量(2^B)而负载未大于阀值6.5时，此时可能存在部分空的bucket，即bucket未有效利用，这时会触发sameSizeGrow，即B不变，但走数据迁移流程，将oldbuckets的数据重新紧凑排列提高bucket的利用率。当然在sameSizeGrow过程中，不能触发loadFactorGrow。</p><p>下面来看个结构图:</p><p><img src="/assets/image/go/go-map-implement.png" alt=""></p><p>再来看Key查找过程(简化版):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// From go 1.8.1 src/runtime/hashmap.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</div><div class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</div><div class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</div><div class="line">&#125;</div><div class="line"><span class="comment">// 并发检查 go hashmap不支持并发访问</span></div><div class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</div><div class="line">throw(<span class="string">"concurrent map read and map write"</span>)</div><div class="line">&#125;</div><div class="line">alg := t.key.alg</div><div class="line">hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</div><div class="line">m := <span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span></div><div class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</div><div class="line"><span class="comment">// step1: 找到bucket</span></div><div class="line"><span class="comment">// 如果oldbuckets未迁移完成 则找打oldbuckets中对应的bucket(低B-1位)</span></div><div class="line"><span class="comment">// 否则为buckets中的bucket(低B位)</span></div><div class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</div><div class="line">m &gt;&gt;= <span class="number">1</span></div><div class="line">&#125;</div><div class="line">oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</div><div class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</div><div class="line">b = oldb</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">top := <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</div><div class="line"><span class="keyword">if</span> top &lt; minTopHash &#123;</div><div class="line">top += minTopHash</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line"><span class="comment">// step2: 比较tophash</span></div><div class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</div><div class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</div><div class="line"><span class="keyword">continue</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// dataOffset为key数组在bucket(bmap结构)中的起始偏移</span></div><div class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</div><div class="line"><span class="keyword">if</span> t.indirectkey &#123;</div><div class="line">k = *((*unsafe.Pointer)(k))</div><div class="line">&#125;</div><div class="line"><span class="comment">// step3: 比较key</span></div><div class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;</div><div class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</div><div class="line"><span class="keyword">if</span> t.indirectvalue &#123;</div><div class="line">v = *((*unsafe.Pointer)(v))</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> v</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">b = b.overflow(t)</div><div class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>限于理解深度，其它一些细节没有提到，比如对不含pointer的key/value优化，另外，go map还针对常用key类型(如int32,int64,string)进行了特例优化，代码位于src/runtime/hashmap_fast.go。以下是上面已经提到的一些小的优化细节：</p><ul><li>key value采用k1,k2,..v1,v2,…排列，而不是k1,v1,k2,v2，这是出于内存对齐考虑，节约空间</li><li>tophash可用于加快key的查找，同时用于标记key的迁移状态</li><li>map大小是2的幂，因此hash值可快速求余: hash(key)&amp;(1&lt;&lt;B-1)</li><li>hash map的增量式扩展，sameSizeGrow</li></ul><p>其它:</p><ul><li>go map不支持并发</li><li>go map目前只有扩展 没有收缩操作(shrink)</li><li>go map迁移时，会创建新的bucket，而不会复用oldbucket中的overflow bucket(作者TODO里面)</li></ul><p>值语义：如hmap结构体所示，buckets为bucket指针数组，那么对key,value的操作都是引用语义的。</p><h3 id="5-channel"><a href="#5-channel" class="headerlink" title="5. channel"></a>5. channel</h3><p>channel是goroutine用于数据交互的通道，和Erlang的Actor以通信实体为第一类对象不同(Actor模型)，Go以通信介质作为第一类对象(CSP模型)，channel支持多写入者和读取者，并且可通过缓冲来实现同步/异步(一定数量)通信。</p><p>在实现上，channel其实就是个消息队列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 省略部分字段</span></div><div class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</div><div class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></div><div class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></div><div class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></div><div class="line">elemsize <span class="keyword">uint16</span></div><div class="line">closed   <span class="keyword">uint32</span></div><div class="line">elemtype *_type <span class="comment">// element type</span></div><div class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></div><div class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></div><div class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></div><div class="line">sendq    waitq  <span class="comment">// list of send waiters</span></div><div class="line">lock mutex</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下图描述了一个缓冲区大小为5，并阻塞了若干读goroutine的情况:</p><p><img src="/assets/image/go/go-chan-implement.png" alt=""></p><p>该图省略了hchan和sudog的部分字段，waitq在实现上是双向链表，虽然实际只会用到单链表语义(FIFO)。</p><p>根据上图情形，此时如果有其它goroutine写入channel:</p><ol><li>从recvq中pop第一个读写者的sudog</li><li>将写入channel的数据拷贝到该sudog的elem字段</li><li>唤醒该读写者goroutine(sudog.g)</li></ol><p>当recvq队列为空，此时写入:</p><ol><li>将写入的数据缓存到buff[sendx]</li><li>sendx环形自增，qcount++</li></ol><p>当buff缓冲区写满(qcount==dataqsiz)，此时写入:</p><ol><li>为写入者创建一个sudog，并插入到sendq队列末</li><li>挂起该写入者goroutine</li></ol><p>如果此时有goroutine再次读channel:</p><ol><li>从buf[recvx]读取第一个数据</li><li>从sendq中pop第一个阻塞的写入者goroutine(sudog)</li><li>将该sudog中的elem字段数据拷贝到buf[recvx]，相当于将elem数据push到buf末尾</li><li>recvx++</li><li>唤醒该发送者goroutine</li></ol><p>没有缓冲的channel(dataqsize==0)操作要简单一些，写入时如果recvq-&gt;first!=nil，则直接拷贝数据到读取者的elem字段，否则将写入者挂起。反之，读写过程也类似。</p><p>另外，由于一个goroutine读写多个channel，因此go提供语言级别的select，用于处理异步IO问题。这其实本质上仍然是尝试对channel进行读写操作(chanrecv)，只不过由block参数为false表明该读写不阻塞，当读写操作需要挂起时，立即返回false。而select操作本身其实就是个多分支的if-elseif-else表达式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">src/runtime/<span class="keyword">chan</span>.<span class="keyword">go</span></div><div class="line"><span class="comment">// compiler implements</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//select &#123;</span></div><div class="line"><span class="comment">//case c &lt;- v:</span></div><div class="line"><span class="comment">//... foo</span></div><div class="line"><span class="comment">//default:</span></div><div class="line"><span class="comment">//... bar</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// as</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//if selectnbsend(c, v) &#123;</span></div><div class="line"><span class="comment">//... foo</span></div><div class="line"><span class="comment">//&#125; else &#123;</span></div><div class="line"><span class="comment">//... bar</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line"><span class="keyword">return</span> chansend(t, c, elem, <span class="literal">false</span>, getcallerpc(unsafe.Pointer(&amp;t)))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>select的if-elseif-else语句分支顺序是随机的，在每次执行select时会将所有scase(包含hchan)顺序随机排列。参考src/runtime/select.go hselect和scase结构体。</p><p>通过<code>cap(chan)</code>和<code>len(chan)</code>可以获取channel的缓冲区大小(dataqsize)和当前消息数量(qcount)。</p><h3 id="6-interface"><a href="#6-interface" class="headerlink" title="6. interface"></a>6. interface</h3><p>interface接口的用法和实现单独放到<a href="http://wudaijun.com/2016/09/go-notes-3-object-oriented/">go面向对象</a>一节。</p><h3 id="7-make-amp-new"><a href="#7-make-amp-new" class="headerlink" title="7. make &amp; new"></a>7. make &amp; new</h3><p>go中有make和new两个关键字用于分配一个对象，简要提一下两者的区别：</p><p>内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型<strong>零值</strong>的指针</p><p>内建函数 make 用来为 slice，map 或 chan 类型分配内存和<strong>初始化</strong>一个对象(目前只能用于这三种类型)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体使用如下：</p><pre><code>// 等价于 a := [capacity]int{}  s := a[0:2]s := make([]int, length [,capacity])m := make(map[int]string [,size])c := make(chan int, [,length])</code></pre><h3 id="8-常量"><a href="#8-常量" class="headerlink" title="8. 常量"></a>8. 常量</h3><p>Go中的常量是无类型的，字面常量(如：3.14, “ok”)是无类型的，可以赋给任何满在其值域中的类型。Go预定义了三个常量：true, false, iota，其中iota是一个可以被编译器修改的常量，它代表一个整数，在每个const出现时被重置为0，然后iota每出现一次，其所代表的值即自增一次。iota通常用来定义枚举值，这类值应用程序不关心具体数值，只需确保其在同一个const枚举声明中不会冲突即可。</p><pre><code>const (    c0 = iota    // c0 == 0    c1 = iota    // c1 == 1    c2 = iota    // c2 == 2)// 根据枚举定义相同表达式的缩写，等价于const (    c0 = iota    // c0 == 0    c1            // c1 == 1    c2            // c2 == 2)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习一下go中常用的几种数据结构，结合源码了解其实现原理。&lt;/p&gt;
&lt;h2 id=&quot;一-类型系统&quot;&gt;&lt;a href=&quot;#一-类型系统&quot; class=&quot;headerlink&quot; title=&quot;一. 类型系统&quot;&gt;&lt;/a&gt;一. 类型系统&lt;/h2&gt;&lt;h3 id=&quot;1-array&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go 笔记(2) 顺序编程</title>
    <link href="http://wudaijun.com/2016/09/go-notes-2-procedural-programming/"/>
    <id>http://wudaijun.com/2016/09/go-notes-2-procedural-programming/</id>
    <published>2016-09-08T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不定参数-amp-多返回值"><a href="#不定参数-amp-多返回值" class="headerlink" title="不定参数&amp;多返回值"></a>不定参数&amp;多返回值</h2><p>不定参数只能是最后一个参数，它实际上是数组切片参数的语法糖：</p><pre><code>// 语法糖 相当于 func myfunc(args []interface{})func myfunc(args ...interface{}){    for _, arg := range args {    fmt.Println(arg)}// 参数会被打包为 []{arg1,arg2,arg3}myfunc(arg1,arg2,arg3)// 要完成可变参数的完美传递 需要用...将Slice打散func myfunc2(args ...interface{})    // 此时args已经是Slice 如果不打散将作为一个参数 不能完美传递    myfunc(args)    // 编译器在此处有优化 最终会直接将args传入 不会打散再打包 参考: http://www.jianshu.com/p/94710d8ab691    myfunc(args...) end</code></pre><p>多返回值为函数提供了更大的便利性，无需传引用或者专门构造返回值结构体，并且在错误处理方面也更简便，在前面的示例代码中已经初尝甜头。</p><pre><code>// 定义多返回值函数时，可以为返回值指定名字func (file *File) Read(b []byte) (n int, err Error){    // n和err在函数开始时，被自动初始化为空    ...    ... n = xxx    ...    ... err = xxx    ...    // 直接执行return时，将返回n和err变量的值    return}</code></pre><p>多返回值的在Plan9 C编译器上的实现是由调用者在其栈上分配n和err的内存，由被调用方修改调用方栈上的n和err的值：</p><p><img src="/assets/image/go/go-func-call.png" alt=""></p><h2 id="匿名函数-amp-闭包"><a href="#匿名函数-amp-闭包" class="headerlink" title="匿名函数&amp;闭包"></a>匿名函数&amp;闭包</h2><p>匿名函数允许函数像变量一样被定义，传递，和使用。Go语言支持随时在代码里定义匿名函数。</p><pre><code>// 赋给变量F = func (a, b int) int {    return a + b}F(1,2)// 直接执行func (a, b int) int {    return a + b}(1,2)</code></pre><h3 id="1-闭包的概念"><a href="#1-闭包的概念" class="headerlink" title="1. 闭包的概念"></a>1. 闭包的概念</h3><p>闭包是可以包含自由(未绑定到特定对象)变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块(由于自由变量包含在代码块中，所以这些自由变量以及它们所引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)。</p><h3 id="2-闭包的价值"><a href="#2-闭包的价值" class="headerlink" title="2. 闭包的价值"></a>2. 闭包的价值</h3><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一类对象，就是说这些函数可以存储到变量中作为参数传递给其它函数，最重要的是能够被函数动态创建和返回。</p><h3 id="3-Go语言中的闭包"><a href="#3-Go语言中的闭包" class="headerlink" title="3. Go语言中的闭包"></a>3. Go语言中的闭包</h3><p>Go语言中的闭包同样也会引用到函数外的变量，闭包的实现确保只要闭包还被使用，那么闭包引用的变量会一直存在。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">5</span></div><div class="line">    return_closure := <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">(<span class="keyword">func</span>()</span>)</span> &#123;</div><div class="line">        <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            j = j + <span class="number">1</span></div><div class="line">            fmt.Printf(<span class="string">"i, j: %d, %d\n"</span>, i, j)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 同一个闭包c1 共享所有外部环境 i, j</span></div><div class="line">    c1 := return_closure()</div><div class="line">    c1()</div><div class="line">    c1()</div><div class="line"></div><div class="line">    j = j + <span class="number">1</span></div><div class="line">    <span class="comment">// c1 c2 只共享return_closure作用域之外的变量 j</span></div><div class="line">    <span class="comment">// return_closure之内定义的变量i将在每次调用时重新生成，因此只对同一个closure有效</span></div><div class="line">    c2 := return_closure()</div><div class="line">    c2()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出：</span></div><div class="line">i, j: <span class="number">11</span>, <span class="number">6</span></div><div class="line">i, j: <span class="number">12</span>, <span class="number">7</span></div><div class="line">i, j: <span class="number">11</span>, <span class="number">9</span></div></pre></td></tr></table></figure><p>为了实现闭包:</p><ul><li>Go必须有能力识别闭包函数的引用变量(这里的j)，并将它们分配在堆上而不是栈上(escape analyze技术)</li><li>用一个闭包结构体保存函数和其引用环境</li></ul><p>下面分别阐述这两点：</p><h4 id="escape-analyze"><a href="#escape-analyze" class="headerlink" title="escape analyze"></a>escape analyze</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</div><div class="line"><span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">i = <span class="number">5</span></div><div class="line"><span class="keyword">return</span> &amp;i</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在C语言中，在函数中返回该函数栈上的地址是不被允许的，因为当函数调用完成后函数栈会被回收。Go当然也有函数栈和栈回收的概念，因此它将i分配在堆上而不是栈上，通过<code>go tool compile -S x.go</code>查看汇编代码:</p><pre><code>...0x001d 00029 (tmp.go:3) LEAQ    type.int(SB), AX0x0024 00036 (tmp.go:3) MOVQ    AX, (SP)0x0028 00040 (tmp.go:3) PCDATA  $0, $00x0028 00040 (tmp.go:3) CALL    runtime.newobject(SB) // 相当于new(int)0x002d 00045 (tmp.go:3) MOVQ    8(SP), AX // 将i的地址放入AX0x0032 00050 (tmp.go:4) MOVQ    $5, (AX) // 将AX存放的内存地址值设为5...</code></pre><p>也可通过<code>-gcflags=-m</code>选项编译来查看:</p><pre><code>▶ go build --gcflags=-m x.go./tmp.go:2: can inline F./tmp.go:5: &amp;i escapes to heap./tmp.go:3: moved to heap: i</code></pre><p>Go编译器依靠escape analyze来识别局部变量的作用范围，来决定变量分配在堆上还是栈上，这与GC技术是相辅相成的。</p><h4 id="闭包结构体"><a href="#闭包结构体" class="headerlink" title="闭包结构体"></a>闭包结构体</h4><p>闭包结构体在src/cmd/compile/internal/gc/closure.go的walkclosure函数生成，具体实现太过复杂，其注释简要地说明了实现方式：</p><pre><code>// Create closure in the form of a composite literal.// supposing the closure captures an int i and a string s// and has one float64 argument and no results,// the generated code looks like:////    clos = &amp;struct{.F uintptr; i *int; s *string}{func.1, &amp;i, &amp;s}//// The use of the struct provides type information to the garbage// collector so that it can walk the closure. We could use (in this case)// [3]unsafe.Pointer instead, but that would leave the gc in the dark.// The information appears in the binary in the form of type descriptors;// the struct is unnamed so that closures in multiple packages with the// same struct type can share the descriptor.</code></pre><p>比如对我们闭包例子中return_closure生成的闭包，其闭包结构体表示为:</p><pre><code>type.struct{     .F uintptr//闭包调用的函数指针     j *int// 指向闭包的上下文数据，c1,c2指向不同的堆地址}</code></pre><h3 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3. 错误处理"></a>3. 错误处理</h3><p>Go的错误处理主要依靠 <code>panic</code>，<code>recover</code>，<code>defer</code>，前两者相当于throw和catch，而defer则是Go又一个让人惊喜的特性，defer确保语句在函数结束(包括异常中断)前执行，更准备地说，<strong>defer语句的执行时机是在返回值赋值之后，函数返回之前</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">r++</div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* 函数返回: 5</span></div><div class="line">f1等价于:</div><div class="line">func f1() (r int)&#123;</div><div class="line">r = 0 // 返回值赋值</div><div class="line">func() &#123;  // 执行defer函数</div><div class="line">r++</div><div class="line">&#125;()</div><div class="line">return  // 函数返回</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">t := <span class="number">5</span></div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">t = t + <span class="number">5</span></div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> t</div><div class="line">&#125;</div><div class="line"><span class="comment">/*函数返回: 1</span></div><div class="line">f2等价于:</div><div class="line">func f2() (r int) &#123;</div><div class="line">t := 5</div><div class="line">r = t</div><div class="line">func() &#123;</div><div class="line">t = t + 5</div><div class="line">&#125;()</div><div class="line">return</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">r = r + <span class="number">5</span></div><div class="line">&#125;(r)</div><div class="line"><span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/*函数返回: 5</span></div><div class="line">f3等价于:</div><div class="line">func f3()(r int)&#123;</div><div class="line">r = 1</div><div class="line">func(r int) &#123;</div><div class="line">r = r + 5</div><div class="line">&#125;(r) // 值传参 不会影响返回的r的值</div><div class="line">return</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure><p>因此，<code>return x</code>其实不是”原子操作”，在其中会插入defer函数执行，在<a href="https://golang.org/ref/spec#Defer_statements" target="_blank" rel="external">Go官方文档</a>中也提到了这点。</p><p>defer还有如下特性：</p><ol><li>一个函数可定义多个defer语句</li><li>多个defer语句按照先入后出的顺序执行</li><li>defer表达式中的变量值在defer表达式定义时就已经明确</li><li>defer表达式可以修改函数中的命名返回值</li></ol><p>defer的作用：</p><ol><li>简化异常处理(在defetr中recover)，避免异常与控制流程混合(try … catch … finally)</li><li>在defer中做环境清理和资源释放</li></ol><p>更多阅读:</p><ol><li>多返回值和闭包: <a href="https://www.teakki.com/p/57df64ccda84a0c45338154e" target="_blank" rel="external">https://www.teakki.com/p/57df64ccda84a0c45338154e</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不定参数-amp-多返回值&quot;&gt;&lt;a href=&quot;#不定参数-amp-多返回值&quot; class=&quot;headerlink&quot; title=&quot;不定参数&amp;amp;多返回值&quot;&gt;&lt;/a&gt;不定参数&amp;amp;多返回值&lt;/h2&gt;&lt;p&gt;不定参数只能是最后一个参数，它实际上是数组切片参数的
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go 笔记(3) 面向对象和接口</title>
    <link href="http://wudaijun.com/2016/09/go-notes-3-object-oriented/"/>
    <id>http://wudaijun.com/2016/09/go-notes-3-object-oriented/</id>
    <published>2016-09-08T16:00:00.000Z</published>
    <updated>2017-06-05T13:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>探索Go类型扩展，类和继承，以及接口的用法和实现。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-类型扩展"><a href="#1-类型扩展" class="headerlink" title="1. 类型扩展"></a>1. 类型扩展</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// 定义了一个新类型:Integer，与int不能直接比较/赋值</span></div><div class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span> <span class="title">Integer</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> *a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-类和继承"><a href="#2-类和继承" class="headerlink" title="2. 类和继承"></a>2. 类和继承</h3><p>在Go中，传统意义上的类相当于是对struct的类型扩展：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span>&#123;</div><div class="line">    x, y <span class="keyword">float64</span></div><div class="line">    w, l <span class="keyword">float64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rect)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> r.l * r.w</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    c := Rect&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>&#125;</div><div class="line">    fmt.Println(c.Area())</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Go中的继承通过匿名组合实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</div><div class="line">    Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(base *Base)</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Base Foo()"</span>)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(base *Base)</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Base Bar()"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 以组合的方式 定义继承</span></div><div class="line"><span class="comment">// 当derive.xxx在Derive中未找到时，将从基类Base中查找</span></div><div class="line"><span class="comment">// 也可通过derive.Base.xxx直接引用基类Base的方法或成员</span></div><div class="line"><span class="keyword">type</span> Derive <span class="keyword">struct</span> &#123;</div><div class="line">    Base</div><div class="line">    age <span class="keyword">int</span> <span class="comment">// 这里的同名成员将覆盖Base中的成员</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 重写基类方法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Derive)</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Derive Bar()"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    b := Base&#123;<span class="string">"name"</span>&#125;</div><div class="line">    d := Derive&#123;b, <span class="number">99</span>&#125;</div><div class="line">    d.Foo() <span class="comment">// == d.Base.Foo() 语法糖，Foo()函数的接收者只能是Base*</span></div><div class="line">    d.Bar()</div><div class="line">    fmt.Println(d.Name,d.age)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还可以以指针的方式从一个类型派生：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Derive <span class="keyword">struct</span> &#123;</div><div class="line">    *Base</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个时候Derive的初始化需要提供一个Base的指针，它存在的意义类似于C++中的虚基类，很少用到。Go将C++面向对象中一些”黑盒子”放到了台面上来，如this指针(作为一个特殊的参数显现出来)，虚函数表(Go中不允许派生类指针到基类指针的隐式转换，也就无需虚函数表来实现多态)，虚基类(通过显式基类指针，简洁明了的实现了这一需求)。</p><p>Go中没有private public等关键字，要使符号对其它包可见，则需要将该符号定义为大写字母开头。如Base中的Name能被其它引用了Base所在包的代码访问到，而Derive中age则不能。Go中没有类级别的访问控制。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口(interface)是一系列方法声明的组合，同时它本身也是一个类型。</p><h3 id="1-非侵入式接口"><a href="#1-非侵入式接口" class="headerlink" title="1. 非侵入式接口"></a>1. 非侵入式接口</h3><p>侵入式接口是指实现类需要明确声明实现了某个接口，目前C++/Java等语言均为侵入式接口。这类接口的缺点是类的实现方需要知道需求方需要的接口，并提前实现这些接口。这给类设计带来很大困难，因为设计类的时候，你并不知道也不应该关心它会被怎么使用。</p><p>GO中的接口是非侵入式的，接口与类分离，类只需要关心它应该有那些功能(函数)，而无需操心其应该满足哪些接口(契约)，<strong>一个类只要实现了某个接口的所有函数，那么它就实现了这个接口</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IReader <span class="keyword">interface</span>&#123;</div><div class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> IWriter <span class="keyword">interface</span>&#123;</div><div class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</div><div class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> IStream <span class="keyword">interface</span>&#123;</div><div class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> IDevice <span class="keyword">interface</span>&#123;</div><div class="line">    Name() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// File定义无需指定实现接口，直接实现其方法即可</span></div><div class="line"><span class="comment">// 根据File类的实现，可以得到：</span></div><div class="line"><span class="comment">// File类实现了 IDevice接口</span></div><div class="line"><span class="comment">// File*类实现了以上所有接口</span></div><div class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f File)</span> <span class="title">Name</span><span class="params">()</span> <span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Go的非侵入式接口的意义：</p><ol><li>Go语言的标准库，没有复杂的继承树，接口与类之间是平坦的，无需绘制类库的继承树图。</li><li>实现类的时候，只需要关心自己应该提供哪些方法(自身功能)，不用再纠结实现哪些接口，接口由使用方按需定义，而不用事前规划。</li><li>不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。</li></ol><h3 id="2-接口赋值"><a href="#2-接口赋值" class="headerlink" title="2. 接口赋值"></a>2. 接口赋值</h3><p>由于接口本身是一种类型，因此它可被赋值。接口赋值分为两种：将对象赋值给接口和将接口赋值给接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 将对象赋值给接口</span></div><div class="line"><span class="comment">// 赋值条件：对象需实现该接口</span></div><div class="line">f := File&#123;&#125;</div><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">var</span> I1 IDevice = f</div><div class="line"><span class="comment">// ok. Go会根据 func (f File) Name() 自动生成 func (f *file) Name()方法</span></div><div class="line"><span class="keyword">var</span> I2 IDevice = &amp;f</div><div class="line"><span class="comment">// error. File类实现的IFile接口中，有函数的接收者为File*</span></div><div class="line"><span class="comment">// func (f *File) Read(buf []byte) 不能转化为 func (f File) Read(buf []byte)</span></div><div class="line"><span class="comment">// 因为前者可能在函数中改变f，后者不能，可能造成语义上的不一致</span></div><div class="line"><span class="keyword">var</span> I3 IFile = f</div><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">var</span> I4 IFile = &amp;f</div><div class="line"><span class="comment">// 赋值完成之后 可通过接口直接调用对象方法</span></div><div class="line">I1.Name()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 2. 将接口赋值给接口</span></div><div class="line"><span class="comment">// 赋值条件：左值接口需是右值接口的子集</span></div><div class="line"><span class="keyword">var</span> I5 IReader = I1 <span class="comment">// error</span></div><div class="line"><span class="keyword">var</span> I6 IFile   = I3 <span class="comment">// ok</span></div><div class="line"><span class="keyword">var</span> I7 IReader = I3 <span class="comment">// ok</span></div></pre></td></tr></table></figure><h3 id="3-接口查询"><a href="#3-接口查询" class="headerlink" title="3. 接口查询"></a>3. 接口查询</h3><p>既然我们可以将对象或者接口赋值给接口，那么也应该有方法能让我们从一个接口查询出其指向对象的类型信息和接口信息：</p><pre><code>f := File{}// 接口查询var I1 IDevice = f// 判断接口I1指向的对象是否实现了IFile接口I2, ok := I1.(IFile) // ok = false File类型没有实现IFile接口 File*类型实现了// 类型查询// 方法一 type assertionsf2, ok := I1.(File) // ok = true// 方法二 type switch// X.(type)方法只能用在switch语句中switch(I1.(type)){    case int:       // 如果I1指向的对象为int    case File:      // 如果I1指向的对象为File    ...}</code></pre><h3 id="4-接口组合"><a href="#4-接口组合" class="headerlink" title="4. 接口组合"></a>4. 接口组合</h3><p>前面的IFile接口定义等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</div><div class="line">    IReader</div><div class="line">    IWriter</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接口组合可以以更简便的方式复用接口类似于类继承，只不过没有成员变量。</p><h3 id="5-空接口"><a href="#5-空接口" class="headerlink" title="5. 空接口"></a>5. 空接口</h3><p>在Go中的任何对象都满足空接口<code>interface{}</code>，所以<code>interface{}</code>可以指向任何对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> v2 <span class="keyword">interface</span>&#123;&#125; = <span class="string">"abc"</span></div><div class="line"><span class="keyword">var</span> v3 <span class="keyword">interface</span>&#123;&#125; = <span class="keyword">struct</span>&#123; x <span class="keyword">int</span> &#125;&#123;<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> v4 <span class="keyword">interface</span>&#123;&#125; = v3</div></pre></td></tr></table></figure><p><code>interface{}</code>比C++中的<code>void*</code>更强大，比<code>template&lt;&gt;</code>更灵活，结合接口查询和反射，构建底层代码变得非常容易。</p><h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6. 反射"></a>6. 反射</h3><p>简单概括，反射一种检查存储在接口变量(任意类型值)中的“类型-值对”的机制。任何接口变量(包括空接口变量)都包含了其对应的具体类型和值信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="built_in">new</span>(File)</div><div class="line"><span class="keyword">var</span> r IReader</div><div class="line">r = f</div><div class="line">fmt.Println(reflect.TypeOf(r), reflect.ValueOf(r))</div><div class="line"><span class="comment">// 输出: *main.File &amp;&#123;&#125;</span></div><div class="line"><span class="keyword">var</span> w IWriter</div><div class="line">w = r.(IWriter)</div><div class="line">...</div></pre></td></tr></table></figure><p>IReader接口变量只提供了访问Read方法的能力，但其接口变量仍然保存了有关该值的所有类型信息，因此我们可以通过接口查询得到IWriter接口变量。接口的静态类型决定了哪些方法可以通过接口变量调用，但接口变量本身可能包含更大的方法集。</p><p>有了这个机制，我们才能通过反射从任意接口变量，获取对象完整的属性。关于反射的API都在reflect包中提供，通过<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>获取接口变量的Type和Value，reflect为Type和Value提供了大量的方法，如<code>Type.Kind()</code>,<code>Value.Interface()</code>等。</p><p>现在我们尝试通过反射修改接口变量的值：</p><pre><code>var x float64 = 3.4v := reflect.ValueOf(x)v.Set(4.1) // error: cannot use 4.1 (type float64) as type reflect.Value in argument to v.Set</code></pre><p>由于在<code>refect.ValueOf(x)</code>中操作的是x的拷贝，因此实际上v.Set即使能操作成功，也不能如我们预期一般修改x的值。因此reflect提供<code>Value.CanSet()</code>来辨别这类不能成功修改的值：</p><blockquote><blockquote><p>CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic.</p></blockquote></blockquote><p>我们可以通过*float64类型的反射来修改x的值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></div><div class="line">p := reflect.ValueOf(&amp;x)</div><div class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</div><div class="line">fmt.Println(<span class="string">"CanSet of p:"</span> , p.CanSet())</div><div class="line">v := p.Elem()</div><div class="line">fmt.Println(<span class="string">"CanSet of v:"</span> , v.CanSet())</div><div class="line"><span class="comment">// v的地址是有效的(保存在p.Value()中) 因此可以修改</span></div><div class="line">v.SetFloat(<span class="number">7.1</span>)</div><div class="line">fmt.Println(v.Interface())</div><div class="line">fmt.Println(x)</div><div class="line"><span class="comment">// 输出:</span></div><div class="line"><span class="comment">// type of p: *float64</span></div><div class="line"><span class="comment">// CanSet of p: false</span></div><div class="line"><span class="comment">// CanSet of v: true</span></div><div class="line"><span class="comment">// 7.1</span></div><div class="line"><span class="comment">// 7.1</span></div></pre></td></tr></table></figure><h3 id="7-接口实现"><a href="#7-接口实现" class="headerlink" title="7. 接口实现"></a>7. 接口实现</h3><p>接口在实现上是一个结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/runtime/runtime2.go</span></div><div class="line"><span class="comment">// 空接口</span></div><div class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</div><div class="line">_type *_type</div><div class="line">data  unsafe.Pointer</div><div class="line">&#125;</div><div class="line"><span class="comment">// 非空接口</span></div><div class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</div><div class="line">tab  *itab</div><div class="line">data unsafe.Pointer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 所有类型信息结构体的公共部分</span></div><div class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</div><div class="line">size       <span class="keyword">uintptr</span> <span class="comment">// 类型的大小</span></div><div class="line">ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></div><div class="line">hash       <span class="keyword">uint32</span>  <span class="comment">// 类型的Hash值</span></div><div class="line">tflag      tflag  <span class="comment">// 类型的Tags </span></div><div class="line">align      <span class="keyword">uint8</span>   <span class="comment">// 结构体内对齐</span></div><div class="line">fieldalign <span class="keyword">uint8</span>   <span class="comment">// 结构体作为field时的对齐</span></div><div class="line">kind       <span class="keyword">uint8</span>   <span class="comment">// 类型编号</span></div><div class="line">alg        *typeAlg<span class="comment">// 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值</span></div><div class="line">gcdata    *<span class="keyword">byte</span>    <span class="comment">// GC相关信息</span></div><div class="line">str       nameOff   <span class="comment">// 类型名字的偏移</span></div><div class="line">ptrToThis typeOff</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非空接口的类型信息</span></div><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">inter  *interfacetype</div><div class="line">_type  *_type</div><div class="line">link   *itab</div><div class="line">bad    <span class="keyword">int32</span></div><div class="line">inhash <span class="keyword">int32</span></div><div class="line">fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// 方法列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空接口(eface)有两个域，所指向对象的类型信息(_type)和数据指针(data)。_type是go所有类型的公共描述，里面包含GC，反射等需要的细节，这也是它和C void*不同之处。<code>refect.Typeof</code>便提取_type字段用于获取类型信息。</p><p>非空接口(iface)本身除了可以容纳满足其接口的对象之外，还需要保存其接口的方法，因此除了data字段，iface通过tab字段描述非空接口的细节，其中itab.fun保存了该接口的所有方法，此外，itab本身也有_type字段用于实现反射。</p><p>再补充一下_type，_type是所有类型结构体的公共部分，各个类型所需要的类型描述是不一样的，比如chan，除了chan本身外，还需要描述其元素类型，而map则需要key类型信息和value类型信息等:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/runtime/type.go</span></div><div class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</div><div class="line">typ  _type</div><div class="line">elem *_type</div><div class="line">dir  <span class="keyword">uintptr</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</div><div class="line">typ           _type</div><div class="line">key           *_type</div><div class="line">elem          *_type</div><div class="line">bucket        *_type <span class="comment">// internal type representing a hash bucket</span></div><div class="line">hmap          *_type <span class="comment">// internal type representing a hmap</span></div><div class="line">keysize       <span class="keyword">uint8</span>  <span class="comment">// size of key slot</span></div><div class="line">indirectkey   <span class="keyword">bool</span>   <span class="comment">// store ptr to key instead of key itself</span></div><div class="line">valuesize     <span class="keyword">uint8</span>  <span class="comment">// size of value slot</span></div><div class="line">indirectvalue <span class="keyword">bool</span>   <span class="comment">// store ptr to value instead of value itself</span></div><div class="line">bucketsize    <span class="keyword">uint16</span> <span class="comment">// size of bucket</span></div><div class="line">reflexivekey  <span class="keyword">bool</span>   <span class="comment">// true if k==k for all keys</span></div><div class="line">needkeyupdate <span class="keyword">bool</span>   <span class="comment">// true if we need to update key on an overwrite</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些类型信息的第一个字段都是<code>_type</code>，用于描述类型信息的公共部分，接下来是一堆类型需要的其它详细信息，在使用时，拿到一个<code>t *_type</code>，通过<code>(*maptype)(unsafe.Pointer(t))</code>即可得到maptype，chantype和maptype本身引用的其它类型都是<code>*_type</code>也是这个原因。</p><p>更多阅读:</p><ol><li>接口和反射的好文：<a href="https://blog.go-zh.org/laws-of-reflection" target="_blank" rel="external">https://blog.go-zh.org/laws-of-reflection</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;探索Go类型扩展，类和继承，以及接口的用法和实现。&lt;/p&gt;
&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;h3 id=&quot;1-类型扩展&quot;&gt;&lt;a href=&quot;#1-类型扩展
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Linux 作业管理</title>
    <link href="http://wudaijun.com/2016/08/linux-job-control/"/>
    <id>http://wudaijun.com/2016/08/linux-job-control/</id>
    <published>2016-08-29T16:00:00.000Z</published>
    <updated>2016-08-31T01:39:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程组-会话"><a href="#进程组-会话" class="headerlink" title="进程组/会话"></a>进程组/会话</h3><p>简要概念：</p><ul><li>进程组：N(N&gt;=1)个进程的集合，通常在同一作业中关联起来(通过管道)。进程组的ID(PGID)即为进程组组长的PID。进程必定且只能属于一个进程组，只有进程组中一个进程存在，进程组就存在，与组长进程终止与否无关。进程组的概念提出主要是为了进程管理与信号分发</li><li>会话：N(N&gt;=1)个进程组的集合，创建会话的进程叫会话首进程。会话ID即为会话首进程PID</li><li>控制终端：如果会话有控制终端，建立与控制终端连接的会话首进程叫控制进程(通常就是Shell进程)，当前与终端交互的进程组为前台进程组，其余进程组成为后台进程组</li><li>无论合适输入终端的退出键，都会将退出信号发送到前台进程组的所有进程</li><li>如果控制终端断开连接，则将挂掉信号(SIGHUP)发送至控制进程(会话首进程)，SIGHUP信号默认将导致控制进程终止</li></ul><a id="more"></a><p>例如，打开Bash，输入：</p><pre><code>proc1 | proc2 &amp;proc3 | proc4 | proc5</code></pre><p>进程关系如下图所示：</p><p><img src="/assets/image/linux/linux-session-process.png" alt="" title="进程组，会话和控制终端"></p><h3 id="作业控制信号"><a href="#作业控制信号" class="headerlink" title="作业控制信号"></a>作业控制信号</h3><ul><li>SIGCHLD: 子进程终止</li><li>SIGTTIN: 后台进程组成员读控制终端</li><li>SIGTTOU: 后台进程组写控制终端</li><li>SIGCONT:  如果进程已停止，则使其继续运行(fg &amp; bg)</li><li>SIGSTOP: 进程停止信号，不能被捕获或忽略</li><li>SIGTSTP: 交互式停止信号(Ctrl+Z)</li><li>SIGINT: 中断信号(Ctrl+C)</li><li>SIGQUIT: 退出信号(Ctrl+)</li></ul><p>SIGCHILD信号在子进程终止或停止时向父进程发送，系统默认将忽略该信号，如果父进程希望知晓子进程状态变更，应捕获该信号。</p><p>对于SIGTTIN和SIGTTOU信号，在后台作业尝试读取控制终端时，终端驱动程序知道它是个后台作业，于是将向改进程发送SIGTTIN信号，该信号默认将导致进程被挂起(停止)：</p><pre><code>▶ /usr/local/opt/coreutils/libexec/gnubin/cat &gt; file &amp;                                                                                                                   [1] 44978[1]  + 44978 suspended (tty input)  /usr/local/opt/coreutils/libexec/gnubin/cat &gt; file▶ fg                                                                                                                                                                     [1]  + 44978 continued  /usr/local/opt/coreutils/libexec/gnubin/cat &gt; fileHello World! // 重新获得终端 读取输入[Ctrl+D] // 键入EOF</code></pre><p>当后台作业尝试写终端时，默认情况下，后台作业的输出将成功输出到控制终端，但我们可以通过stty命令禁止后台作业向控制终端写，此时终端驱动程序向进程发送SIGTTOU信号：</p><pre><code>▶ /usr/local/opt/coreutils/libexec/gnubin/cat file &amp;[1] 46166Hello World![1]  + 46166 done       /usr/local/opt/coreutils/libexec/gnubin/cat file▶ stty tostop  // 禁止后台作业向控制终端写▶ /usr/local/opt/coreutils/libexec/gnubin/cat file &amp; [1] 46290[1]  + 46290 suspended (tty output)  /usr/local/opt/coreutils/libexec/gnubin/cat file▶ fg[1]  + 46290 continued  /usr/local/opt/coreutils/libexec/gnubin/cat fileHello World!</code></pre><p>注意，在MacOS X上，自带的cat程序有BUG，不是interrupt-safe的，在MacOS X上，尝试恢复cat程序的执行将得到<code>cat: stdin: Interrupted system call</code>错误，<a href="http://factor-language.blogspot.com/2010/09/two-things-every-unix-developer-should.html" target="_blank" rel="external">这篇文章</a>和APUE 9.8节均提到了这个问题，因此我使用的是brew安装的GNU版本cat命令，安装方案参见<a href="https://www.topbug.net/blog/2013/04/14/install-and-use-gnu-command-line-tools-in-mac-os-x/" target="_blank" rel="external">这里</a>。</p><p>关于SIGTSTP和SIGSTOP的区别，前者通常由键盘产生，可被捕获，当通过Ctrl+Z将前台作业放入后台时，前台作业收到该信号，意思是”从哪儿来到哪儿去”。而SIGSTOP通常由kill产生，不可被捕获或忽略，意思是”在那里待着别动”。两者均可由SIGCONT信号恢复运行。</p><p>对于键盘输入产生的信号，控制进程将信号发送至前台进程组的所有进程。</p><p>作业控制信号间有某些交互，当对一个进程产生四种停止信号(SIGTSTP,SIGSTOP,SIGTTIN,SIGTTOU)中的一种时，对该进程的任意未决SIGCONT信号将被丢弃，同样，当产生SIGCONT信号时，对同一进程的任意停止信号将被丢弃。</p><h3 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h3><ul><li>&amp; 将作业放入后台执行，如果没有进行重定向，数据流仍然会输出到前台</li><li>Ctrl+C 强制中断前台当前作业执行</li><li>Ctrl+Z 将作业挂到后台</li><li>jobs -l 查看所有作业，作业ID和其PID</li><li>fg %作业ID 将后台作业拿到前台来处理</li><li>bg %作业ID 将后台作业由挂起变为执行</li><li>kill -signal %作业ID 向指定作业的所有进程发送信号</li></ul><p>作业管理的后台不是系统后台，因此，上述的任务管理依旧与终端有关，当远程连接的终端断开连接时，SIGHUP信号默认将导致改会话上所有的任务都会被中断。</p><h3 id="脱机管理"><a href="#脱机管理" class="headerlink" title="脱机管理"></a>脱机管理</h3><ul><li>nohup: nohup CMD &amp; 将任务放在后台执行，并忽略SIGHUP挂掉信号，但是在人机交互上比较麻烦</li><li>screen: 一个可以在多个进程之间多路复用一个物理终端的窗口管理器，在远端服务器上运行screen，开启一个新会话并执行任务，在终端断开后，任务继续执行，下次登录再attach上screen会话即可，Linux发行版自带</li><li>tmux: 功能类似于screen，但在分屏切换，配置方面更强大，完全可作为本地终端使用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程组-会话&quot;&gt;&lt;a href=&quot;#进程组-会话&quot; class=&quot;headerlink&quot; title=&quot;进程组/会话&quot;&gt;&lt;/a&gt;进程组/会话&lt;/h3&gt;&lt;p&gt;简要概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程组：N(N&amp;gt;=1)个进程的集合，通常在同一作业中关联起来(通过管道)。进程组的ID(PGID)即为进程组组长的PID。进程必定且只能属于一个进程组，只有进程组中一个进程存在，进程组就存在，与组长进程终止与否无关。进程组的概念提出主要是为了进程管理与信号分发&lt;/li&gt;
&lt;li&gt;会话：N(N&amp;gt;=1)个进程组的集合，创建会话的进程叫会话首进程。会话ID即为会话首进程PID&lt;/li&gt;
&lt;li&gt;控制终端：如果会话有控制终端，建立与控制终端连接的会话首进程叫控制进程(通常就是Shell进程)，当前与终端交互的进程组为前台进程组，其余进程组成为后台进程组&lt;/li&gt;
&lt;li&gt;无论合适输入终端的退出键，都会将退出信号发送到前台进程组的所有进程&lt;/li&gt;
&lt;li&gt;如果控制终端断开连接，则将挂掉信号(SIGHUP)发送至控制进程(会话首进程)，SIGHUP信号默认将导致控制进程终止&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="os" scheme="http://wudaijun.com/categories/os/"/>
    
    
      <category term="os" scheme="http://wudaijun.com/tags/os/"/>
    
      <category term="linux" scheme="http://wudaijun.com/tags/linux/"/>
    
  </entry>
  
</feed>
