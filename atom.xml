<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wudaijun&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/eb575f4256a9fe4728b794090470955c</icon>
  <subtitle>Coding is Funny</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wudaijun.com/"/>
  <updated>2018-06-07T15:27:00.000Z</updated>
  <id>http://wudaijun.com/</id>
  
  <author>
    <name>wudaijun</name>
    <email>wdjlost@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一致Hash算法</title>
    <link href="http://wudaijun.com/2018/06/consistent-hashing/"/>
    <id>http://wudaijun.com/2018/06/consistent-hashing/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2018-06-07T15:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h3><p>Hash算法本质是将一个值域(也称定义域，通常更大)映射到另一个值域(通常更小)，比如SHA-2，MD5等。Hash算法有一些共有特性，比如确定性，不可逆性。Hash算法被广泛应用于加密，Hash表，文件校验等领域。</p><p>分布式系统中常用Hash算法来进行任务分配，比如我们要设计一个分布式存储系统，通过Hash算法能够有序均匀地将N个任务分配到M个节点(Hash槽)上:</p><p><img src="/assets/image/201806/hash_sample.png" alt=""></p><p>这里的Hash算法的主要作用是将任务均摊到各个Hash槽中，比如我们有1000W份data和100个node，我们可以简单通过取MD5值再取余的方式来分配任务，代码实现<a href="https://github.com/wudaijun/consistent-hash/blob/master/normal_hash.py" target="_blank" rel="external">normal_hash.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*- </span></div><div class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</div><div class="line"><span class="keyword">import</span> util</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalHash</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, NODES)</span>:</span></div><div class="line">        self.NODES = NODES</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, data)</span>:</span></div><div class="line">        h = util.hash(data)</div><div class="line">        <span class="keyword">return</span> h % self.NODES</div></pre></td></tr></table></figure><p>在我们的分布式存储系统中，我们从两个方面来评估一个Hash算法:</p><ol><li>Hash算法分配是否均匀，即数据是否均匀地分布在各个节点上</li><li>当一个节点挂掉时，需要迁移(即前后Hash不一致)的数据量大小</li></ol><p>我写了个简单的测试用例来评估以上两项，代码实现<a href="https://github.com/wudaijun/consistent-hash/blob/master/test.py" target="_blank" rel="external">test.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">NODES1      = <span class="number">100</span></div><div class="line">NODES2      = <span class="number">99</span></div><div class="line">DATAS       = <span class="number">10000000</span></div><div class="line"></div><div class="line">node_stat1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(NODES1)]</div><div class="line">node_stat2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(NODES2)]</div><div class="line">changes = <span class="number">0</span></div><div class="line"></div><div class="line">// 在这里替换不同的Hash算法</div><div class="line">hash1 = NormalHash(NODES1)</div><div class="line">hash2 = NormalHash(NODES2)</div><div class="line"> </div><div class="line"><span class="keyword">for</span> data <span class="keyword">in</span> xrange(DATAS):</div><div class="line">    n1 = hash1.get_node(data)</div><div class="line">    node_stat1[n1] += <span class="number">1</span></div><div class="line"></div><div class="line">    n2 = hash2.get_node(data)</div><div class="line">    node_stat2[n2] += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> n1 != n2:</div><div class="line">        changes += <span class="number">1</span></div><div class="line"></div><div class="line">util.printNodeStats(DATAS, NODES1, node_stat1)</div><div class="line">print(<span class="string">"--- Node 99 Down: "</span>, node_stat1[<span class="number">99</span>])</div><div class="line">util.printNodeStats(DATAS, NODES2, node_stat2)</div><div class="line">util.printChanges(DATAS, changes)</div></pre></td></tr></table></figure><p>针对我们的NormalHash，输出如下:</p><pre><code>Ave: 100000Max: 100695     (0.69%)Min: 99073      (0.93%)--- Node[99] Down, Datas: 100212Ave: 101010Max: 101731     (0.71%)Min: 100129     (0.87%)Change: 9900142 (99.00%)</code></pre><p>可以看到，基于MD5再取模的Hash算法能够很好地将1000W个任务均摊到各个节点上，但传统Hash存在一个问题，就是当Hash槽变动时，需要对所有关键字重新映射，并导致大量的任务迁移。我们的NormalHash迁移的数据条目数占总条目数的99%，而实际上需要迁移的数据量只有1%左右，也就是说，为了提升1%的可用性，我们需要迁移99%的数据，这无疑是很难接受的。而我们想要这样一种Hash算法，在节点变动时，已映射的条目尽可能不变，只需要迁移变更节点(故障节点或新增节点)上的数据，这就是一致性Hash算法的提出背景。</p><h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>以下是Wiki给出的一致Hash的定义:</p><blockquote><blockquote><p>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的VNode表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p></blockquote></blockquote><h4 id="1-Ring-Hash"><a href="#1-Ring-Hash" class="headerlink" title="1. Ring Hash"></a>1. Ring Hash</h4><p>针对我们上个问题提出的需求，我们可以考虑一种实现：当节点挂掉时，将故障节点上的数据转移到另一个节点上去，其它已有节点和数据的映射不变，这样迁移的数据更少。为了快速找到某个节点的替代节点，可以将所有节点想象成一个环(ring)，每次我们找到这个节点在环上的后继节点:</p><p><img src="/assets/image/201806/hash_ring.png" alt=""></p><p>如图，当Node3挂掉时，其上的Data2将迁移到Node2。我们可以设计一个RingHash类，代码实现<a href="https://github.com/wudaijun/consistent-hash/blob/master/ring_hash.py" target="_blank" rel="external">ring_hash.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingHash</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, NODES)</span>:</span></div><div class="line">        self.NODES = NODES</div><div class="line">        self.ring = []</div><div class="line">        self.hash2node = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> xrange(NODES):</div><div class="line">            h = util.hash(n)</div><div class="line">            self.ring.append(h)</div><div class="line">            self.hash2node[h] = n</div><div class="line">        self.ring.sort()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, data)</span>:</span></div><div class="line">        h = util.hash(data)</div><div class="line">        n = bisect_left(self.ring, h) % self.NODES</div><div class="line">        <span class="keyword">return</span> self.hash2node[self.ring[n]]</div></pre></td></tr></table></figure><p>复用我们上面写的测试用例，看一下测试结果:</p><pre><code>Ave: 100000Max: 596413     (496.41%)Min: 103        (99.90%)--- Node[99] Down, Datas: 65656Ave: 101010Max: 596413     (490.45%)Min: 103        (99.90%)Change: 65656   (0.66%)</code></pre><p>如我们所料，现在迁移率更低了，只会迁移挂掉的节点上的那部分数据，将其移到其环上的下一个节点上。这种方案和NormalHash的本质不同在于RingHash基于范围，在NormalHash中，Hash槽变动会导致Hash环变小([0~99]-&gt;[0~98])，最终变更了数据落在环上位置，而在RingHash中，数据和节点落在Hash环上的位置是不变的(Hash环本身没变)，变更的是位置到节点的映射。<br>现在来看看RingHash的分配效果，出乎意料地差，节点间的数据量差距最大达6000倍。这是因为虽然1000W数据的Hash值分布仍然是相对均匀的，但100个节点的Hash值分布却不是(定义域太小)，这种环形算法在数据分配上面是不能满足需求的。这个算法还有一个问题，就是将故障节点上所有的数据都重新分配到了同一个节点，容易造成热点放大。</p><h4 id="2-Ring-Hash-Virtual-Node"><a href="#2-Ring-Hash-Virtual-Node" class="headerlink" title="2. Ring Hash + Virtual Node"></a>2. Ring Hash + Virtual Node</h4><p>为了让节点的Hash在环上相对分布均匀，我们可以让一个节点对应多个Hash值，即中间加一层虚拟节点(Virtual Node，以下简称VNode)，然后再由虚拟节点映射到真实节点(Node)。</p><p><img src="/assets/image/201806/hash_ring_vnode.png" alt=""></p><p>比如我们让每个Node对应100个VNode，一共10000个VNode的Hash值分布在环上，代码实现<a href="https://github.com/wudaijun/consistent-hash/blob/master/ring_hash_vnode.py" target="_blank" rel="external">ring_hash_vnode.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingHashVNode</span>:</span></div><div class="line">    VNODES = <span class="number">100</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, NODES)</span>:</span></div><div class="line">        self.NODES = NODES</div><div class="line">        self.ring = []</div><div class="line">        self.hash2node = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> xrange(NODES):</div><div class="line">            <span class="keyword">for</span> vn <span class="keyword">in</span> xrange(RingHashVNode.VNODES):</div><div class="line">                <span class="comment"># 根据n和vn简单拼接得到新的独立k</span></div><div class="line">                <span class="comment"># 如n=88 vn=99，则拼接得到"0880000000099"</span></div><div class="line">                k = str(n).zfill(<span class="number">3</span>) + str(vn).zfill(<span class="number">10</span>)</div><div class="line">                h = util.hash(k)</div><div class="line">                self.ring.append(h)</div><div class="line">                self.hash2node[h] = n</div><div class="line">        self.ring.sort()</div><div class="line">        self.ringlen = len(self.ring)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, data)</span>:</span></div><div class="line">        h = util.hash(data)</div><div class="line">        n = bisect_left(self.ring, h) % self.ringlen</div><div class="line">        <span class="keyword">return</span> self.hash2node[self.ring[n]]</div></pre></td></tr></table></figure><p>统计分配情况:</p><pre><code>Ave: 100000Max: 124605     (24.61%)Min: 81856      (18.14%)--- Node[99] Down, Datas: 116555Ave: 101010Max: 125236     (23.98%)Min: 83320      (17.51%)Change: 116555  (1.17%)</code></pre><p>现在数据分配效果理想了很多，数据迁移量也达到最小，并且由于虚节点的存在，被迁移的数据项(分布在环的各个位置)会向就近的VNode迁移，最终相对均匀地落在各个Node上。 </p><h4 id="3-Ring-Hash-Fixed-HashVirtual-Node"><a href="#3-Ring-Hash-Fixed-HashVirtual-Node" class="headerlink" title="3. Ring Hash + Fixed HashVirtual Node"></a>3. Ring Hash + Fixed HashVirtual Node</h4><p>虚拟节点方案本质上通过VNode将节点Hash尽可能更均匀地分布在Hash环上，那么实际上我们可以将Hash环固定地分为N份(N个VNode)，再通过维护VNode到Node的映射来完成任务分配，这样在节点变更时，Hash环也是稳定的，代码实现<a href="https://github.com/wudaijun/consistent-hash/blob/master/ring_hash_fixed_vnode.py" target="_blank" rel="external">ring_hash_fixed_vnode.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingHashFixedVNode</span>:</span></div><div class="line">    VNODES  = <span class="number">10000</span> <span class="comment"># 将整个环分为VNODES份</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, NODES)</span>:</span></div><div class="line">        self.NODES = NODES</div><div class="line">        self.ring = [] <span class="comment"># 下标为VNode 值为对应的Node</span></div><div class="line">        <span class="keyword">for</span> vn <span class="keyword">in</span> xrange(self.VNODES):</div><div class="line">            self.ring.append(vn%NODES)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, data)</span>:</span></div><div class="line">        h = util.hash(data)</div><div class="line">        vn = h%self.VNODES</div><div class="line">        <span class="keyword">return</span> self.ring[vn]</div><div class="line"></div><div class="line">    <span class="comment"># 某个节点挂掉了，将其数据手动均匀分到其它节点上</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node_down</span><span class="params">(self, n)</span>:</span></div><div class="line">        self.NODES -= <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> vn <span class="keyword">in</span> xrange(self.VNODES):</div><div class="line">            <span class="keyword">if</span> self.ring[vn] == n:</div><div class="line">                self.ring[vn] = vn % self.NODES</div></pre></td></tr></table></figure><p>注意到当节点变更之后，我们需要根据当前的VNode-&gt;Node的映射进行变更，因此两次Hash不是独立的，在测试时，我们需要这样生成两次对比的Hash算法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hash1 = RingHashFixedVNode(NODES1)</div><div class="line">hash2 = RingHashFixedVNode(NODES1)</div><div class="line">hash2.node_down(DOWN_NODE_ID)</div></pre></td></tr></table></figure><p>测试结果为:</p><pre><code>Ave: 100000Max: 100695     (0.69%)Min: 99073      (0.93%)--- Node 99 Down, Datas: 100212Ave: 101010Max: 102381     (1.36%)Min: 100087     (0.91%)Change: 100212  (1.00%)</code></pre><p>这个算法不仅数据分配更均匀(1000个固定VNode，比RingHashVNode的10000个VNode分配情况要好得多)，数据迁移量也最少，并且计算上也会更快，因为不需要计算VNode的Hash，也不需要基于范围进行<code>bisect_left</code>插入排序操作，在VNode层级，它和普通Hash一样简单快捷，在节点变更时，变更的只是VNode-&gt;Node的映射，并且通过手动维护这份映射(而不是再次通过自动取余等操作)，将数据迁移降到最低。</p><p>RingHashFixedVNode还有一定的优化空间，比如通过将VNode个数设为2的幂，以通过位运算(&lt;&lt;)来取代取余(%)操作等。这里不再赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hash算法&quot;&gt;&lt;a href=&quot;#Hash算法&quot; class=&quot;headerlink&quot; title=&quot;Hash算法&quot;&gt;&lt;/a&gt;Hash算法&lt;/h3&gt;&lt;p&gt;Hash算法本质是将一个值域(也称定义域，通常更大)映射到另一个值域(通常更小)，比如SHA-2，MD5等。
      
    
    </summary>
    
      <category term="algorithm" scheme="http://wudaijun.com/categories/algorithm/"/>
    
    
      <category term="hash" scheme="http://wudaijun.com/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Flux - Web应用的数据流管理</title>
    <link href="http://wudaijun.com/2018/06/flux-study/"/>
    <id>http://wudaijun.com/2018/06/flux-study/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2018-06-02T02:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>React实际上只是View层的一套解决方案，它将View层组件化，并约定组件如何交互，数据如何在组件内流通等，但实际的Web App除了View层外，还包括Model层，界面响应，服务器请求等，Flux则是Facebook为此给出一套非常简洁的方案，用于管理Web应用程序数据流。与其说Flux是一套框架，不如说其是一套设计模式，因为其核心代码只有几百行，它主要表述的是一种Web应用设计理念和模式。</p><a id="more"></a><p>目前大部分的前端框架(Angular, Vue)都支持双向绑定(MVVM)技术，其中M(Model)指数据层，V(View)指视图层，所谓双向绑定是指Model层发生变化(比如服务器数据更新)，导致对应View层更新，View层产生用户交互，也会反映到Model层。这种机制看起来方便，但在实际应用中，一个Model更新可能导致多个View和Model连锁更新(Cascading Update)。Model可以更新Model，Model可以更新View，View可以更新Model，开发者很难完全掌控数据流，比如到了后期完全不知道View的变化是由那个局部变更导致的。整个关系图看起来像是这样:</p><p><img src="/assets/image/react/mvvm.png" alt=""></p><p> Flux为此给出了单向数据流的解决方案，React的单向数据流指的是View层内部的自顶向下的数据流，这里指的整个Web App 的单向数据流，在Flux中，主要有四个部分:</p><ul><li>View: 在Flux中，View层完全是Store层的展现。它订阅Store的变更(change event)，并反馈到界面上。Flux本身支持你使用任意的前端框架，但Flux的理念与React最为契合(毕竟都源自于Facebook)。</li><li>Store: 即应用数据，Store的数据只能由Action更新(对外只有get方法)，每个Store决定自己响应哪些Action，并更新自身，更新完成之后，抛出变更事件(change event)。</li><li>Action: 描述应用的内部接口，它代表任何能与应用交互的方式(比如界面交互，后台更新等)，在Flux中，Action被简单定义为Type+Data。</li><li>Dispatcher: 如其名，它负责接收所有的Action，并将其派发到注册到它的Store，每个Store都会收到所有的Action。所有的Action都会经由Dispatcher。</li></ul><p>Flux通过加入Dispatcher和Action避免了Model对View的依赖，形成单向数据流:</p><p><img src="/assets/image/react/react-one-way-dataflow.png" alt=""></p><p>假设我们有个Todo应用，在Flux中，一个典型的交互流程如下:</p><ol><li>View层(被挂载时)订阅TodoStore的内容变更</li><li>View层获取TodoStore中所有的TodoList并渲染</li><li>用户在界面上输入一条新Todo内容</li><li>View捕捉到该输入事件，通过Dispatcher派发一个Action，Type为”add-todo”，Data为用户输入的内容</li><li>TodoStore收到这个Action，判断并响应该Action(这个过程叫Reduce)，添加todo内容更新自身，然后抛出更新事件(change event)</li><li>View层收到该change event，从TodoStore中获取最新数据，并刷新显示</li></ol><p>整个流程看起来比双向绑定更麻烦，但实际数据流更清晰可控，这样做有如下好处:</p><ol><li>View层职责很简单，只负责渲染Store变更和触发Action</li><li>每个Store的变更可通过其响应的Action来判断和追踪</li><li>所有的Action都必须经由全局Dispatcher，即”消息汞”</li></ol><p>Flux官方的<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc" target="_blank" rel="external">todomvc</a>是一个很好的入门例子</p><p>总结起来就是，Flux通过将职责细分，将模块变得更干净，然后通过必要的中间组件(如Dispatcher)，让所有的操作和状态都变得容易被追踪，调试。前面提过，Flux本身只是一种设计模式，并针对这种设计模式提供了一个简洁的实现，针对小型项目足以应付。但也有一些缺陷，，比如所有的Store都会收到所有Action，因此基于Flux单向数据流思想，衍生了一些其它第三方状态管理器(state container)，目前最火的是<a href="https://cn.redux.js.org/" target="_blank" rel="external">Redux</a>，它与Flux的主要区别是:</p><ol><li>整个应用只有一个Store</li><li>将Store的State更新操作分离到Reducer中</li><li>Reducer用来处理Action对State树的更改，它是纯函数(替换而不是修改State)，这样每个Reducer维护State树的一部分</li><li>由于只有一个Store，Flux中的Dispather变成了Store的一个函数</li></ol><p>当然，框架这种东西，在思想确定后，根据项目选合适的就行了。并不是越复杂越好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React实际上只是View层的一套解决方案，它将View层组件化，并约定组件如何交互，数据如何在组件内流通等，但实际的Web App除了View层外，还包括Model层，界面响应，服务器请求等，Flux则是Facebook为此给出一套非常简洁的方案，用于管理Web应用程序数据流。与其说Flux是一套框架，不如说其是一套设计模式，因为其核心代码只有几百行，它主要表述的是一种Web应用设计理念和模式。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://wudaijun.com/categories/web/"/>
    
    
      <category term="web" scheme="http://wudaijun.com/tags/web/"/>
    
      <category term="react" scheme="http://wudaijun.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React - Web中的函数式思维</title>
    <link href="http://wudaijun.com/2018/05/react-notes/"/>
    <id>http://wudaijun.com/2018/05/react-notes/</id>
    <published>2018-05-26T16:00:00.000Z</published>
    <updated>2018-06-02T02:20:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6</a>: Javascript 的新标准，主要包括引入class，箭头函数，let, const 新关键字等。</p><p><a href="https://doc.react-china.org/docs/introducing-jsx.html" target="_blank" rel="external">JSX</a>: JSX 是JavaScript 语法扩展，让在 js 中写HTML像模板语言一样方便，最终会编译为js。</p><h3 id="React-特性"><a href="#React-特性" class="headerlink" title="React 特性"></a>React 特性</h3><h4 id="1-组件"><a href="#1-组件" class="headerlink" title="1. 组件"></a>1. 组件</h4><p>React的核心思想便是将UI切分成一些的独立的、可复用的组件，这样你就只需专注于构建每一个单独的部件，达到非常灵活的组件级别的解耦和复用。</p><a id="more"></a><p>组件本质上是函数(ES6的 class仍然基于之前的function prototype实现)，接收任意值，并返回一个 React 元素。组件可以像HTML标签一样被使用:</p><pre><code>// 组件本身，接收 props，返回界面显示元素function Welcome(props) {  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}// 使用Welcome组件提供的 k-v 对将作为props参数(property的缩写)// 其实本质上就是HTML标签的attribute)传入 Welcome 组件const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render(  element,  document.getElementById(&#39;root&#39;));</code></pre><p>上面的组件被称为无状态组件，有状态(state)的组件通常通过 class 实现，通过 render 方法返回界面元素:</p><pre><code>class Clock extends React.Component {  constructor(props) {    super(props);    this.state = {date: new Date()};  }  componentDidMount() {    this.timerID = setInterval(      () =&gt; this.tick(),      1000    );  }  componentWillUnmount() {    clearInterval(this.timerID);  }  tick() {    this.setState({      date: new Date()    });  }  render() {    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;      &lt;/div&gt;    );  }}ReactDOM.render(  &lt;Clock /&gt;,  document.getElementById(&#39;root&#39;));</code></pre><p><a href="https://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="external">CodePen预览</a></p><p>简单来说，组件就是将props和state映射为React 元素。比如 props 可能是一批库存列表，state 可能包含是否勾选了显示无货商品的复选框，然后组件结合这两部分信息，生成对应的 React 元素。</p><p>props对于组件来说是只读的，其字段映射到外部使用该组件时传入的属性(除了 props.children，它代表该组件下定义的所有的子节点)，属性值可以是基础数据类型，回调函数，甚至 React 元素，因此，组件还可以通过提供 propTypes 来验证外部使用组件传入的属性是否符合规范。</p><p>state仅由其所属组件维护，通常是一些和界面显示相关的内部状态(比如是否勾选复选项)，通过<code>this.setState</code>可变更这些状态。React 会追踪这些状态变更并反映到虚拟DOM上，开发者无需关心何时更新虚拟DOM并反馈到真实DOM上，React 可能会将几次setState操作merge为一个来提高性能，用官方的说法，setState是异步更新的。</p><p>元素是 React应用的最小单位，React 当中的元素事实上是普通的对象，比如<code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</code>。React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p><p>每个组件都有自己的生命周期，通过生命周期钩子实现，如componentDidMount，componentWillUnMount等。</p><h4 id="2-虚拟-DOM"><a href="#2-虚拟-DOM" class="headerlink" title="2. 虚拟 DOM"></a>2. 虚拟 DOM</h4><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">DOM Diff</a> ，它可以极大提高网页的性能表现。</p><p>React 中所有的组件被组织为一棵树（虚拟 DOM 树），React将界面视为一个个特定时刻的固定内容（就像一帧一帧的动画），而不是随时处于变化之中（而不是处于变化中的一整段动画）。每个组件只关心如何根据数据(props)和状态(state)得到React元素(element)。而不关心自己何时被渲染，是否需要渲染等细节。React 会在组件的 props 和 state 变更时知晓状态变更，并负责调用render进行渲染(像是”桢驱动”)。如此，组件只负责维护状态和映射，其它的事情(驱动，渲染，优化)React 都帮你做好了。由于 DOM Diff 算法的存在，React会先比较虚拟DOM的差异，在真实 DOM 中只会渲染改变了的部分。</p><h4 id="3-DOM-Diff"><a href="#3-DOM-Diff" class="headerlink" title="3. DOM Diff"></a>3. DOM Diff</h4><p>DOM Diff的用于比较新旧虚拟DOM树，找到最少的转换步骤。这本是O(n^3)的复杂度，React使用启发式算法，复杂度仅为O(n)。这归功于React对Web界面作出的两个假设:</p><ol><li>两个不同类型的元素将产生不同的树。</li><li>通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。</li></ol><p>在实际 Diff 过程中，React只会对同一层次的节点进行比较，如果节点类型不同或者被移动到不同层级，则整个节点(及其子节点)重新插入到真实DOM中。如果节点类型相同，则依靠开发者提供的key属性来优化列表比较。</p><p>因此在实际应用中，保持稳定的 DOM 结构，合理使用key属性可以帮助 React 更好的完成 diff 操作。</p><p>另外，组件的生命周期(生命周期钩子)其实也跟 DOM Diff 有关。</p><h4 id="4-单向数据流"><a href="#4-单向数据流" class="headerlink" title="4. 单向数据流"></a>4. 单向数据流</h4><p>理想情况下，React组件是单向数据流的，任何状态始终由对应组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。即整个数据流是从父组件到子组件的。在实际应用中，组件交互往往会更复杂，React 也提供了一些最佳实践:</p><ul><li>组合而不是继承: 父子组件通过组合而不是继承的方式来实现</li><li>子组件更新父组件: 父组件将自己的回调函数通过 props 传给子组件</li><li>兄弟组件需要共享状态: 将状态提升到其共有的父组件中，或者通过<a href="https://doc.react-china.org/docs/context.html" target="_blank" rel="external">Context</a></li><li>高阶组件: 参数(props)和返回值都是组件的无状态函数，可以完成对组件更高层次的行为模式抽象，<a href="https://doc.react-china.org/docs/higher-order-components.html" target="_blank" rel="external">参考</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>俗话说，没有什么是加一层抽象不能解决的，React虚拟DOM，就像操作系统的虚拟内存等概念一样，极大程度简化了开发者负担。虚拟内存屏蔽了内存换入换出等细节，而虚拟DOM屏蔽了何时渲染，渲染优化等问题，开发只关心架设好虚拟DOM，然后随着状态变更，真实DOM会随时更新。</p><p>React另一个很棒的想法是将界面看作一帧桢的动画，当前状态决定当前界面，React组件本质上就是将局部状态映射为局部界面(动画某一帧的某一部分)，然后组装为整个UI界面(某一帧的定格)。这其中外部输入(props)是只读的，内部状态(state)是可变的，而输出的界面元素(element)是不可变的。</p><p>React 在很多地方都有函数式的影子，比如数据流思想(处理过程输入输出都不可变)，高阶组件(其实就是高阶函数)等，这种思想让开发者理解和调试变得简单，开发者只关心props+state=&gt;element 的映射，React来处理其它的实现细节，如虚拟DOM，DOM Diff(有点像函数式语言实现不可变语义的Copy-On-Write)，以及虚拟DOM到真实DOM的映射等。</p><p>React的单向数据流，是一种非常简单和理想化的模型，虽然有回调函数，高阶组件等方法，但不可避免地，React 也提供了类似 Context 这种全局上下文的概念。这和函数式一样，理念在实践中只是原则而不是规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ES6&lt;/a&gt;: Javascript 的新标准，主要包括引入class，箭头函数，let, const 新关键字等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.react-china.org/docs/introducing-jsx.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSX&lt;/a&gt;: JSX 是JavaScript 语法扩展，让在 js 中写HTML像模板语言一样方便，最终会编译为js。&lt;/p&gt;
&lt;h3 id=&quot;React-特性&quot;&gt;&lt;a href=&quot;#React-特性&quot; class=&quot;headerlink&quot; title=&quot;React 特性&quot;&gt;&lt;/a&gt;React 特性&lt;/h3&gt;&lt;h4 id=&quot;1-组件&quot;&gt;&lt;a href=&quot;#1-组件&quot; class=&quot;headerlink&quot; title=&quot;1. 组件&quot;&gt;&lt;/a&gt;1. 组件&lt;/h4&gt;&lt;p&gt;React的核心思想便是将UI切分成一些的独立的、可复用的组件，这样你就只需专注于构建每一个单独的部件，达到非常灵活的组件级别的解耦和复用。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://wudaijun.com/categories/web/"/>
    
    
      <category term="web" scheme="http://wudaijun.com/tags/web/"/>
    
      <category term="react" scheme="http://wudaijun.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>理解函数式编程</title>
    <link href="http://wudaijun.com/2018/05/understand-functional-programing/"/>
    <id>http://wudaijun.com/2018/05/understand-functional-programing/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-05-13T11:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>源自于我做的一次公司内部的技术分享，这是初稿。 PPT 就不贴了。</p><h2 id="一-序章-可计算模型"><a href="#一-序章-可计算模型" class="headerlink" title="一. 序章: 可计算模型"></a>一. 序章: 可计算模型</h2><p>1936 阿隆佐·邱奇发表可计算函数的第一份精确定义，即<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="external">Lambda演算(λ演算)</a>。λ演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。<br>1936 艾伦·图灵提出<a href="ttps://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="external">图灵机</a>设想，通过TAPE,HEAD,TABLE,STATE四个部分模拟人的纸笔运算<br>1945 冯·诺伊曼提出冯·诺伊曼结构(存储程序型电脑)，是通用图灵机实现<br>1958 约翰·麦卡锡，发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行</p><p>图灵机设想和 Lamdba 演算都是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。图灵机和 Lamdba 演算这两个可计算理论已经被证明是等价的。</p><a id="more"></a><p>函数式的起源Lambda 演算甚至还要早于图灵机，但图灵机由于其更具实现意义，也更容易被理解，因此很早就有了硬件实现基础，而 Lambda 演算是一套更接近软件而非硬件的形式系统，Lambda 演算的第一台硬件则要等到1973年的 MIT 人工智能实验室开发的Lisp机。</p><h2 id="二-什么是函数式编程"><a href="#二-什么是函数式编程" class="headerlink" title="二. 什么是函数式编程"></a>二. 什么是函数式编程</h2><p>函数式编程是一种编程范式，我们常见的编程范式有命令式编程，函数式编程，逻辑式编程，常见的面向对象编程和面向过程编程都是命令式编程。</p><p>命令式编程是面向计算机硬件的抽象，如变量(抽象存储单元)，表达式(算数运算与内存读写)，控制语句(跳转指令)，最终得到一个冯诺依曼机的指令序列。</p><p>函数式编程的基础模型来源于λ演算，是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因为lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的(毕竟是数学家捣鼓出来的东西)。 目前的函数式编程语言基本都是翻译为冯诺依曼指令实现的。</p><h2 id="三-函数式编程概念"><a href="#三-函数式编程概念" class="headerlink" title="三. 函数式编程概念"></a>三. 函数式编程概念</h2><p>变量: </p><ul><li>命令式: 代表存储可变状态的单元(内存地址)，相当于地址的别名  x = x + 1</li><li>函数式: 代表数学函数中的变量，映射到某个值，相当于值的别名  2x = 4</li></ul><p>函数:</p><ul><li>命令式: 描述求解过程(怎么做)，本质上是一系列的冯诺依曼机指令，can do anything</li><li>函数式: 数学概念里的函数，描述映射(计算)关系(做什么)，也称为纯函数/无状态函数</li></ul><h2 id="四-函数式编程特性"><a href="#四-函数式编程特性" class="headerlink" title="四. 函数式编程特性"></a>四. 函数式编程特性</h2><h3 id="1-不可变语义"><a href="#1-不可变语义" class="headerlink" title="1. 不可变语义"></a>1. 不可变语义</h3><p>比如我们有一个 Point类，其 moveBy 方法对 x,y 坐标进行偏移，得到新的 Point 对象:</p><pre><code>// 命令式写法: 直接修改内存值func (p *Point) moveBy(deltaX, deltaY int) {    p.x = p.x + deltaX    p.y = p.y + deltaX}// 函数式写法: 新建一个 Point 对象，函数本身只需关心对象的映射，而非对象复用等实现细节。在语义上，新旧 Point 代表完全独立并可不变的两个&quot;Point 值&quot;。func moveBy(p *Point, deltaX, deltaY int) *Point {    return &amp;Point{        x:    p.x+deltaX,        y:    p.y+deltaY,    }}</code></pre><p>没有可变状态，也就没有 for, while 循环，使得函数式编程严重依赖递归。</p><p>这里的不可变，指的是语义上的不可变，而非其底层实现上的不变。比如Erlang 虚拟机用 C 实现，通过写时拷贝来实现不可变语义，但针对比如binary 升级，Pid打包等，虽然底层的实现结构可能会改变，但对应用层来说语义是不变的。</p><h3 id="2-纯函数"><a href="#2-纯函数" class="headerlink" title="2. 纯函数"></a>2. 纯函数</h3><ul><li>确定性: 相同输入得到相同输出，函数的返回值和参数以外的其他隐藏信息或状态无关</li><li>无副作用: 函数不能有语义上可观察的副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外对象的内容等</li></ul><p>纯函数都是显式数据流的，即所有的输入都通过参数传入，所有输出都通过返回值传出。</p><p>纯函数即无状态函数，微服务中的无状态服务也有一个无状态似，但关注的是整个处理流程的无状态，即把状态往两边推到输入(如Network)和输出(DB，Cache，Log 等)，这样服务能够横向扩展和动态伸缩(就像一个巨大的纯函数)。而对函数式而言，理论上演算过程中的任一处理步骤(每次函数调用)都是无状态的，因此可伸缩和并发的粒度更小。</p><p>在实现上，无状态和不可变语义一样，是语义上的，无状态是指函数本身不能有可以改变状态的指令，从系统层次上来看，要说绝对没状态是不可能的，比如调用函数会导致进程栈增长，页面换入换出等。另外，在 Haskell 语言中，还有惰性求值，会使得在执行纯函数时执行一些外部操作(比如文件 IO)。因此从这个角度来看，我们用命令式语言也可以实现无状态效果。</p><h3 id="3-递归与尾递归"><a href="#3-递归与尾递归" class="headerlink" title="3. 递归与尾递归"></a>3. 递归与尾递归</h3><p>递归在几乎所有命令式编程语言中都有，即函数调用自身，在函数式编程中，由于没有可变状态，for, while 循环都只能通过递归来实现，因此函数式编程严重依赖递归:</p><p>以阶乘为例:<br><img src="leanote://file/getImage?fileId=5ad172004a714562e4000001" alt=""></p><pre><code>// 自底向上，递推求解func fact_1(n int) int {    acc := 1    for k:=1; k&lt;=n; k++ {        acc = acc*k    }    return acc}//  自顶向下，递归求解func fact_2(n int) int {    if n == 0 {        return 1    } else {        return fact_2(n-1)*n    }}// 自顶向下，递归求解 - Erlangfact(N) when N == 0 -&gt; 1;fact(N) when N &gt; 0 -&gt; N*fact(N-1).// 递归求解 - Erlang - 尾递归版fact1(N) -&gt; fact(1, N).fact(Acc, N) when N == 0 -&gt; Acc;fact(Acc, N) when N &gt; 0 -&gt; fact(Acc*N, N-1).</code></pre><p>我们知道在现代冯诺依曼结构计算机中，递归和普通函数一样，是通过函数调用栈来实现的，为了防止函数栈肆意扩展(导致栈溢出)，通常函数式语言的编译器都会实现尾调用优化。尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。这种情况下，函数可以直接复用当前函数栈的栈空间执行尾调用，减少栈空间使用并提高效率。(尾递归是函数式基于命令式语言实现时的一个实现上的优化(栈空间是有限的)，并非Lamda 演算本身的内容。)</p><p>递归是函数式中非常核心的一个概念，其在函数式语言中的低位要比在命令式语言高很多，理解递归是理解函数式的基础。递归是另一种我们思考和解决问题的方式，在一些情景下，使用递归会让问题简化许多。比如经典的找零钱问题:</p><pre><code>// 若干面值钞票，给一张大面值货币要兑换成零钱，求有多少种兑换方式// 递归版本func countChange(money int, coins []int) int {    if money &lt; 0 || len(coins) == 0 {        return 0    }    if money == 0 {        return 1    }    return countChange(money, coins[1:]) + countChange(money-coins[0], coins)}// 迭代版本func countChange2(changes []int, money int) int {    n  := len(changes)    dp := make([]int, money+1)    for i:=1; i&lt;=money; i++ {        dp[i] = 0    }    dp[0] = 1    for i:=0; i&lt;n; i++ {        for j:=changes[i]; j&lt;=money; j++{            dp[j] += dp[j-changes[i]]        }    }    return dp[money]}</code></pre><p>可以看到，递归版比迭代版要容易理解得多，后者需要手动维护状态，而前者将状态隐藏到递归过程中了。类似的还有背包问题，都是理解递归很好的例子。</p><h3 id="4-惰性求值-乱序求值"><a href="#4-惰性求值-乱序求值" class="headerlink" title="4. 惰性求值/乱序求值"></a>4. 惰性求值/乱序求值</h3><p>表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p><pre><code>A = dosomething1()B = dosomething2(A)C = dosomething3()    </code></pre><p>编译器很容易就可以推断出，A-&gt;B 和 C 可以乱序(无状态)或者并行(不可变语义)执行，并且对 A，B，C 的求值可以等到它们被引用的时候再计算，因此函数式本身是比较好优化的。</p><p>Haskell 语言天生就是惰性的，你可以用<code>[1..]</code>表示1到无穷大的列表，只要有获取这个列表的第 N 个元素时，Haskell 才会去计算它:<code>[1..] !! 999</code>返回列表中下标为999的元素，这里会计算1-1000的列表，最终返回1000。另外个例子，如果 xs 是一个列表，doubleMe 会将 xs 中的元素*2，那么在Haskell中，doubleMe(doubleMe(doubleMe(xs)))只会遍历列表一次。</p><h3 id="5-柯里化-currying"><a href="#5-柯里化-currying" class="headerlink" title="5. 柯里化(currying)"></a>5. 柯里化(currying)</h3><p>柯里化:将一个多参数函数分解成多个单参数函数，然后将单参函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。比如前面我们的尾递归版阶乘计算，可以写成:</p><pre><code>fact2(Acc) -&gt;    fun(N) -&gt; fact(Acc, N) end.F = fact2(1)F(10)</code></pre><p>换成 Lua 可能更容易理解，比如我们有两个参数的 add :</p><pre><code>add = function(x, y)    return x + yendprint(add(3,4))</code></pre><p>可将其柯里化为:</p><pre><code>add = function(x)    return function(y)        return x + y    endendprint(add(3)(4)) </code></pre><p>上面我们列举的柯里化看起来很像Lua,Go等语言中的闭包(词法闭包，Lexical Closure)，实际上柯里化是Lambda 演算中的概念，用于简化推导流程。闭包只是一种实现方式，如C++ STL 的<code>bind1st</code>和<code>bind2nd</code>也可以实现固化函数参数的作用。 </p><p>柯里化所要表达是:如果你固定某些参数，你将得到接受余下参数的一个函数,所以对于有两个变量的函数x+y，如果固定了x=3，则得到有一个变量的函数3+y(是不是很像多项式一个一个变量求解)。这就是求值策略中的部分求值策略。柯里化具有延迟计算、参数复用、动态生成函数的作用。</p><h3 id="6-高阶函数"><a href="#6-高阶函数" class="headerlink" title="6. 高阶函数"></a>6. 高阶函数</h3><p>函数式的要义之一就是将函数当做普通对象一样，可以被当做参数传递，也可以作为函数返回值(在λ演算创始人阿隆佐·邱奇的眼里，一切且函数，变量也是函数)。所谓高阶函数就是以函数为参数或返回值的函数，有了高阶函数，就可以将复用的粒度降至函数级别，相对面向对象而言，复用粒度更低。</p><pre><code>sumInts(A, B) when A &gt; B -&gt; 0;sumInts(A, B) -&gt; A + sumInts(A+1, B).sumFacts(A, B) when A &gt; B -&gt; 0;sumFacts(A, B) -&gt; fact1(A) + sumFacts(A+1, B).sum(F, A, B) when A &gt; B -&gt; 0;sum(F, A, B) -&gt; F(A) + sum(F, A+1, B).&gt; sum(fun fact1/1, 3, 6)</code></pre><p>函数式语言通常提供了非常强大的”集合类”，可以基于高阶函数提供便捷的集合操作:</p><pre><code>37&gt; L = [1,2,3].[1,2,3]38&gt; lists:map(fun(E) -&gt; 2*E end, L).[2,4,6]39&gt; lists:foldl(fun(E, Acc) -&gt; Acc+E end, 0, L).6</code></pre><p>得益于函数式的无状态和不可变语义，将lists:map 函数改写为并发执行的 map 只需几十行代码，安全无副作用。</p><p>可能接触过面向对象编程的人都接触或使用过设计模式，在函数式编程里面，通过 function 实现设计模式要比 class, interface 那一套要简洁灵活得多。比如lists:map本身就是一个很好用的访问者模式。</p><h3 id="7-Monad"><a href="#7-Monad" class="headerlink" title="7. Monad"></a>7. Monad</h3><p>前面提到，函数式中变量不可变，且纯函数没有副作用，那么函数式如何处理可变状态比如 IO 呢，在 Erlang 里，IO 通过 C 实现，即引入了可变性和副作用，并且 Erlang没有对这种副作用代码和纯代码分隔开，这得依靠程序员来做。而纯函数式语言 Haskell 采用了另一种方案: Monad。</p><p>单子(Monad)是来自范畴论中的概念，范畴论是数学的一门学科，以抽象的方法来处理数学概念，将这些概念形式化成一组组的“对象”及“态射”。</p><p>Monad 的概念被引入到 Haskell，表示”注入”和”提取”的概念，用于处理 IO，串联函数等。</p><p>Haskell严格地把纯代码从那些有副作用的代码(如 IO)中分隔开。就是说，它给纯代码提供了完全的副作用隔离。除了帮助程序员推断他们自己代码的正确性，它还使编译器可以自动采取优化和并行化成为可能。而 Monad 加上 Haskell 的类型类即成为分离纯函数和副作用函数的利器:</p><p><img src="/assets/image/haskell-monad.png" alt=""></p><p><a href="http://zhuoqiang.me/what-is-monad.html" target="_blank" rel="external">图片出处</a></p><p>上图说明了 Haskell 如何通过 Monad 管理纯函数副作用函数。具体到代码，看起来像是这样:</p><pre><code>name2reply :: String -&gt; Stringname2reply name =    &quot;Pleased to meet you, &quot; ++ name ++ &quot;.\n&quot; ++    &quot;Your name contains &quot; ++ charcount ++ &quot; characters.&quot;    where charcount = show (length name)main :: IO ()main = do       putStrLn &quot;Greetings once again.  What is your name?&quot;       inpStr &lt;- getLine       let outStr = name2reply inpStr       putStrLn outStr</code></pre><p>Haskell在纯代码和I/O动作之间做了很明确的区分。很多语言没有这种区分。 在C或者Java(包括 Erlang)这样的语言中，编译器不能保证一个函数对于同样的参数总是返回同样的结果，或者保证函数没有副作用。程序中的很多错误都是由意料之外的副作用造成的。做好这种隔离有利于程序员和编译器更好地思考和优化程序。</p><h2 id="五-函数式的优缺点"><a href="#五-函数式的优缺点" class="headerlink" title="五. 函数式的优缺点"></a>五. 函数式的优缺点</h2><ul><li>并发性: 函数无副作用(天然可重入)，原生并发友好</li><li>确定性: 可读性高，易于测试和调试，错误易于重现</li><li>没有锁和指针就没有伤害</li><li>具有很大的优化潜力，如惰性求值，并发，缓存函数计算结果等，很多原本需要程序来做的事情，都可以由编译器来做。比如动态规划的缓存，MapReduce 等。</li></ul><p>缺点:</p><ul><li>处理可变状态如 IO 的能力弱(要么使用可变状态，要么使用 Monad)</li><li>为了维持不可变性，拷贝的开销</li><li>运行效率，依靠并发</li></ul><h2 id="六-函数式的实现"><a href="#六-函数式的实现" class="headerlink" title="六. 函数式的实现"></a>六. 函数式的实现</h2><h3 id="1-Erlang"><a href="#1-Erlang" class="headerlink" title="1. Erlang"></a>1. Erlang</h3><p>Erlang 不是一门纯函数式语言(提供了外部可变状态组件，如进程字典，Ets)，但它充分利用函数式的无状态和不可变语义，将函数式的各种优势很好地利用了起来。Erlang 的具体介绍和细节我们就谈了，我着重讲一下其三个让其它语言”眼红”的三个特性:</p><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h4><p>Erlang 是 Actor 模型，一个 Actor 即一个 Erlang 进程，创建一个进程是微秒级的。Erlang 可以说是最早支持协程的语言之一，Actor 与 Actor 之间通过消息交互，加上不可变语义，使得 Erlang 比其它语言更易于实现安全的并发(Erlang/OTP并发编程实践作者将共享内存比作这个时代的goto)。</p><h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><p>说起代码热替换，估计没有语言比 Erlang 做得更好了，这是 Erlang 的黑科技，一个用了你就回不去的功能。热更新对于游戏服务器的意义是很大的，游戏开发版本更新快，有时候有些不大不小的问题(比如一些调试日志忘删除了，某个小功能可能无法使用)，通过重启来解决的代价太大(用户流失)，用 Erlang 直接无缝热更，比无缝重启要方便快捷太多。</p><p>热更新的原理是代码版本替换，一方面仰仗于Erlang运行时的代码加载机制，另一方面，函数式也功不可没，一个具有内部状态的函数是很难做热更新的。</p><h4 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h4><p>Erlang 有一个很有意思的slogan，叫”let it crash”，这看起来与命令式编程中的”defensive coding(防御式编程)”背道而驰，在大型分布式程序的构建过程中，代码会遇到各种各样的异常，代码编写者不可能或者说很难预料并且处理到所有的异常，在这个背景下，Erlang 提出”let it crash” 的概念: 既然未预料的异常无可避免，那么就应该统一隔离处理并且恢复它，注意，这里提到了三个词: 错误隔离，错误处理和故障恢复，大部分语言最多做到第一步(比如 Go 语言)，而 Erlang 把整个三步都做到了虚拟机中。一个进程挂了，会由监督者发现，并且根据重启策略重启。 Actor 的状态隔离与轻量为整个容错性提供基础保障。</p><p>总的来说，Erlang 在并发，健壮性，可伸缩性方面，都有非常出色的表现。适用于 IO 密集型的软实时系统(设计之初就是为了解决电信通信问题的)。</p><h3 id="2-Haskell"><a href="#2-Haskell" class="headerlink" title="2. Haskell"></a>2. Haskell</h3><p>Erlang并不是一门纯函数式语言的话，进程字典，ets，IO 等状态性和副作用，Haskell 则剑走偏锋，号称是纯函数式语言。Haskell 我只看了一部分，以下是一些基础特性:</p><ul><li>支持惰性求值</li><li>更彻底的函数(+,-)</li><li>静态类型系统 + 类型推导 + 强大的typeclass (==, Functor)，支持自定义类</li><li>原生柯里化(<code>map (+1) [1,2,3]</code>)</li><li>引入范畴论的 Monad</li></ul><h2 id="七-最后"><a href="#七-最后" class="headerlink" title="七. 最后"></a>七. 最后</h2><h4 id="1-为什么函数式没有崛起"><a href="#1-为什么函数式没有崛起" class="headerlink" title="1. 为什么函数式没有崛起?"></a>1. 为什么函数式没有崛起?</h4><p>图灵机是一个具备实现意义的 model，或者换句话说，lambda 演算则是更抽象，更上层的计算模型，图灵机也更符合人解决问题的方式(纸笔推演)，更容易被没有数学背景的工程师所理解，因此很快在现实世界中实现推广。</p><p>一个有意思的论题是Worse Is Better，由 Common Lisp 专家Richard P. Gabriel在90年代反思 Lisp 这么牛的语言却日渐式微提出的观点，他提出软件设计有以下四大目标: 简单性，正确性，一致性，完整性</p><ul><li>函数式语言: 正确性 = 一致性 &gt; 完整性 &gt; 简单(为了接口简单，宁愿实现复杂) </li><li>命令式语言: 简单性（实现简单优于接口简单）&gt; 正确性 &gt; 完整性 &gt; 一致性</li></ul><p>原文 Worse Is Better 中的 Worse 是指C/Unix将其简单性优于其它目标的做法(在作者看来是糟糕的)，Better 是指 C/Unix 当下的处境(当然是非常流行)，因此可以粗略理解为”简单的就是好的”。作者将C/Unix 的流行归功于他们实现简单，使得其像”病毒”一样可快速移植到与传播，用户也更愿意接受，等到用户产生依赖，再逐步完善。</p><p>当然，可能还有一个原因，那个年代计算机是稀缺资源，比较注重效率，而在冯诺依曼机上的实现的函数式语言自然没有早期的命令式语言快，自然也让 C，C+这类”简单粗暴”的语言飞速推广。再借助 OS，编译器等形成生态。</p><h4 id="2-函数式近几年开始受到更多的关注"><a href="#2-函数式近几年开始受到更多的关注" class="headerlink" title="2. 函数式近几年开始受到更多的关注"></a>2. 函数式近几年开始受到更多的关注</h4><p>由于软件复杂度和 CPU 核数的增加，多线程和其他形式的并行化变得越来越普遍， 管理全局副作用变得越来越困难，函数式的好处(正确性和一致性)开始体现出来，几十年前写的 Erlang 代码放到今天，无需任何改动，核数越多，跑得越快，因此现在的软件设计理念都会从函数式思想中学习一些东西。</p><p>从设计上来讲，现代语言都或多或少吸收了函数式的一些特性: 如function，闭包，尾递归，高阶函数等等。从理念上来讲，函数式的无状态为并发提供了另一种解决方案，比如近几年推崇的无状态服务设计，Erlang 的 Actor 模型等。</p><p>如今很多语言都支持多种编程范式，一些函数式语言也有可变状态，一些命令式语言支持部分函数式特性，理解函数式可以扩展我们解决问题的思路，找到更简洁有效的解决方案，如递归而不是迭代，函数注入而不是对象注入等。最后，我认为每个程序员都可以去学习一门函数式语言，扩展自己的思维，写出更灵活，安全，”纯洁”的代码。</p><p>参考:</p><ol><li><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="external">什么是函数式思维?</a></li></ol><p>Haskell:</p><ol><li><a href="http://cnhaskell.com/chp/7.html" target="_blank" rel="external">Real World Haskell 中文版</a></li><li><a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">图解 Monad</a></li><li><a href="http://zhuoqiang.me/what-is-monad.html" target="_blank" rel="external">Monad 最简介绍</a></li><li><a href="http://yi-programmer.com/2010-04-06_haskell_and_category_translate.html" target="_blank" rel="external">Haskell 与范畴轮</a></li><li><a href="https://learnyoua.haskell.sg/content/zh-cn/ch11/functors-applicative-functors-and-monoids.html" target="_blank" rel="external">Haskell 趣学指南</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源自于我做的一次公司内部的技术分享，这是初稿。 PPT 就不贴了。&lt;/p&gt;
&lt;h2 id=&quot;一-序章-可计算模型&quot;&gt;&lt;a href=&quot;#一-序章-可计算模型&quot; class=&quot;headerlink&quot; title=&quot;一. 序章: 可计算模型&quot;&gt;&lt;/a&gt;一. 序章: 可计算模型&lt;/h2&gt;&lt;p&gt;1936 阿隆佐·邱奇发表可计算函数的第一份精确定义，即&lt;a href=&quot;https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lambda演算(λ演算)&lt;/a&gt;。λ演算是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。&lt;br&gt;1936 艾伦·图灵提出&lt;a href=&quot;ttps://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;图灵机&lt;/a&gt;设想，通过TAPE,HEAD,TABLE,STATE四个部分模拟人的纸笔运算&lt;br&gt;1945 冯·诺伊曼提出冯·诺伊曼结构(存储程序型电脑)，是通用图灵机实现&lt;br&gt;1958 约翰·麦卡锡，发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行&lt;/p&gt;
&lt;p&gt;图灵机设想和 Lamdba 演算都是一种抽象计算模型，是解决可计算问题的一种方案，通俗来讲，就是将计算以数学的方式抽象化，以便证明和推导。图灵机和 Lamdba 演算这两个可计算理论已经被证明是等价的。&lt;/p&gt;
    
    </summary>
    
      <category term="programing" scheme="http://wudaijun.com/categories/programing/"/>
    
    
      <category term="programing" scheme="http://wudaijun.com/tags/programing/"/>
    
  </entry>
  
  <entry>
    <title>go pprof 性能分析</title>
    <link href="http://wudaijun.com/2018/04/go-pprof/"/>
    <id>http://wudaijun.com/2018/04/go-pprof/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-04-08T11:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-pprof-数据采样"><a href="#一-pprof-数据采样" class="headerlink" title="一. pprof 数据采样"></a>一. pprof 数据采样</h3><p>pprof 采样数据主要有三种获取方式:</p><ul><li><strong>runtime/pprof</strong>: 手动调用<code>runtime.StartCPUProfile</code>或者<code>runtime.StopCPUProfile</code>等 API来生成和写入采样文件，灵活性高</li><li><strong>net/http/pprof</strong>: 通过 http 服务获取Profile采样文件，简单易用，适用于对应用程序的整体监控。通过 runtime/pprof 实现</li><li><strong>go test</strong>: 通过 <code>go test -bench . -cpuprofile prof.cpu</code>生成采样文件 适用对函数进行针对性测试</li></ul><a id="more"></a><h4 id="1-1-net-http-pprof"><a href="#1-1-net-http-pprof" class="headerlink" title="1.1 net/http/pprof"></a>1.1 net/http/pprof</h4><p>在应用程序中导入<code>import _ &quot;net/http/pprof&quot;</code>，并启动 http server即可:</p><pre><code>// net/http/pprof 已经在 init()函数中通过 import 副作用完成默认 Handler 的注册go func() {    log.Println(http.ListenAndServe(&quot;localhost:6060&quot;, nil))}()</code></pre><p>之后可通过 <a href="http://localhost:6060/debug/pprof/CMD" target="_blank" rel="external">http://localhost:6060/debug/pprof/CMD</a> 获取对应的采样数据。支持的 CMD 有:</p><ul><li>goroutine: 获取程序当前所有 goroutine 的堆栈信息。</li><li>heap: 包含每个 goroutine 分配大小，分配堆栈等。每分配 runtime.MemProfileRate(默认为512K) 个字节进行一次数据采样。</li><li>threadcreate: 获取导致创建 OS 线程的 goroutine 堆栈</li><li>block: 获取导致阻塞的 goroutine 堆栈(如 channel, mutex 等)，使用前需要先调用 <code>runtime.SetBlockProfileRate</code></li><li>mutex: 获取导致 mutex 争用的 goroutine 堆栈，使用前需要先调用 <code>runtime.SetMutexProfileFraction</code></li></ul><p>以上五个 CMD 都通过<a href="https://github.com/golang/go/blob/release-branch.go1.9/src/runtime/pprof/pprof.go#L135" target="_blank" rel="external">runtime/pprof Profile</a> 结构体统一管理，以 Lookup 提供统一查询接口，有相似的返回值(goroutine 堆栈)，它们都支持一个 debug  URL参数，默认为0，此时返回的采样数据是不可人为解读的函数地址列表，需要结合 pprof 工具才能还原函数名字。 debug=1时，会将函数地址转换为函数名，即脱离 pprof 在浏览器中直接查看。对 goroutine CMD来说，还支持 debug=2，此时将以 unrecovered panic 的格式打印堆栈，可读性更高。如启用<code>net/http/pprof</code>后，<a href="http://localhost:6060/debug/pprof/goroutine?debug=2" target="_blank" rel="external">http://localhost:6060/debug/pprof/goroutine?debug=2</a> 的响应格式为:</p><pre><code>goroutine 18 [chan receive, 8 minutes]:ngs/core/glog.logWorker(0x18b548a, 0x4, 0x7fff5fbffb0e, 0x0, 0x3, 0xc4200e31a0, 0xc4203627c4)    /Users/wudaijun/go/src/ngs/core/glog/worker.go:43 +0x19ccreated by ngs/core/glog.newLogger    /Users/wudaijun/go/src/ngs/core/glog/glog.go:51 +0xe4goroutine 6 [syscall, 8 minutes]:os/signal.signal_recv(0x0)    /usr/local/Cellar/go/1.9.1/libexec/src/runtime/sigqueue.go:131 +0xa7os/signal.loop()    /usr/local/Cellar/go/1.9.1/libexec/src/os/signal/signal_unix.go:22 +0x22created by os/signal.init.0    /usr/local/Cellar/go/1.9.1/libexec/src/os/signal/signal_unix.go:28 +0x41goroutine 50 [select, 8 minutes]:context.propagateCancel.func1(0x1cfcee0, 0xc42017a1e0, 0x1cf3820, 0xc42005b480)    /usr/local/Cellar/go/1.9.1/libexec/src/context/context.go:260 +0x113created by context.propagateCancel    /usr/local/Cellar/go/1.9.1/libexec/src/context/context.go:259 +0x1da...</code></pre><p>以上几种 Profile 可在 <a href="http://localhost:6060/debug/pprof/" target="_blank" rel="external">http://localhost:6060/debug/pprof/</a> 中看到，除此之外，go pprof 的 CMD 还包括:</p><ul><li>cmdline: 获取程序的命令行启动参数</li><li>profile: 获取指定时间内(从请求时开始)的cpuprof，倒计时结束后自动返回。参数: seconds, 默认值为30。cpuprofile 每秒钟采样100次，收集当前运行的 goroutine 堆栈信息。  </li><li>symbol: 用于将地址列表转换为函数名列表，地址通过’+’分隔，如 URL/debug/pprof?0x18d067f+0x17933e7</li><li>trace: 对应用程序进行执行追踪，参数: seconds, 默认值1s</li></ul><p>这几个 CMD 因为各种原因没有整合到 Profile 结构中去，但就使用上而言，是没有区别的，URL格式是一致的，因此可以看做一个整体，从各个角度对系统进行数据采样和分析。</p><h4 id="1-2-runtime-pprof"><a href="#1-2-runtime-pprof" class="headerlink" title="1.2 runtime/pprof"></a>1.2 runtime/pprof</h4><p><code>runtime/pprof</code>提供各种相对底层的 API 用于生成采样数据，一般应用程序更推荐使用<code>net/http/pprof</code>，<code>runtime/pprof</code> 的 API 参考<a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="external">runtime/pprof</a>或 <a href="https://github.com/golang/go/blob/release-branch.go1.9/src/net/http/pprof/pprof.go" target="_blank" rel="external">http pprof 实现</a>。</p><h4 id="1-3-go-test"><a href="#1-3-go-test" class="headerlink" title="1.3 go test"></a>1.3 go test</h4><p>通常用<code>net/http/pprof</code>或<code>runtime/pprof</code>对应用进行整体分析，找出热点后，再用<code>go test</code>进行基准测试，进一步确定热点加以优化并对比测试。</p><pre><code># 生成 test 二进制文件， pprof 工具需要用到▶ go test -c -o tmp.test # 执行基准测试 BenchAbc，并忽略任何单元测试，test flag前面需要加上&#39;test.&#39;前缀▶ tmp.test -test.bench BenchAbc -test.run XXX test.cpuprofile cpu.prof     # 与上面两条命令等价，只不过没有保留 test 二进制文件▶ go test -bench BenchAbc -run XXX -cpuprofile=cpu.prof .</code></pre><p><code>go test</code>可以直接加<code>-cpuprofile</code> <code>-mutexprofilefraction</code>等参数实现prof数据的采样和生成，更多相关参数参考 <code>go test -h</code>。</p><h3 id="二-pprof-数据分析"><a href="#二-pprof-数据分析" class="headerlink" title="二. pprof 数据分析"></a>二. pprof 数据分析</h3><p>虽然 <code>net/http/pprof</code>提供的数据分析可以通过设置参数后直接在浏览器查看，但 pprof 采样数据主要是用于 pprof 工具的，特别针对 cpuprof, memprof, blockprof等来说，我们需要直观地得到整个调用关系链以及每次调用的详细信息，这是需要通过<code>go tool pprof</code>命令来分析:</p><pre><code>go tool pprof [binary] [binary.prof]# 如果使用的 net/http/pprof 可以直接接 URLgo tool pprof http://localhost:6060/debug/pprof/profile</code></pre><p>go pprof 采样数据是非常丰富的，大部分情况下我们只会用到 CPU 和 内存分析，因此这里介绍下 cpu, heap, block 和 mutex 四种 pprof 数据分析。</p><h4 id="2-1-cpuprofile"><a href="#2-1-cpuprofile" class="headerlink" title="2.1 cpuprofile"></a>2.1 cpuprofile</h4><p>以<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">Profiling Go Programs</a>中的<a href="https://github.com/rsc/benchgraffiti" target="_blank" rel="external">示例代码</a>为例:</p><pre><code>▶ go build -o havlak1 havlak1.go ▶ ./havlak1 --cpuprofile=havlak1.prof# of loops: 76000 (including 1 artificial root node)▶ go tool pprof havlak1 havlak1.profFile: havlak1Type: cpuTime: Apr 3, 2018 at 3:50pm (CST)Duration: 20.40s, Total samples = 23.30s (114.24%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) top5Showing nodes accounting for 9.60s, 41.20% of 23.30s totalDropped 112 nodes (cum &lt;= 0.12s)Showing top 5 nodes out of 90      flat  flat%   sum%        cum   cum%     2.59s 11.12% 11.12%      2.78s 11.93%  runtime.mapaccess1_fast64 /usr/local/Cellar/go/1.9.1/libexec/src/runtime/hashmap_fast.go     2.26s  9.70% 20.82%      4.97s 21.33%  runtime.scanobject /usr/local/Cellar/go/1.9.1/libexec/src/runtime/mgcmark.go     2.06s  8.84% 29.66%     13.79s 59.18%  main.FindLoops /Users/wudaijun/Code/goprof/havlak/havlak1.go     1.39s  5.97% 35.62%      1.39s  5.97%  runtime.heapBitsForObject /usr/local/Cellar/go/1.9.1/libexec/src/runtime/mbitmap.go     1.30s  5.58% 41.20%      4.14s 17.77%  runtime.mapassign_fast64 /usr/local/Cellar/go/1.9.1/libexec/src/runtime/hashmap_fast.go</code></pre><p>top5用于显示消耗 CPU 前五的函数，每一行代表一个函数，每一列为一项指标:</p><ul><li>flat: 采样时，该函数正在运行的次数*采样频率(10ms)，即得到估算的函数运行”采样时间”。这里不包括函数等待子函数返回。</li><li>flat%: flat / 总采样时间值</li><li>sum%: 前面所有行的 flat% 的累加值，如第二行 sum% = 20.82% = 11.12% + 9.70%</li><li>cum: 采样时，该函数出现在调用堆栈的采样时间，包括函数等待子函数返回。因此 flat &lt;= cum</li><li>cum%: cum / 总采样时间值</li></ul><p>PS: 老的pprof版本貌似显示的是采样次数，比如 flat 为采样时该函数正在运行的次数，这个次数*采样频率即得到采样时间。</p><p><code>go tool pprof</code> 常用命令:</p><ul><li>topN: 输入 top 命令，默认显示 flat 前10的函数调用，可使用 -cum 以 cum 排序</li><li>list Func: 显示函数名以及每行代码的采样分析</li><li>web: 生成 svg 热点图片，可在浏览器中打开，可使用 web Func 来过滤指定函数相关调用树</li></ul><p>通过<code>top5</code>命令可以看到，<code>mapaccess1_fast64</code>函数占用的CPU 采样时间最多，通过 <code>web mapaccess1_fast64</code> 命令打开调用图谱，查看该函数调用关系，可以看到主要在DFS 和 FindLoops 中调用的，然后再通过 <code>list DFS</code>查看函数代码和关键调用，得到 map 结构是瓶颈点，尝试转换为 slice 优化，整个过程参考<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">Profiling Go Programs</a>。总的思路就是通过<code>top</code> 和<code>web</code> 找出关键函数，再通过<code>list Func</code> 查看函数代码，找到关键代码行并确认优化方案(辅以 go test Benchmark)。</p><h4 id="2-2-memprofile"><a href="#2-2-memprofile" class="headerlink" title="2.2 memprofile"></a>2.2 memprofile</h4><pre><code>▶ go build -o havlak3 havlak3.go ▶ ./havlak3 --memprofile=havlak3.mprof▶ go tool pprof havlak3 havlak3.mprofFile: havlak3Type: inuse_spaceTime: Apr 3, 2018 at 3:44pm (CST)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) topShowing nodes accounting for 57.39MB, 100% of 57.39MB total      flat  flat%   sum%        cum   cum%   39.60MB 69.00% 69.00%    39.60MB 69.00%  main.FindLoops /Users/wudaijun/Code/goprof/havlak/havlak3.go   11.29MB 19.67% 88.67%    11.29MB 19.67%  main.(*CFG).CreateNode /Users/wudaijun/Code/goprof/havlak/havlak3.go    6.50MB 11.33%   100%    17.79MB 31.00%  main.NewBasicBlockEdge /Users/wudaijun/Code/goprof/havlak/havlak3.go         0     0%   100%    39.60MB 69.00%  main.FindHavlakLoops /Users/wudaijun/Code/goprof/havlak/havlak3.go         0     0%   100%    17.79MB 31.00%  main.buildBaseLoop /Users/wudaijun/Code/goprof/havlak/havlak3.go</code></pre><p>memprofile 也就是 heap 采样数据，go tool pprof 默认显示的是使用的内存的大小，如果想要显示使用的堆对象的个数，则通过<code>go tool pprof --inuse_objects havlak3 havlak3.mprof</code>，其它参数还有<code>--alloc_objects</code>和<code>--alloc_space</code>，分别是分配的堆内存大小和对象个数。在本例中，FindLoops 函数分配了39.60M 堆内存，占到69%，同样，接下来是通过<code>list FindLoops</code>对函数代码进行 review，找出关键数据结构，进行优化。</p><h4 id="2-3-blockprofile"><a href="#2-3-blockprofile" class="headerlink" title="2.3 blockprofile"></a>2.3 blockprofile</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mutex sync.Mutex</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// rate = 1 时, 统计所有的 block event, </span></div><div class="line">    <span class="comment">// rate &lt;=0 时，则关闭block profiling</span></div><div class="line">    <span class="comment">// rate &gt; 1 时，为 ns 数，阻塞时间t&gt;rate的event 一定会被统计，小于rate则有t/rate 的几率被统计</span></div><div class="line">    <span class="comment">// 参考 https://github.com/golang/go/blob/release-branch.go1.9/src/runtime/mprof.go#L397</span></div><div class="line">runtime.SetBlockProfileRate(<span class="number">1</span> * <span class="number">1000</span> * <span class="number">1000</span>)</div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">wg.Add(<span class="number">1</span>)</div><div class="line">mutex.Lock()</div><div class="line"><span class="keyword">go</span> worker(&amp;wg)</div><div class="line">time.Sleep(<span class="number">2</span>*time.Millisecond)</div><div class="line">mutex.Unlock()</div><div class="line">wg.Wait()</div><div class="line"></div><div class="line">writeProfTo(<span class="string">"block"</span>, <span class="string">"block.bprof"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</div><div class="line"><span class="keyword">defer</span> wg.Done()</div><div class="line">mutex.Lock()</div><div class="line">time.Sleep(<span class="number">1</span>*time.Millisecond)</div><div class="line">mutex.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeProfTo</span><span class="params">(name, fn <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">p := pprof.Lookup(name)</div><div class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</div><div class="line">fmt.Errorf(<span class="string">"%s prof not found"</span>, name)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">f, err := os.Create(fn)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Errorf(<span class="string">"%v"</span>, err.Error())</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">defer</span> f.Close()</div><div class="line">err = p.WriteTo(f, <span class="number">0</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Errorf(<span class="string">"%v"</span>, err.Error())</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行程序并 pprof:</p><pre><code>▶ go build -o Temp tmp.go▶ go tool pprof Temp block.bprof(pprof) topShowing nodes accounting for 3.37ms, 100% of 3.37ms total      flat  flat%   sum%        cum   cum%    2.04ms 60.52% 60.52%     2.04ms 60.52%  sync.(*Mutex).Lock /usr/local/Cellar/go/1.9.1/libexec/src/sync/mutex.go    1.33ms 39.48%   100%     1.33ms 39.48%  sync.(*WaitGroup).Wait /usr/local/Cellar/go/1.9.1/libexec/src/sync/waitgroup.go         0     0%   100%     1.33ms 39.48%  main.main /Users/wudaijun/go/src/ngs/test/tmp/tmp.go         0     0%   100%     2.04ms 60.52%  main.worker /Users/wudaijun/go/src/ngs/test/tmp/tmp.go         0     0%   100%     3.37ms   100%  runtime.goexit /usr/local/Cellar/go/1.9.1/libexec/src/runtime/asm_amd64.s         0     0%   100%     1.33ms 39.48%  runtime.main /usr/local/Cellar/go/1.9.1/libexec/src/runtime/proc.go</code></pre><p>可以看到程序在 mutex.Lock 上阻塞了2.04ms(worker goroutine)， 在 WaitGroup.Wait 上等待了1.33ms(main goroutine)，从更上层来看，在 main 函数中一共阻塞了2.04ms，worker函数中阻塞了1.33ms(cum 列)，通过 <code>web</code>命令生成 svg 图片在浏览器查看:</p><p><img src="/assets/image/go/go-block-prof.png" alt=""></p><p>可以很直观地看到整个阻塞调用链，对于耗时较多的阻塞调用加以优化。</p><h4 id="2-4-mutexprofile"><a href="#2-4-mutexprofile" class="headerlink" title="2.4 mutexprofile"></a>2.4 mutexprofile</h4><p>仍然用2.3中的代码，只需要改两个地方，将 <code>runtime.SetBlockProfileRate(1 * 1000 * 1000)</code> 改为:</p><pre><code>// 当 rate = 0 时，关闭 mutex prof (默认值)// 当 rate = 1 时，表示记录所有的 mutex event// 当 rate &gt; 1 时，记录 1/rate 的 mutex event(随机)runtime.SetMutexProfileFraction(1)</code></pre><p>再将<code>writeProfTo(&quot;block&quot;, &quot;block.bprof&quot;)</code>改为<code>writeProfTo(&quot;mutex&quot;, &quot;mutex.mprof&quot;)</code>即可，编译运行，并打开 pprof 工具:</p><pre><code>▶ go tool pprof bin/Temp mutex.mprof(pprof) topShowing nodes accounting for 2.55ms, 100% of 2.55ms total      flat  flat%   sum%        cum   cum%    2.55ms   100%   100%     2.55ms   100%  sync.(*Mutex).Unlock /usr/local/Cellar/go/1.9.1/libexec/src/sync/mutex.go         0     0%   100%     2.55ms   100%  main.main /Users/wudaijun/go/src/ngs/test/tmp/tmp.go         0     0%   100%     2.55ms   100%  runtime.goexit /usr/local/Cellar/go/1.9.1/libexec/src/runtime/asm_amd64.s         0     0%   100%     2.55ms   100%  runtime.main /usr/local/Cellar/go/1.9.1/libexec/src/runtime/proc.go</code></pre><p>查看 svg 图:</p><p><img src="/assets/image/go/go-mutex-prof.png" alt=""></p><h3 id="三-实践-Tips"><a href="#三-实践-Tips" class="headerlink" title="三. 实践 Tips"></a>三. 实践 Tips</h3><p>以下是一些从其它项目借鉴或者自己总结的实践经验，它们只是建议，而不是准则，实际项目中应该以性能分析数据来作为优化的参考，避免过早优化。</p><ol><li>对频繁分配的小对象，使用 <a href="https://golang.org/pkg/sync/#Pool" target="_blank" rel="external">sync.Pool</a> 对象池避免分配</li><li>自动化的 DeepCopy 是非常耗时的，其中涉及到反射，内存分配，容器(如 map)扩展等，大概比手动拷贝慢一个数量级</li><li>用 atomic.Load/StoreXXX，atomic.Value, sync.Map 等代替 Mutex。(优先级递减)</li><li>使用高效的第三方库，如用<a href="https://github.com/valyala/fasthttp" target="_blank" rel="external">fasthttp</a>替代 net/http</li><li>在开发环境加上<code>-race</code>编译选项进行竞态检查</li><li>在开发环境开启 net/http/pprof，方便实时 pprof</li><li>将所有外部IO(网络IO，磁盘IO)做成异步</li></ol><p>参考: </p><ol><li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="external">Profiling Go Programs</a></li><li><a href="http://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/" target="_blank" rel="external">profiling-and-optimizing-go-web-applications</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-pprof-数据采样&quot;&gt;&lt;a href=&quot;#一-pprof-数据采样&quot; class=&quot;headerlink&quot; title=&quot;一. pprof 数据采样&quot;&gt;&lt;/a&gt;一. pprof 数据采样&lt;/h3&gt;&lt;p&gt;pprof 采样数据主要有三种获取方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;runtime/pprof&lt;/strong&gt;: 手动调用&lt;code&gt;runtime.StartCPUProfile&lt;/code&gt;或者&lt;code&gt;runtime.StopCPUProfile&lt;/code&gt;等 API来生成和写入采样文件，灵活性高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;net/http/pprof&lt;/strong&gt;: 通过 http 服务获取Profile采样文件，简单易用，适用于对应用程序的整体监控。通过 runtime/pprof 实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;go test&lt;/strong&gt;: 通过 &lt;code&gt;go test -bench . -cpuprofile prof.cpu&lt;/code&gt;生成采样文件 适用对函数进行针对性测试&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器管理</title>
    <link href="http://wudaijun.com/2018/03/docker-container-ops/"/>
    <id>http://wudaijun.com/2018/03/docker-container-ops/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-03-28T09:36:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-容器资源限制"><a href="#一-容器资源限制" class="headerlink" title="一. 容器资源限制"></a>一. 容器资源限制</h3><p>Docker资源限制主要靠Linux cgroups技术实现，简单说，cgroups是一个个的进程组(实际上是进程树)，这些进程树通过挂接 subsystem(事实上是挂接到 cgroup 上层的hierarchy)来实现对各种资源的限制和追踪，subsystem是内核附加在程序上的一系列钩子（hooks），通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。cgroups 技术的具体介绍和实现参考文末链接。</p><h4 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1. CPU"></a>1. CPU</h4><p>默认情况下，Docker容器对 CPU 资源的访问是无限制的，可使用如下参数控制容器的 CPU 访问:</p><p><code>--cpus</code>: 控制容器能够使用的最大 CPU 核数，参数为一个精度为两位小数的浮点数(默认值为0，即不限制 CPU)，不能超出物理机的 CPU 核数。</p><pre><code># 通过 stress 开启三个 worker 跑满 CPU 的 worker，并设置容器能访问的 cpus 为1.5&gt; docker run --rm -it --cpus 1.5 progrium/stress --cpu 3stress: info: [1] dispatching hogs: 3 cpu, 0 io, 0 vm, 0 hddstress: dbug: [1] using backoff sleep of 9000usstress: dbug: [1] --&gt; hogcpu worker 3 [7] forkedstress: dbug: [1] using backoff sleep of 6000usstress: dbug: [1] --&gt; hogcpu worker 2 [8] forkedstress: dbug: [1] using backoff sleep of 3000usstress: dbug: [1] --&gt; hogcpu worker 1 [9] forked# 开启另一个窗口查看 CPU 占用情况top# ...  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND 4296 root      20   0    7316    100      0 R  51.8  0.0   0:07.04 stress 4294 root      20   0    7316    100      0 R  51.5  0.0   0:07.02 stress 4295 root      20   0    7316    100      0 R  46.5  0.0   0:06.42 stress</code></pre><p>三个 worker 进程各自占用了50%的 CPU，共计150%，符合<code>--cpus</code>指定的1.5核约束。</p><p><code>--cpu-shares</code>: 通过权重来控制同一物理机上的各容器的 CPU 占用，默认值为1024(该值应该是起源于 Linux2.6+中 CFS 调度算法的默认进程优先级)，它是一个软限制，仅在物理机 CPU 不够用时生效，当 CPU 够用时，容器总是尽可能多地占用 CPU。</p><pre><code># 开启8个 cpu worker 跑满所有核 默认 cpu-shares 为1024&gt; docker run --rm -it  progrium/stress --cpu 8# 开新窗口查看 CPU 状态&gt; top# ...  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND 4477 root      20   0    7316     96      0 R 100.0  0.0   0:08.51 stress 4481 root      20   0    7316     96      0 R 100.0  0.0   0:08.52 stress 4474 root      20   0    7316     96      0 R  99.7  0.0   0:08.50 stress 4476 root      20   0    7316     96      0 R  99.7  0.0   0:08.50 stress 4478 root      20   0    7316     96      0 R  99.7  0.0   0:08.50 stress 4479 root      20   0    7316     96      0 R  99.7  0.0   0:08.50 stress 4480 root      20   0    7316     96      0 R  99.7  0.0   0:08.50 stress 4475 root      20   0    7316     96      0 R  99.3  0.0   0:08.48 stress# 再开8个 cpu worker，设置 cpu-shares 为 512docker run --rm -it  --cpu-shares 512 progrium/stress --cpu 8# 再次查看 CPU 占用&gt; top# ...  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND 4815 root      20   0    7316     96      0 R  67.0  0.0   0:28.56 stress 4816 root      20   0    7316     96      0 R  67.0  0.0   0:28.30 stress 4820 root      20   0    7316     96      0 R  67.0  0.0   0:28.13 stress 4821 root      20   0    7316     96      0 R  67.0  0.0   0:28.31 stress 4817 root      20   0    7316     96      0 R  66.7  0.0   0:28.04 stress 4818 root      20   0    7316     96      0 R  66.7  0.0   0:28.42 stress 4819 root      20   0    7316     96      0 R  66.7  0.0   0:28.24 stress 4822 root      20   0    7316     96      0 R  66.7  0.0   0:28.38 stress 4961 root      20   0    7316     96      0 R  33.3  0.0   0:03.93 stress 4962 root      20   0    7316     96      0 R  33.3  0.0   0:03.96 stress 4965 root      20   0    7316     96      0 R  33.3  0.0   0:03.95 stress 4966 root      20   0    7316     96      0 R  33.3  0.0   0:04.02 stress 4968 root      20   0    7316     96      0 R  33.3  0.0   0:03.90 stress 4963 root      20   0    7316     96      0 R  33.0  0.0   0:04.01 stress 4964 root      20   0    7316     96      0 R  33.0  0.0   0:03.97 stress 4967 root      20   0    7316     96      0 R  33.0  0.0   0:03.94 stress</code></pre><p>可以看到最开始的8个 worker CPU 占用由100%降到67%左右，而新启动的 worker CPU 占用为32%左右，大致满足2/3和1/3的权重占比。</p><p>除此之外，Docker还可以通过<code>--cpuset-cpus</code>参数限制容器运行在某些核上，但环境依赖太强(需要知道主机上有几个CPU核)，有违容器初衷，并且通常都不需要这样做。在 Docker1.13之后，还支持容器的实时调度配置(realtime scheduler)，就应用层而言，基本用不到这项配置，参考: <a href="https://docs.docker.com/config/containers/resource_constraints/#configure-the-realtime-scheduler。" target="_blank" rel="external">https://docs.docker.com/config/containers/resource_constraints/#configure-the-realtime-scheduler。</a></p><h4 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h4><p>同 CPU 一样，默认情况下，Docker没有对容器内存进行限制。内存相关的几个概念:</p><p>memory: 即容器可用的物理内存(RES)，包含 kernel-memory 和 user-memory，即内核内存和用户内存。<br>kernel-memory: 内核内存，每个进程都会占用一部分内核内存，和user-memory 的最大区别是不能被换入换出，因此进程的内核内存占用过大可能导致阻塞系统服务。<br>swap: 容器可用的交换区大小，会swap+memory限制着进程最大能够分配的虚拟页，也是进程理论上能够使用的最大”内存”(虚拟内存)。</p><p>以下大部分配置的参数为正数，加上内存单位，如”4m”, “128k”。</p><ul><li><code>-m</code> or <code>--memory</code>: 容器可以使用的最大内存限制，最小为4m</li><li><code>--memory-swap</code>: 容器使用的内存和交换区的总大小</li><li><code>--memory-swappiness</code>: 默认情况下，主机可以把容器使用的匿名页(anonymous page) swap 出来，这个参数可以配置可被swap的比例(0-100)</li><li><code>--memory-reservation</code>: 内存软限制，每次系统内存回收时，都会尝试将进程的内存占用降到该限制以下(尽可能换出)。该参数的主要作用是避免容器长时间占用大量内存。</li><li><code>--kernel-memory</code>: 内核内存的大小</li><li><code>--memory-swappiness</code>: 设置容器可被置换的匿名页的百分比，值为[0,100]，为0则关闭匿名页交换，容器的工作集都在内存中活跃，默认值从父进程继承</li><li><code>--oom-kill-disable</code>: 当发生内存不够用(OOM) 时，内核默认会向容器中的进程发送 kill 信号，添加该参数将避免发送 kill 信号。该参数一般与<code>-m</code> 一起使用，因为如果没有限制内存，而又启用了 oom-kill-disable，OS 将尝试 kill 其它系统进程。(PS: 该参数我在 Ubuntu 16.04 LTS/Docker17.09.0-ce环境下，没有测试成功，仍然会直接 kill)</li><li><code>--oom-score-adj</code>: 当发生 OOM 时，进程被 kill 掉的优先级，取值[-1000,1000]，值越大，越可能被 kill 掉</li></ul><p><code>--memory</code>和<code>--memory-swap</code>:</p><pre><code>1. 当 memory-swap &gt; memory &gt; 0: 此时容器可使用的 swap 大小为: swap = memory-swap - memory2. memory-swap == 0 或 &lt; memory: 相当于没有设置(如果&lt; memory, docker 会错误提示)，使用默认值，此时容器可使用的 swap 大小为: swap == memory，即 memory-swap = = 2*memory3. memory-swap == memory &gt; 0: 容器不能使用交换空间: swap = memory-swap - memory = 04. memory-swap == -1: 容器可使用主机上所有可用的 swap 空间，即无限制</code></pre><p>在配置<code>--memory-swap</code> 参数时，可能遇到如下提示:</p><pre><code>WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.</code></pre><p>解决方案为:</p><pre><code>To enable memory and swap on system using GNU GRUB (GNU GRand Unified Bootloader), do the following:1. Log into Ubuntu as a user with sudo privileges.2. Edit the /etc/default/grub file.3. Set the GRUB_CMDLINE_LINUX value as follows:    GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;4. Save and close the file.5. Update GRUB.    $ sudo update-grubReboot your system.</code></pre><p>示例:</p><p>我们通过一个 带有 stress 命令的 ubuntu 镜像来进行测试:</p><pre><code>&gt; cat DockerfileFROM ubuntu:latestRUN apt-get update &amp;&amp; \apt-get install stress&gt; docker build -t ubuntu-stress:latest .# 示例一:# memory 限制为100M，swap 空间无限制，分配1000M 内存&gt; docker run -it --rm -m 100M --memory-swap -1 ubuntu-stress:latest /bin/bashroot@e618f1fc6ff9:/# stress --vm 1 --vm-bytes 1000M# docker stats 查看容器内存占用，此时容器物理内存已经达到100M 限制&gt; docker stats e618f1fc6ff9CONTAINER           CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDSe618f1fc6ff9        15.62%              98.25MiB / 100MiB   98.25%              3.39kB / 0B         22GB / 22.4GB       3&gt; pgrep stress2715827159 # stress worker 子进程 PID# 通过 top 可以看到进程物理内存占用为100M，虚拟内存占用为1000M&gt; top -p 27159top - 19:30:08 up 31 days,  1:55,  3 users,  load average: 1.63, 1.43, 1.03Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie%Cpu(s):  1.8 us,  4.3 sy,  2.1 ni, 81.2 id, 10.3 wa,  0.0 hi,  0.3 si,  0.0 stKiB Mem : 16361616 total,   840852 free,  3206616 used, 12314148 buff/cacheKiB Swap: 16705532 total, 15459856 free,  1245676 used. 12681868 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND27159 root      20   0 1031484  98844    212 D  14.3  0.6   0:53.11 stress# 示例二:# memory 限制为100M，swap 比例为 50%&gt; docker run -it --rm -m 100M --memory-swappiness 50 ubuntu-stress:latest /bin/bashroot@e3fdd8b75f1d:/# stress --vm 1 --vm-bytes 190M # 分配190M 内存# 190M 内存正常分配，因为190M*50%的页面可以被 swap，剩下50%的页面放在内存中&gt; top -p 29655# ...  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND29655 root      20   0  202044  98296    212 D   9.7  0.6   0:17.52 stress# 停止 stress，重新尝试分配210M 内存，210M*50%&gt;100M，内存不够，进程被 kill 掉&gt; root@e3fdd8b75f1d:/# stress --vm 1 --vm-bytes 210Mstress: info: [13] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hddstress: FAIL: [13] (415) &lt;-- worker 14 got signal 9stress: WARN: [13] (417) now reaping child worker processesstress: FAIL: [13] (451) failed run completed in 4s# 示例三:# memory 限制为100M, swap 比例为60%, memory-swap 为130M# 可以得到，容器能使用的最大虚拟内存为 min(100/(1-60%), 130) = 130M，现在来简单验证docker run -it --rm -m 100M --memory-swappiness 50 --memory-swap 30M ubuntu-stress:latest /bin/bash# 分配120M 内存, OKroot@b54444b40706:/# stress --vm 1 --vm-bytes 120Mstress: info: [11] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd^C# 分配140M 内存，Errorroot@b54444b40706:/# stress --vm 1 --vm-bytes 140Mstress: info: [13] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hddstress: FAIL: [13] (415) &lt;-- worker 14 got signal 9stress: WARN: [13] (417) now reaping child worker processesstress: FAIL: [13] (451) failed run completed in 1s</code></pre><h3 id="二-容器监控"><a href="#二-容器监控" class="headerlink" title="二. 容器监控"></a>二. 容器监控</h3><h4 id="1-docker-inspect"><a href="#1-docker-inspect" class="headerlink" title="1. docker inspect"></a>1. docker inspect</h4><p><code>docker inspect</code>用于查看容器的静态配置，容器几乎所有的配置信息都在里面:</p><pre><code>&gt; docker inspect 5c004516ee59 0e9300806926[    {        &quot;Id&quot;: &quot;5c004516ee592b53e3e83cdee69fc93713471d4ce06778e1c6a9f783a576531b&quot;,        &quot;Created&quot;: &quot;2018-03-27T16:44:27.521434182Z&quot;,        &quot;Path&quot;: &quot;game&quot;,        &quot;Args&quot;: [],        &quot;State&quot;: {            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,        ...</code></pre><p><code>docker inspect</code>接收一个容器 ID 列表，返回一个 json 数组，包含容器的各项参数，可以通过 docker format 过滤输出:</p><pre><code># 显示容器 IP&gt; docker inspect --format &#39;{{ .NetworkSettings.IPAddress }}&#39; 5c004516ee59172.17.0.2</code></pre><h4 id="2-docker-stats"><a href="#2-docker-stats" class="headerlink" title="2. docker stats"></a>2. docker stats</h4><p><code>docker stats</code>可实时地显示容器的资源使用(内存, CPU, 网络等):</p><pre><code># 查看指定容器&gt; docker stats ngs-game-1CONTAINER           CPU %               MEM USAGE / LIMIT    MEM %               NET I/O             BLOCK I/O           PIDSngs-game-1          0.55%               127.4MiB / 15.6GiB   0.80%               0B / 0B             0B / 0B             18# 以容器名代替容器ID查看所有运行中的容器状态&gt; docker stats $(docker ps --format={{.Names}})CONTAINER           CPU %               MEM USAGE / LIMIT    MEM %               NET I/O             BLOCK I/O           PIDSngs-game-1          0.74%               127.4MiB / 15.6GiB   0.80%               0B / 0B             0B / 0B             18ngs-game-4          0.54%               21.99MiB / 15.6GiB   0.14%               0B / 0B             0B / 0B             20ngs-auth-1          0.01%               11.11MiB / 15.6GiB   0.07%               0B / 0B             0B / 0B             20</code></pre><h4 id="3-docker-attach"><a href="#3-docker-attach" class="headerlink" title="3. docker attach"></a>3. docker attach</h4><p>将本地的标准输入/输出以及错误输出 attach 到运行中的container 上。</p><pre><code>&gt; docker run -d -it --name ubuntu1 ubuntu-stress /bin/bashda01f119000f7370780eea0220a0fbf6e7b6d8d0dac1d635fc5dd480a64e4f68&gt; docker attach ubuntu1root@da01f119000f:/## 开启另一个 terminal，再次 attach，此时两个 terminal 的输入输出会自动同步&gt; docker attach ubuntu1</code></pre><p>由于本地输入完全重定向到容器，因此输入 exit 或<code>CTRL-d</code>会退出容器，要 dettach 会话，输入<code>CTRL-p</code> <code>CTRL-q</code>。</p><h3 id="三-容器停止"><a href="#三-容器停止" class="headerlink" title="三. 容器停止"></a>三. 容器停止</h3><ul><li>docker stop: 分为两个阶段，第一个阶段向容器主进程(Pid==1)发送SIGTERM信号，容器主进程可以捕获这个信号并进入退出处理流程，以便优雅地停止容器。第一阶段是有时间限制的(通过<code>-t</code>参数指明，默认为10s)，如果超过这个时间容器仍然没有停止，则进入第二阶段: 向容器主进程发送SIGKILL信号强行终止容器(SIGKILL无法被忽略或捕获)。</li><li>docker kill: 不带参数则相当于直接进入docker stop的第二阶段，可通过<code>-s</code>参数指定要发送的信号(默认是SIGKILL)。</li></ul><p>docker stop/kill仅向容器主进程(Pid==1)发送信号，因此对于ENTRYPOINT/CMD的Shell格式来说，可能导致应用无法接收的信号，Docker命令文档也提到了这一点:</p><blockquote><blockquote><p>Note: ENTRYPOINT and CMD in the shell form run as a subcommand of /bin/sh -c, which does not pass signals. This means that the executable is not the container’s PID 1 and does not receive Unix signals.</p></blockquote></blockquote><p>参考:</p><ol><li><a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="external">https://docs.docker.com/config/containers/resource_constraints/</a></li><li><a href="https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources" target="_blank" rel="external">https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources</a></li><li><a href="https://coolshell.cn/articles/17049.html" target="_blank" rel="external">DOCKER基础技术：LINUX CGROUP</a></li><li><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="external">Docker背后的内核知识——cgroups资源限制</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-容器资源限制&quot;&gt;&lt;a href=&quot;#一-容器资源限制&quot; class=&quot;headerlink&quot; title=&quot;一. 容器资源限制&quot;&gt;&lt;/a&gt;一. 容器资源限制&lt;/h3&gt;&lt;p&gt;Docker资源限制主要靠Linux cgroups技术实现，简单说，cgroups是一
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器编排工具</title>
    <link href="http://wudaijun.com/2018/03/docker-management/"/>
    <id>http://wudaijun.com/2018/03/docker-management/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-03-14T02:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-Docker-Machine"><a href="#一-Docker-Machine" class="headerlink" title="一. Docker Machine"></a>一. Docker Machine</h3><p>通常我们使用的Docker都是直接在物理机上安装Docker Engine，docker-machine是一个在虚拟机上安装Docker Engine的工具，使用起来很方便:</p><pre><code># 创建一个docker machine，命名为abc&gt; docker-machine create abc# 列出当前主机上所有的docker machine&gt; docker-machine ls# 通过ssh连接到abc&gt; docker-machine ssh abc# 现在就已经在abc machine上，可以像使用Docker Engine一样正常使用docker@abc:~$ docker ps# 退出machinedocker@abc:~$ exit</code></pre><p>docker-machine可以用来在本机部署Docker集群，或者在云上部署Docker。docker-machine支持多种虚拟方案，virtualbox，xhyve，hyperv等等。具体使用比较简单，命令参考附录文档。</p><h3 id="二-Docker-Swarm"><a href="#二-Docker-Swarm" class="headerlink" title="二. Docker Swarm"></a>二. Docker Swarm</h3><p>Docker Swarm是docker原生的集群管理工具，之前是个独立的项目，于 Docker 1.12 被整合到 Docker Engine 中,作为swarm model存在，因此Docker Swarm实际上有两种：独立的swarm和整合后swarm model。官方显然推荐后者，本文也使用swarm model。相较于kubernetes，Mesos等工具，swarm最大的优势是轻量，原生和易于配置。它使得原本单主机的应用可以方便地部署到集群中。</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul><li>task: 任务，集群的最小单位，对应单容器实例</li><li>service: 服务，由一个或多个task构成，可以统一配置，部署，收缩</li><li>node: 机器节点，代表一台物理机    </li></ul><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li>docker service: 提供了service创建，更新，回滚，task扩展收缩等功能</li><li>docker node: 提供对机器节点的管理</li><li>docker swarm: 用于配置机器集群，包括管理manager和worker两类机器节点的增删</li></ul><h4 id="1-初始化-swarm"><a href="#1-初始化-swarm" class="headerlink" title="1. 初始化 swarm"></a>1. 初始化 swarm</h4><pre><code>[n1-common]&gt; docker swarm initSwarm initialized: current node (b3a3avned864im04d7veyw06t) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join --token SWMTKN-1-4mptgs751hcyh3ddlqwvv2aumo5j5mu1qllva52ciim6bun51d-eausald3qqtae604doj639mck 192.168.65.2:2377To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</code></pre><p>执行该条命令的node将会成为manager node，该命令会生成两个token: manager token和worker token，通过<code>docker swarm join --token TOKEN MANAGER_NODE_IP</code>提供不同的token来将当前node以不同身份加入到集群。</p><p>现在我们尝试加入一个worker node，在另一台机器上执行:</p><pre><code>[moby]&gt; docker swarm join --token SWMTKN-1-2w53lkm9h1l5u6yb4hh0k2t8yayub2zx0sidpvcr9nicqwafzx-9jm5zix2041rhfrf7e07oh4l2 172.20.140.39:2377This node joined a swarm as a worker.</code></pre><h4 id="2-配置节点"><a href="#2-配置节点" class="headerlink" title="2. 配置节点"></a>2. 配置节点</h4><p>通过 <code>docker node ls</code> 可以查看当前swarm集群中的所有节点(只能在manager节点上运行):</p><pre><code>[n1-common]&gt; sudo docker node lsID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUSyozazaogirhpj8skccfwqtl8f     moby                Ready               Activerx03hnmwx6z9jc9x9velz46if *   n1-common           Ready               Active              Leader</code></pre><p>PS: swarm的service和node管理命令的规范和container管理类似:</p><pre><code>docker node|service ls: 查看集群中所有的节点(服务)docker node|service ps: 查看指定节点(服务)的容器信息docker node|service inspect: 查看指定节点(服务)的内部配置和状态信息docker node|service update: 更新节点(服务)配置信息docker node|service rm: 从集群中移除节点(服务)</code></pre><p>以上命令都只能在manager节点上运行。</p><p>在这里，我们通过docker node update为节点设置标签:</p><pre><code>n1-common:~$ docker node update --label-add type=db mobymoby</code></pre><h4 id="3-创建服务"><a href="#3-创建服务" class="headerlink" title="3. 创建服务"></a>3. 创建服务</h4><p>服务有两种模式(mode): </p><ul><li>复制集模式(—mode replicas): 默认模式，该方式会将指定的(通过—replicas) M个task按照指定方式部署在N个机器节点上(N &lt;= 集群机器节点数)。</li><li>全局模式(—mode global): 将服务在每个机器节点上部署一份，因此无需指定任务数量，也不能进行任务扩展和收缩。</li></ul><p>我们尝试创建一个名为redis的服务，该服务包含5个任务的复制集:</p><pre><code>[n1-common]&gt; docker service create \--replicas 5 \--name redis \--constraint &#39;node.labels.type=db&#39; \--update-delay 10s \--update-parallelism 2 \--env MYVAR=foo \-p 6379:6379 \redis</code></pre><p><code>--update-xxx</code>指定了服务更新策略，这里为redis服务指定最多同时更新2个task，并且每批次更新之间间隔10s，在更新失败时，执行回滚操作，回滚到更新前的配置。更新操作通过<code>docker service update</code>命令完成，可以更新<code>docker service create</code>中指定的几乎所有配置，如task数量。<code>docker service create</code>除了更新策略外，还可以为service指定回滚策略(<code>--rollback-xxx</code>)，重启策略(<code>--restart-xxx</code>)等。</p><p><code>--constraint</code>指定服务约束，限制服务的任务能够部署的节点，在这里，redis服务的5个任务只能部署在集群中labels.type==db的节点上。除了constraint参数外，还可以通过<code>--placement-pref</code>更进一步地配置部署优先级，如<code>--placement-pref &#39;spread=node.labels.type&#39;</code>将task平均分配到不同的type上，哪怕各个type的node数量不一致。</p><p><code>--env MYVAR=foo</code>指定服务环境变量，当然，这里并没有实际意义。</p><p>关于服务创建的更多选项参考官方文档。运行以上命令后，服务默认将在后台创建(—detach=false)，通过<code>docker service ps redis</code>可查看服务状态，确保服务的任务都以正常启动:</p><pre><code>[n1-common]&gt; docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTSfegu7p341u58        redis.1             redis:latest        moby                Running             Running 9 seconds agohoghsnnamv56        redis.2             redis:latest        moby                Running             Running 9 seconds ago0klozd8zkz0d        redis.3             redis:latest        moby                Running             Running 10 seconds agojpcik7w3hpjx        redis.4             redis:latest        moby                Running             Running 10 seconds ago29jrofbwfi13        redis.5             redis:latest        moby                Running             Running 8 seconds ago</code></pre><p>可以看到，由于只有moby节点的labels.type==db，因此所有的task都被部署在moby节点上。现在整个服务已经部署完成，那么如何访问这个服务呢？事实上，我们通过moby或者n1-common两台主机IP:6379均可访问Redis服务，<strong>Swarm向用户屏蔽了服务的具体部署位置，让用户使用集群就像使用单主机一样</strong>，这也为部署策略，负载均衡以及故障转移提供基础。</p><h4 id="4-平滑更新"><a href="#4-平滑更新" class="headerlink" title="4. 平滑更新"></a>4. 平滑更新</h4><p>通过<code>docker service update</code>可以完成对服务的更新，可更新的配置很多，包括<code>docker service create</code>中指定的参数，自定义标签等，服务的更新策略由<code>--update-xxx</code>选项配置，只有部分更新需要重启任务，可通过<code>--force</code>参数强制更新。</p><p>现在我们尝试限制redis服务能够使用的cpu个数:</p><pre><code>[n1-common]&gt; docker service update --limit-cpu 2 redisredisSince --detach=false was not specified, tasks will be updated in the background.In a future release, --detach=false will become the default.[n1-common]&gt; docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTSfegu7p341u58        redis.1             redis:latest        moby                Running             Running 13 minutes agohoghsnnamv56        redis.2             redis:latest        moby                Running             Running 13 minutes agomgblj8v97al1        redis.3             redis:latest        moby                Running             Running 9 seconds ago0klozd8zkz0d         \_ redis.3         redis:latest        moby                Shutdown            Shutdown 11 seconds agojpcik7w3hpjx        redis.4             redis:latest        moby                Running             Running 13 minutes ago49mvisd0zbtj        redis.5             redis:latest        moby                Running             Running 8 seconds ago29jrofbwfi13         \_ redis.5         redis:latest        moby                Shutdown            Shutdown 11 seconds ago[n1-common]&gt; docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS9396e3x8gp5m        redis.1             redis:latest        moby                Ready               Ready 2 seconds agofegu7p341u58         \_ redis.1         redis:latest        moby                Shutdown            Running 2 seconds agomsugiubez60a        redis.2             redis:latest        moby                Ready               Ready 2 seconds agohoghsnnamv56         \_ redis.2         redis:latest        moby                Shutdown            Running 2 seconds agomgblj8v97al1        redis.3             redis:latest        moby                Running             Running 13 seconds ago0klozd8zkz0d         \_ redis.3         redis:latest        moby                Shutdown            Shutdown 15 seconds agojpcik7w3hpjx        redis.4             redis:latest        moby                Running             Running 13 minutes ago49mvisd0zbtj        redis.5             redis:latest        moby                Running             Running 12 seconds ago29jrofbwfi13         \_ redis.5         redis:latest        moby                Shutdown            Shutdown 15 seconds ago</code></pre><p>由于限制服务所使用的CPU数量需要重启任务，通过前后两次的<code>docker service ps</code>可以看到，docker service的更新策略与我们在<code>docker service create</code>中指定的一致: 每两个一组，每组间隔10s，直至更新完成，通过指定<code>--detach=false</code>能同步地看到这个平滑更新过程。这种平滑更新重启使得服务在升级过程中，仍然能够正常对外提供服务。docker swarm会保存每个任务的升级历史及对应的容器ID和容器状态，以便在更新失败时正确回滚(如果指定了更新失败的行为为回滚)，<code>docker service rollback</code>命令可强制将任务回滚到上一个版本。</p><p>现在我们通过<code>docker service scale</code>来伸缩服务任务数量，在这里我们使用<code>--detach=false</code>选项:</p><pre><code>[n1-common]&gt; docker service scale redis=3redis scaled to 3overall progress: 3 out of 3 tasks1/3: running   [==================================================&gt;]2/3: running   [==================================================&gt;]3/3: running   [==================================================&gt;]verify: Service converged[n1-common]&gt; docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS9396e3x8gp5m         redis.1            redis:latest        moby                Running             Running 10 minutes agofegu7p341u58         \_ redis.1         redis:latest        moby                Shutdown            Shutdown 10 minutes ago8urov9089x6c         redis.4            redis:latest        moby                Running             Running 9 minutes agojpcik7w3hpjx         \_ redis.4         redis:latest        moby                Shutdown            Shutdown 9 minutes ago49mvisd0zbtj         redis.5            redis:latest        moby                Running             Running 10 minutes ago29jrofbwfi13         \_ redis.5         redis:latest        moby                Shutdown            Shutdown 10 minutes ago</code></pre><p>服务的任务规模被收缩，现在只剩下redis.1,redis.4,redis.5三个任务。</p><h4 id="5-故障转移"><a href="#5-故障转移" class="headerlink" title="5. 故障转移"></a>5. 故障转移</h4><p>现在我们将redis服务停掉，重新创建一个redis服务:</p><pre><code>[n1-common]&gt; docker service rm redisredis[n1-common]&gt; docker service create --replicas 5 --name redis  -p 6379:6379 redisfvcwpsmbscxhsmg04vf5zhmbfSince --detach=false was not specified, tasks will be created in the background.In a future release, --detach=false will become the default.[n1-common]&gt; docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTSn1dd790efq36        redis.1             redis:latest        moby                Running             Running 2 minutes ago5fvqbozb7bpr        redis.2             redis:latest        n1-common           Running             Running 2 minutes agoma533n5ce09c        redis.3             redis:latest        moby                Running             Running 2 minutes agoj1f18j2yaqhc        redis.4             redis:latest        n1-common           Running             Running 2 minutes agop2kf7ftrexam        redis.5             redis:latest        moby                Running             Running 2 minutes ago</code></pre><p>由于我们没有指定部署约束，因此redis服务的5个任务将被自动负载到集群节点中，在这里，redis.2,redis.4部署在n1-common上，其余三个部署在moby，现在我们将moby节点退出集群，观察服务任务状态变化:</p><pre><code>[moby]&gt;  docker swarm leaveNode left the swarm.[n1-common]&gt; service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                     ERROR               PORTS8c5py5p9pcgz        redis.1             redis:latest        n1-common           Ready               Accepted less than a second agon1dd790efq36         \_ redis.1         redis:latest        moby                Shutdown            Running 12 seconds ago5fvqbozb7bpr        redis.2             redis:latest        n1-common           Running             Running 8 minutes agoml546ziyey4r        redis.3             redis:latest        n1-common           Ready               Accepted less than a second agoma533n5ce09c         \_ redis.3         redis:latest        moby                Shutdown            Running 8 minutes agoj1f18j2yaqhc        redis.4             redis:latest        n1-common           Running             Running 8 minutes agokfu6jeddkvwu        redis.5             redis:latest        n1-common           Ready               Accepted less than a second agop2kf7ftrexam         \_ redis.5         redis:latest        moby                Shutdown            Running 12 seconds ago[n1-common]&gt; docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS8c5py5p9pcgz        redis.1             redis:latest        n1-common           Running             Running 3 seconds agon1dd790efq36         \_ redis.1         redis:latest        moby                Shutdown            Running 23 seconds ago5fvqbozb7bpr        redis.2             redis:latest        n1-common           Running             Running 8 minutes agoml546ziyey4r        redis.3             redis:latest        n1-common           Running             Running 3 seconds agoma533n5ce09c         \_ redis.3         redis:latest        moby                Shutdown            Running 8 minutes agoj1f18j2yaqhc        redis.4             redis:latest        n1-common           Running             Running 8 minutes agokfu6jeddkvwu        redis.5             redis:latest        n1-common           Running             Running 3 seconds agop2kf7ftrexam         \_ redis.5         redis:latest        moby                Shutdown            Running 23 seconds ago</code></pre><p>故障节点moby上面的1,3,5任务已经被自动重新部署在其它可用节点(当前只有n1-common)上，并记录了每个任务的版本和迁移历史。现在如果尝试再将moby节点加入集群，会发现5个task仍然都在n1-common上，没有立即进行任务转移，而是等下一步重启升级或者扩展服务任务时再进行动态负载均衡。</p><h4 id="6-再看Swarm集群"><a href="#6-再看Swarm集群" class="headerlink" title="6. 再看Swarm集群"></a>6. 再看Swarm集群</h4><p>再来回顾一下Docker Swarm，在我们初始化或加入Swarm集群时，通过<code>docker network ls</code>可以看到，Docker做了如下事情:</p><ol><li>创建了一个叫ingress的overlay网络，用于Swarm集群容器跨主机通信，在创建服务时，如果没有为其指定网络，将默认接入到ingress网络中</li><li>创建一个docker_gwbridge虚拟网桥，用于连接集群各节点(Docker Deamon)的物理网络到到ingress网络</li></ol><p>网络细节暂时不谈(也没怎么搞清楚)，总之，Swarm集群构建了一个跨主机的网络，可以允许集群中多个容器自由访问。Swarm集群有如下几个比较重要的特性:</p><ol><li>服务的多个任务可以监听同一端口(通过iptables透明转发)。</li><li>屏蔽掉服务的具体物理位置，通过任意集群节点IP:Port均能访问服务(无论这个服务是否跑在这个节点上)，Docker会将请求正确路由到运行服务的节点(称为routing mesh)。在routine mesh下，服务运行在虚拟IP环境(virtual IP mode, vip)，即使服务运行在global模式(每个节点都运行有任务)，用户仍然不能假设指定IP:Port节点上的服务会处理请求。</li><li>如果不想用Docker Swarm自带的routing mesh负载均衡器，可以在服务创建或更新时使用<code>--endpoint-mode = dnsrr</code>，dnsrr为dns round robin简写，另一种模式即为vip，dnsrr允许应用向Docker通过服务名得到服务IP:Port列表，然后应用负责从其中选择一个地址进行服务访问。</li></ol><p>综上，Swarm通过虚拟网桥和NATP等技术，搭建了一个跨主机的虚拟网络，通过Swarm Manager让这个跨主机网络用起来像单主机一样方便，并且集成了服务发现(服务名-&gt;服务地址)，负载均衡(routing mesh)，这些都是Swarm能够透明协调转移任务的根本保障，应用不再关心服务有几个任务，部署在何处，只需要知道服务在这个集群中，端口是多少，然后这个服务就可以动态的扩展，收缩和容灾。当然，Swarm中的服务是理想状态的微服务，亦即是无状态的。</p><h3 id="三-Docker-Compose-amp-Stack"><a href="#三-Docker-Compose-amp-Stack" class="headerlink" title="三. Docker Compose &amp; Stack"></a>三. Docker Compose &amp; Stack</h3><p>docker-compose 是一个用于定义和运行多容器应用的工具。使用compose，你可以通过一份docker-compose.yml配置文件，然后运行<code>docker-compose up</code>即可启动整个应用所配置的服务。一个docker-compose.yml文件定义如下:</p><pre><code>version: &#39;3&#39;  # docker-compose.yml格式版本号，版本3为官方推荐版本，支持swarm model和deploy选项services:     # 定义引用所需服务  web:        # 服务名字    build: .  # 服务基于当前目录的Dockerfile构建    ports:    # 服务导出端口配置    - &quot;5000:5000&quot;    volumes:  # 服务目录挂载配置    - .:/code    - logvolume01:/var/log    links:    # 网络链接    - redis    deploy:   # 部署配置 和 docker service create中的参数对应 只有版本&gt;3支持      replicas: 5      resources:        limits:          cpus: &quot;0.1&quot;          memory: 50M      restart_policy:        condition: on-failure  redis:      # redis 服务    image: redis # 服务基于镜像构建</code></pre><p>docker-compose设计之初是单机的，docker-compose中也有服务的概念，但只是相当于一个或多个容器(version&gt;2.2 scale参数)，并且只能部署在单台主机上。版本3的docker-compose.yml开始支持swarm model，可以进行集群部署配置，这里的服务才是swarm model中的服务。但version 3的docker-compose.yml本身已经不能算是docker-compose的配置文件了，因为docker-compose不支持swarm model，用以上配置文件执行<code>docker-compose up</code>将得到警告:</p><pre><code>WARNING: Some services (web) use the &#39;deploy&#39; key, which will be ignored. Compose does not support &#39;deploy&#39; configuration - use `docker stack deploy` to deploy to a swarm.WARNING: The Docker Engine you&#39;re using is running in swarm mode.Compose does not use swarm mode to deploy services to multiple nodes in a swarm. All containers will be scheduled on the current node.</code></pre><p>那么<code>docker stack</code>又是什么？<code>docker stack</code>是基于<code>docker swarm</code>之上的应用构建工具，前面介绍的<code>docker swarm</code>只能以服务为方式构建，而docker-compose虽然能以应用为单位构建，但本身是单机版的，Docker本身并没有基于docker-compose进行改造，而是另起炉灶，创建了<code>docker stack</code>命令，同时又复用了docker-compose.yml配置方案(同时也支持另一种bundle file配置方案)，因此就造成了docker-compose能使用compose配置的version 1, version 2,和部分version 3(不支持swarm model和deploy选项)，而<code>docker stack</code>仅支持version 3的compose配置。</p><p>总的来说，如果应用是单机版的，或者说不打算使用docker swarm集群功能，那么就通过docker-compose管理应用构建，否则使用docker stack，毕竟后者才是亲生的。</p><p>参考:</p><ol><li><a href="https://docs.docker.com/machine/reference/" target="_blank" rel="external">Docker Machine</a></li><li><a href="https://docs.docker.com/get-started/part4/" target="_blank" rel="external">Docker Swarm</a></li><li><a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="external">Docker Compose</a></li><li><a href="https://docs.docker.com/get-started/part3/" target="_blank" rel="external">Docker Services</a></li><li><a href="https://docs.docker.com/network/overlay/" target="_blank" rel="external">Docker overlay网络</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-Docker-Machine&quot;&gt;&lt;a href=&quot;#一-Docker-Machine&quot; class=&quot;headerlink&quot; title=&quot;一. Docker Machine&quot;&gt;&lt;/a&gt;一. Docker Machine&lt;/h3&gt;&lt;p&gt;通常我们使用的Docke
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Go sync.Map 实现</title>
    <link href="http://wudaijun.com/2018/02/go-sync-map-implement/"/>
    <id>http://wudaijun.com/2018/02/go-sync-map-implement/</id>
    <published>2018-02-08T16:00:00.000Z</published>
    <updated>2018-02-11T08:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go基于CSP模型，提倡”Share memory by communicating; don’t communicate by sharing memory.”，亦即通过channel来实现goroutine之间的数据共享，但很多时候用锁仍然是不可避免的，它可以让流程更直观明了，并且减少内存占用等。通常我们的实践是用channel传递数据的所有权，分配工作和同步异步结果等，而用锁来共享状态和配置等信息。</p><p>本文从偏实现的角度学习下Go的atomic.Load/Store，atomic.Value，以及sync.Map。</p><a id="more"></a><h3 id="1-atomic-Load-Store"><a href="#1-atomic-Load-Store" class="headerlink" title="1. atomic.Load/Store"></a>1. atomic.Load/Store</h3><p>在Go中，对于一个字以内的简单类型(如整数，指针)，可以直接通过<code>atomic.Load/Store/Add/Swap/CompareAndSwap</code>系列API来进行原子读写，以Int32为例: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="comment">// AddInt32 atomically adds delta to *addr and returns the new value.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span></div><div class="line">// <span class="title">LoadInt32</span> <span class="title">atomically</span> <span class="title">loads</span> *<span class="title">addr</span>.</div><div class="line"><span class="title">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="keyword">int32</span>)</span> <span class="params">(val <span class="keyword">int32</span>)</span></div><div class="line">// <span class="title">StoreInt32</span> <span class="title">atomically</span> <span class="title">stores</span> <span class="title">val</span> <span class="title">into</span> *<span class="title">addr</span>.</div><div class="line"><span class="title">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="keyword">int32</span>, val <span class="keyword">int32</span>)</span></div><div class="line">// <span class="title">SwapInt32</span> <span class="title">atomically</span> <span class="title">stores</span> <span class="title">new</span> <span class="title">into</span> *<span class="title">addr</span> <span class="title">and</span> <span class="title">returns</span> <span class="title">the</span> <span class="title">previous</span> *<span class="title">addr</span> <span class="title">value</span>.</div><div class="line"><span class="title">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(old <span class="keyword">int32</span>)</span></div><div class="line">// <span class="title">CompareAndSwapInt32</span> <span class="title">executes</span> <span class="title">the</span> <span class="title">compare</span>-<span class="title">and</span>-<span class="title">swap</span> <span class="title">operation</span> <span class="title">for</span> <span class="title">an</span> <span class="title">int32</span> <span class="title">value</span>.</div><div class="line"><span class="title">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></div></pre></td></tr></table></figure><p>一个有意思的问题，在64位平台下，对Int32，Int64的直接读写是原子的吗？以下是一些有意思的讨论:</p><ul><li><a href="http://preshing.com/20130618/atomic-vs-non-atomic-operations/" target="_blank" rel="external">http://preshing.com/20130618/atomic-vs-non-atomic-operations/</a></li><li><a href="https://stackoverflow.com/questions/46556857/is-golang-atomic-loaduint32-necessary" target="_blank" rel="external">https://stackoverflow.com/questions/46556857/is-golang-atomic-loaduint32-necessary</a></li><li><a href="https://stackoverflow.com/questions/5258627/atomic-64-bit-writes-with-gcc" target="_blank" rel="external">https://stackoverflow.com/questions/5258627/atomic-64-bit-writes-with-gcc</a></li></ul><p>总结就是，现代硬件架构基本都保证了内存对齐的word-sized load和store是原子的，这隐含两个条件: 单条MOV, MOVQ等指令是原子的，字段内存对齐(CPU对内存的读取是基于word-size的)。但安全起见，最好还是使用atomic提供的接口，具备更好的跨平台性，并且atomic还提供了一些复合操作(Add/Swap/CAS)。golang也在实现上会对具体平台进行优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var i int64</div><div class="line">atomic.StoreInt64(&amp;i, 123)</div><div class="line">x := atomic.LoadInt64(&amp;i)</div><div class="line">y := atomic.AddInt64(&amp;i, 1)</div></pre></td></tr></table></figure><p>在MacOS10.12(X86_64)下，对应汇编代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// var i int64</div><div class="line">tmp.go:9        0x1093bff       488d051af50000                  LEAQ 0xf51a(IP), AX  // 加载int64 type</div><div class="line">tmp.go:9        0x1093c06       48890424                        MOVQ AX, 0(SP)</div><div class="line">tmp.go:9        0x1093c0a       e8c1a1f7ff                      CALL runtime.newobject(SB) // i分配在堆上(逃逸分析,escape analytic))</div><div class="line">tmp.go:9        0x1093c0f       488b442408                      MOVQ 0x8(SP), AX</div><div class="line">tmp.go:9        0x1093c14       4889442450                      MOVQ AX, 0x50(SP) // 0x50(SP) = &amp;i</div><div class="line">tmp.go:9        0x1093c19       48c70000000000                  MOVQ $0x0, 0(AX)  // 初始化 i = 0</div><div class="line">// atomic.StoreInt64(&amp;i, 123)</div><div class="line">tmp.go:10       0x1093c20       488b442450                      MOVQ 0x50(SP), AX  // 加载&amp;i</div><div class="line">tmp.go:10       0x1093c25       48c7c17b000000                  MOVQ $0x7b, CX  // 加载立即数 123</div><div class="line">tmp.go:10       0x1093c2c       488708                          XCHGQ CX, 0(AX)  // *(&amp;i) = 123  Key Step XCHGQ通过LOCK信号锁住内存总线来确保原子性</div><div class="line">// x := atomic.LoadInt64(&amp;i)</div><div class="line">tmp.go:11       0x1093c2f       488b442450                      MOVQ 0x50(SP), AX</div><div class="line">tmp.go:11       0x1093c34       488b00                          MOVQ 0(AX), AX // AX = *(&amp;i)  Key Step 原子操作</div><div class="line">tmp.go:11       0x1093c37       4889442430                      MOVQ AX, 0x30(SP)</div><div class="line">// y := atomic.AddInt64(&amp;i, 1)</div><div class="line">tmp.go:12       0x1093c3c       488b442450                      MOVQ 0x50(SP), AX</div><div class="line">tmp.go:12       0x1093c41       48c7c101000000                  MOVQ $0x1, CX</div><div class="line">tmp.go:12       0x1093c48       f0480fc108                      LOCK XADDQ CX, 0(AX) // LOCK会锁住内存总线，直到XADDQ指令完成，完成后CX为i的旧值 0(AX)=*(&amp;i)=i+1</div><div class="line">tmp.go:12       0x1093c4d       488d4101                        LEAQ 0x1(CX), AX // AX = CX+1 再执行一次加法 用于返回值</div><div class="line">tmp.go:12       0x1093c51       4889442428                      MOVQ AX, 0x28(SP)</div></pre></td></tr></table></figure></p><p>对XCHG和XADD这类X开头的指令，都会通过LOCK信号锁住内存总线，因此加不加LOCK前缀都是一样的。可以看到，由于硬件架构的支持，atomic.Load/Store和普通读写基本没有什么区别，这种CPU指令级别的锁非常快。因此通常我们将这类CPU指令级别的支持的Lock操作称为原子操作或无锁操作。</p><h3 id="2-atomic-Value"><a href="#2-atomic-Value" class="headerlink" title="2. atomic.Value"></a>2. atomic.Value</h3><p>atomic.Value于go1.4引入，用于无锁存取任意值(interface{})，它的数据结构很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sync/atomic/value.go</span></div><div class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</div><div class="line">  <span class="comment">// 没有实际意义 用于保证结构体在第一次被使用之后，不能被拷贝</span></div><div class="line">  <span class="comment">// 参考: https://github.com/golang/go/issues/8005#issuecomment-190753527</span></div><div class="line">   noCopy noCopy</div><div class="line">  <span class="comment">// 实际保存的值</span></div><div class="line">   v <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>atomic负责v的原子存取操作，我们知道interface{}对应的数据结构为eface，有两个字段: type和data，因此它不能直接通过atomic.Load/Store来存取，atomic.Value实现无锁存取的原理很简单: type字段不变，只允许更改data字段，这样就能通过<code>atomic.LoadPointer</code>来实现对data的存取。从实现来讲，atomic.Value要处理好两点:</p><ol><li>atomic.Value的初始化，因为在初始化时，需要同时初始化type和data字段，atomic.Value通过CAS自旋锁来实现初始化的原子性。</li><li>atomic.Value的拷贝，一是拷贝过程的原子性，二是拷贝方式，浅拷贝会带来更多的并发问题，深拷贝得到两个独立的atomic.Value是没有意义的，因此atomic.Value在初始化完成之后是不能拷贝的。</li></ol><p>除此之外，atomic.Value的实现比较简单，结合eface和<code>atomic.LoadPointer()</code>即可理解，不再详述。</p><h3 id="3-sync-Map"><a href="#3-sync-Map" class="headerlink" title="3. sync.Map"></a>3. sync.Map</h3><p>sync.Map于go1.9引入，为并发map提供一个高效的解决方案。在此之前，通常是通过<code>sync.RWMutex</code>来实现线程安全的Map，后面会有mutexMap和sync.Map的性能对比。先来看看sync.Map的特性: </p><ol><li>以空间换效率，通过read和dirty两个map来提高读取效率</li><li>优先从read map中读取(无锁)，否则再从dirty map中读取(加锁)</li><li>动态调整，当misses次数过多时，将dirty map提升为read map</li><li>延迟删除，删除只是为value打一个标记，在dirty map提升时才执行真正的删除</li></ol><p>sync.Map的使用很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m sync.Map</div><div class="line">m.Store(<span class="string">"key"</span>, <span class="number">123</span>)</div><div class="line">v, ok := m.Load(<span class="string">"key"</span>)</div></pre></td></tr></table></figure><p>下面看一下sync.Map的定义以及Load, Store, Delete三个方法的实现。</p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sync/map.go</span></div><div class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</div><div class="line">   <span class="comment">// 当写read map 或读写dirty map时 需要上锁</span></div><div class="line">   mu Mutex</div><div class="line"></div><div class="line">   <span class="comment">// read map的 k v(entry) 是不变的，删除只是打标记，插入新key会加锁写到dirty中</span></div><div class="line">   <span class="comment">// 因此对read map的读取无需加锁</span></div><div class="line">   read atomic.Value <span class="comment">// 保存readOnly结构体</span></div><div class="line"></div><div class="line">   <span class="comment">// dirty map 对dirty map的操作需要持有mu锁</span></div><div class="line">   dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</div><div class="line"></div><div class="line">   <span class="comment">// 当Load操作在read map中未找到，尝试从dirty中进行加载时(不管是否存在)，misses+1</span></div><div class="line">   <span class="comment">// 当misses达到diry map len时，dirty被提升为read 并且重新分配dirty</span></div><div class="line">   misses <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// read map数据结构</span></div><div class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</div><div class="line">   m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</div><div class="line">   <span class="comment">// 为true时代表dirty map中含有m中没有的元素</span></div><div class="line">   amended <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</div><div class="line">   <span class="comment">// 指向实际的interface&#123;&#125;</span></div><div class="line">   <span class="comment">// p有三种状态:</span></div><div class="line">   <span class="comment">// p == nil: 键值已经被删除，此时，m.dirty==nil 或 m.dirty[k]指向该entry</span></div><div class="line">   <span class="comment">// p == expunged: 键值已经被删除， 此时, m.dirty!=nil 且 m.dirty不存在该键值</span></div><div class="line">   <span class="comment">// 其它情况代表实际interface&#123;&#125;地址 如果m.dirty!=nil 则 m.read[key] 和 m.dirty[key] 指向同一个entry</span></div><div class="line">   <span class="comment">// 当删除key时，并不实际删除，先CAS entry.p为nil 等到每次dirty map创建时(dirty提升后的第一次新建Key)，会将entry.p由nil CAS为expunged</span></div><div class="line">   p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>定义很简单，补充以下几点:</p><ol><li>read和dirty通过entry包装value，这样使得value的变化和map的变化隔离，前者可以用atomic无锁完成</li><li>Map的read字段结构体定义为readOnly，这只是针对map[interface{}]*entry而言的，entry内的内容以及amended字段都是可以变的</li><li>大部分情况下，对已有key的删除(entry.p置为nil)和更新可以直接通过修改entry.p来完成</li></ol><h4 id="3-2-Load"><a href="#3-2-Load" class="headerlink" title="3.2 Load"></a>3.2 Load</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查找对应的Key值 如果不存在 返回nil，false</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">  <span class="comment">// 1. 优先从read map中读取(无锁)</span></div><div class="line">  read, _ := m.read.Load().(readOnly)</div><div class="line">  e, ok := read.m[key]</div><div class="line">  <span class="comment">// 2. 如果不存在，并且ammended字段指明dirty map中有read map中不存在的字段，则加锁尝试从dirty map中加载</span></div><div class="line">  <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</div><div class="line">    m.mu.Lock()</div><div class="line">    <span class="comment">// double check，避免在加锁的时候dirty map提升为read map</span></div><div class="line">    read, _ = m.read.Load().(readOnly)</div><div class="line">    e, ok = read.m[key]</div><div class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</div><div class="line">      e, ok = m.dirty[key]</div><div class="line">      <span class="comment">// 3. 不管dirty中有没有找到 都增加misses计数 该函数可能将dirty map提升为readmap</span></div><div class="line">      m.missLocked()</div><div class="line">    &#125;</div><div class="line">    m.mu.Unlock()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> !ok &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> e.load()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从entry中atomic load实际interface&#123;&#125;</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">  p := atomic.LoadPointer(&amp;e.p)</div><div class="line">  <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 增加misses计数，并在必要的时候提升dirty map</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</div><div class="line">  m.misses++</div><div class="line">  <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 提升过程很简单，直接将m.dirty赋给m.read.m</span></div><div class="line">  <span class="comment">// 提升完成之后 amended == false m.dirty == nil</span></div><div class="line">  <span class="comment">// m.dirty并不立即创建被拷贝元素，而是延迟创建</span></div><div class="line">  m.read.Store(readOnly&#123;m: m.dirty&#125;)</div><div class="line">  m.dirty = <span class="literal">nil</span></div><div class="line">  m.misses = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-3-Store"><a href="#3-3-Store" class="headerlink" title="3.3 Store"></a>3.3 Store</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Store sets the value for a key.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">  <span class="comment">// 1. 如果read map中存在该key  则尝试直接更改(由于修改的是entry内部的pointer，因此dirty map也可见)</span></div><div class="line">  read, _ := m.read.Load().(readOnly)</div><div class="line">  <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  m.mu.Lock()</div><div class="line">  read, _ = m.read.Load().(readOnly)</div><div class="line">  <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</div><div class="line">    <span class="keyword">if</span> e.unexpungeLocked() &#123;</div><div class="line">      <span class="comment">// 2. 如果read map中存在该key，但p == expunged，则说明m.dirty!=nil并且m.dirty中不存在该key值 此时:</span></div><div class="line">      <span class="comment">//    a. 将 p的状态由expunged先更改为nil </span></div><div class="line">      <span class="comment">//    b. dirty map新建key</span></div><div class="line">      <span class="comment">//    c. 更新entry.p = value (read map和dirty map指向同一个entry)</span></div><div class="line">      m.dirty[key] = e</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 3. 如果read map中存在该key，且 p != expunged，直接更新该entry (此时m.dirty==nil或m.dirty[key]==e)</span></div><div class="line">    e.storeLocked(&amp;value)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</div><div class="line">    <span class="comment">// 4. 如果read map中不存在该Key，但dirty map中存在该key，直接写入更新entry(read map中仍然没有)</span></div><div class="line">    e.storeLocked(&amp;value)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 5. 如果read map和dirty map中都不存在该key，则:</span></div><div class="line">    <span class="comment">//    a. 如果dirty map为空，则需要创建dirty map，并从read map中拷贝未删除的元素</span></div><div class="line">    <span class="comment">//    b. 更新amended字段，标识dirty map中存在read map中没有的key</span></div><div class="line">    <span class="comment">//    c. 将k v写入dirty map中，read.m不变</span></div><div class="line">    <span class="keyword">if</span> !read.amended &#123;</div><div class="line">      m.dirtyLocked()</div><div class="line">      m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</div><div class="line">    &#125;</div><div class="line">    m.dirty[key] = newEntry(value)</div><div class="line">  &#125;</div><div class="line">  m.mu.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尝试直接更新entry 如果p == expunged 返回false</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">  p := atomic.LoadPointer(&amp;e.p)</div><div class="line">  <span class="keyword">if</span> p == expunged &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    p = atomic.LoadPointer(&amp;e.p)</div><div class="line">    <span class="keyword">if</span> p == expunged &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">unexpungeLocked</span><span class="params">()</span> <span class="params">(wasExpunged <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果 dirty map为nil，则从read map中拷贝元素到dirty map</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  read, _ := m.read.Load().(readOnly)</div><div class="line">  m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</div><div class="line">  <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</div><div class="line">    <span class="comment">// a. 将所有为 nil的 p 置为 expunged</span></div><div class="line">    <span class="comment">// b. 只拷贝不为expunged 的 p</span></div><div class="line">    <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</div><div class="line">      m.dirty[k] = e</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">  p := atomic.LoadPointer(&amp;e.p)</div><div class="line">  <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    p = atomic.LoadPointer(&amp;e.p)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> p == expunged</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-4-Delete"><a href="#3-4-Delete" class="headerlink" title="3.4 Delete"></a>3.4 Delete</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Delete deletes the value for a key.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">  <span class="comment">// 1. 从read map中查找，如果存在，则置为nil</span></div><div class="line">  read, _ := m.read.Load().(readOnly)</div><div class="line">  e, ok := read.m[key]</div><div class="line">  <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</div><div class="line">    <span class="comment">// double check</span></div><div class="line">    m.mu.Lock()</div><div class="line">    read, _ = m.read.Load().(readOnly)</div><div class="line">    e, ok = read.m[key]</div><div class="line">    <span class="comment">// 2. 如果read map中不存在，但dirty map中存在，则直接从dirty map删除</span></div><div class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</div><div class="line">      <span class="built_in">delete</span>(m.dirty, key)</div><div class="line">    &#125;</div><div class="line">    m.mu.Unlock()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> ok &#123;</div><div class="line">    <span class="comment">// 将entry.p 置为 nil</span></div><div class="line">    e.<span class="built_in">delete</span>()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    p := atomic.LoadPointer(&amp;e.p)</div><div class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h4><p>除了Load/Store/Delete之外，sync.Map还提供了LoadOrStore/Range操作，但没有提供Len()方法，这是因为要统计有效的键值对只能先提升dirty map(dirty map中可能有read map中没有的键值对)，再遍历m.read(由于延迟删除，不是所有的键值对都有效)，这其实就是Range做的事情，因此在不添加新数据结构支持的情况下，sync.Map的长度获取和Range操作是同一复杂度的。这部分只能看官方后续支持。</p><p>sync.Map实现上并不是特别复杂，但仍有很多值得借鉴的地方:</p><ol><li>通过entry隔离map变更和value变更，并且read map和dirty map指向同一个entry, 这样更新read map已有值无需加锁</li><li>double checking</li><li>延迟删除key，通过标记避免修改read map，同时极大提升了删除key的效率(删除read map中存在的key是无锁操作)</li><li>延迟创建dirty map，并且通过p的nil和expunged，amended字段来加强对dirty map状态的把控，减少对dirty map不必要的使用</li></ol><p>sync.Map适用于key值相对固定，读多写少(更新m.read已有key仍然是无锁的)的情况，下面是一份使用RWLock的内建map和sync.Map的并发读写性能对比，代码在<a href="https://github.com/wudaijun/Code/tree/master/go/go19_syncmap_test" target="_blank" rel="external">这里</a>，代码对随机生成的整数key/value值进行并发的Load/Store/Delete操作，benchmark结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">go test -bench=.</div><div class="line">goos: darwin</div><div class="line">goarch: amd64</div><div class="line">BenchmarkMutexMapStoreParalell-4         5000000               260 ns/op</div><div class="line">BenchmarkSyncMapStoreParalell-4          3000000               498 ns/op</div><div class="line">BenchmarkMutexMapLoadParalell-4         20000000                78.0 ns/op</div><div class="line">BenchmarkSyncMapLoadParalell-4          30000000                41.1 ns/op</div><div class="line">BenchmarkMutexMapDeleteParalell-4       10000000               235 ns/op</div><div class="line">BenchmarkSyncMapDeleteParalell-4        30000000                49.2 ns/op</div><div class="line">PASS</div></pre></td></tr></table></figure><p>可以看到，除了并发写稍慢之外(并发写随机1亿以内的整数key/value，因此新建key操作远大于更新key，会导致sync.Map频繁的dirty map提升操作)，Load和Delete操作均快于mutexMap，特别是删除，得益于延迟删除，sync.Map的Delete几乎和Load一样快。</p><p>最后附上一份转载的sync.Map操作图解(<a href="http://russellluo.com/2017/06/go-sync-map-diagram.html" target="_blank" rel="external">图片出处</a>):</p><p><img src="/assets/image/go/go-sync-map-diagram.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go基于CSP模型，提倡”Share memory by communicating; don’t communicate by sharing memory.”，亦即通过channel来实现goroutine之间的数据共享，但很多时候用锁仍然是不可避免的，它可以让流程更直观明了，并且减少内存占用等。通常我们的实践是用channel传递数据的所有权，分配工作和同步异步结果等，而用锁来共享状态和配置等信息。&lt;/p&gt;
&lt;p&gt;本文从偏实现的角度学习下Go的atomic.Load/Store，atomic.Value，以及sync.Map。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go Interface 实现</title>
    <link href="http://wudaijun.com/2018/01/go-interface-implement/"/>
    <id>http://wudaijun.com/2018/01/go-interface-implement/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-02-11T07:57:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文从源码的角度学习下Go接口的底层实现，以及接口赋值，反射，断言的实现原理。作为对比，用到了go1.8.6和go1.9.1两个版本。</p><h3 id="1-eface"><a href="#1-eface" class="headerlink" title="1. eface"></a>1. eface</h3><p>空接口通过eface结构体实现，位于runtime/runtime2.go: </p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/runtime/runtime2.go</span></div><div class="line"><span class="comment">// 空接口</span></div><div class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</div><div class="line">    _type *_type</div><div class="line">    data  unsafe.Pointer</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>空接口(eface)有两个域，所指向对象的类型信息(_type)和数据指针(data)。先看看<code>_type</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 所有类型信息结构体的公共部分</div><div class="line">// src/rumtime/runtime2.go</div><div class="line">type _type struct &#123;</div><div class="line">    size       uintptr         // 类型的大小</div><div class="line">    ptrdata    uintptr      // size of memory prefix holding all pointers</div><div class="line">    hash       uint32          // 类型的Hash值</div><div class="line">    tflag      tflag              // 类型的Tags </div><div class="line">    align      uint8       // 结构体内对齐</div><div class="line">    fieldalign uint8       // 结构体作为field时的对齐</div><div class="line">    kind       uint8       // 类型编号 定义于runtime/typekind.go</div><div class="line">    alg        *typeAlg    // 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值</div><div class="line">    gcdata    *byte            // GC相关信息</div><div class="line">    str       nameOff   // 类型名字的偏移    </div><div class="line">    ptrToThis typeOff    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>_type是go所有类型的公共描述，里面包含GC，反射等需要的细节，它决定data应该如何解释和操作，这也是它和C void*不同之处。<br>各个类型所需要的类型描述是不一样的，比如chan，除了chan本身外，还需要描述其元素类型，而map则需要key类型信息和value类型信息等:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/runtime/type.go</span></div><div class="line"><span class="comment">// ptrType represents a pointer type.</span></div><div class="line"><span class="keyword">type</span> ptrType <span class="keyword">struct</span> &#123;</div><div class="line">   typ     _type   <span class="comment">// 指针类型 </span></div><div class="line">   elem  *_type <span class="comment">// 指针所指向的元素类型</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</div><div class="line">    typ  _type        <span class="comment">// channel类型</span></div><div class="line">    elem *_type     <span class="comment">// channel元素类型</span></div><div class="line">    dir  <span class="keyword">uintptr</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</div><div class="line">    typ           _type</div><div class="line">    key           *_type</div><div class="line">    elem          *_type</div><div class="line">    bucket        *_type <span class="comment">// internal type representing a hash bucket</span></div><div class="line">    hmap          *_type <span class="comment">// internal type representing a hmap</span></div><div class="line">    keysize       <span class="keyword">uint8</span>  <span class="comment">// size of key slot</span></div><div class="line">    indirectkey   <span class="keyword">bool</span>   <span class="comment">// store ptr to key instead of key itself</span></div><div class="line">    valuesize     <span class="keyword">uint8</span>  <span class="comment">// size of value slot</span></div><div class="line">    indirectvalue <span class="keyword">bool</span>   <span class="comment">// store ptr to value instead of value itself</span></div><div class="line">    bucketsize    <span class="keyword">uint16</span> <span class="comment">// size of bucket</span></div><div class="line">    reflexivekey  <span class="keyword">bool</span>   <span class="comment">// true if k==k for all keys</span></div><div class="line">    needkeyupdate <span class="keyword">bool</span>   <span class="comment">// true if we need to update key on an overwrite</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些类型信息的第一个字段都是<code>_type</code>(类型本身的信息)，接下来是一堆类型需要的其它详细信息(如子类型信息)，这样在进行类型相关操作时，可通过一个字(<code>typ *_type</code>)即可表述所有类型，然后再通过<code>_type.kind</code>可解析出其具体类型，最后通过地址转换即可得到类型完整的”_type树”，参考<code>reflect.Type.Elem()</code>函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reflect/type.go</span></div><div class="line"><span class="comment">// reflect.rtype结构体定义和runtime._type一致  type.kind定义也一致(为了分包而重复定义)</span></div><div class="line"><span class="comment">// Elem()获取rtype中的元素类型，只针对复合类型(Array, Chan, Map, Ptr, Slice)有效</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Type</span></span> &#123;</div><div class="line">   <span class="keyword">switch</span> t.Kind() &#123;</div><div class="line">   <span class="keyword">case</span> Array:</div><div class="line">      tt := (*arrayType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Chan:</div><div class="line">      tt := (*chanType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Map:</div><div class="line">      <span class="comment">// 对Map来讲，Elem()得到的是其Value类型</span></div><div class="line">      <span class="comment">// 可通过rtype.Key()得到Key类型</span></div><div class="line">      tt := (*mapType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Ptr:</div><div class="line">      tt := (*ptrType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   <span class="keyword">case</span> Slice:</div><div class="line">      tt := (*sliceType)(unsafe.Pointer(t))</div><div class="line">      <span class="keyword">return</span> toType(tt.elem)</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">panic</span>(<span class="string">"reflect: Elem of invalid type"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-iface"><a href="#2-iface" class="headerlink" title="2. iface"></a>2. iface</h3><p>iface结构体表示非空接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// runtime/runtime2.go</span></div><div class="line"><span class="comment">// 非空接口</span></div><div class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</div><div class="line">    tab  *itab</div><div class="line">    data unsafe.Pointer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非空接口的类型信息</span></div><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">    inter  *interfacetype    <span class="comment">// 接口定义的类型信息</span></div><div class="line">    _type  *_type                <span class="comment">// 接口实际指向值的类型信息</span></div><div class="line">    link   *itab  </div><div class="line">    bad    <span class="keyword">int32</span></div><div class="line">    inhash <span class="keyword">int32</span></div><div class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span>             <span class="comment">// 接口方法实现列表，即函数地址列表，按字典序排序</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// runtime/type.go</span></div><div class="line"><span class="comment">// 非空接口类型，接口定义，包路径等。</span></div><div class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</div><div class="line">   typ     _type</div><div class="line">   pkgpath name</div><div class="line">   mhdr    []imethod      <span class="comment">// 接口方法声明列表，按字典序排序</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 接口的方法声明 </span></div><div class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</div><div class="line">   name nameOff          <span class="comment">// 方法名</span></div><div class="line">   ityp typeOff                <span class="comment">// 描述方法参数返回值等细节</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非空接口(iface)本身除了可以容纳满足其接口的对象之外，还需要保存其接口的方法，因此除了data字段，iface通过tab字段描述非空接口的细节，包括接口方法定义，接口方法实现地址，接口所指类型等。iface是非空接口的实现，而不是类型定义，iface的真正类型为interfacetype，其第一个字段仍然为描述其自身类型的_type字段。</p><p>为了提高查找效率，runtime中实现(interface_type, concrete_type) -&gt; itab(包含具体方法实现地址等信息)的hash表:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// runtime/iface.go</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">   hashSize = <span class="number">1009</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">   ifaceLock mutex <span class="comment">// lock for accessing hash</span></div><div class="line">   hash      [hashSize]*itab</div><div class="line">)</div><div class="line"><span class="comment">// 简单的Hash算法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</div><div class="line">   h := inter.typ.hash</div><div class="line">   h += <span class="number">17</span> * typ.hash</div><div class="line">   <span class="keyword">return</span> h % hashSize</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 根据interface_type和concrete_type获取或生成itab信息</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</div><div class="line">   ...</div><div class="line">    <span class="comment">// 算出hash key</span></div><div class="line">   h := itabhash(inter, typ)</div><div class="line"></div><div class="line"></div><div class="line">   <span class="keyword">var</span> m *itab</div><div class="line">   ...</div><div class="line">           <span class="comment">// 遍历hash slot链表</span></div><div class="line">      <span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</div><div class="line">         <span class="comment">// 如果在hash表中找到则返回</span></div><div class="line">         <span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</div><div class="line">            <span class="keyword">if</span> m.bad &#123;</div><div class="line">               <span class="keyword">if</span> !canfail &#123;</div><div class="line">                  additab(m, locked != <span class="number">0</span>, <span class="literal">false</span>)</div><div class="line">               &#125;</div><div class="line">               m = <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">            <span class="keyword">return</span> m</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">    <span class="comment">// 如果没有找到，则尝试生成itab(会检查是否满足接口)</span></div><div class="line">   m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</div><div class="line">   m.inter = inter</div><div class="line">   m._type = typ</div><div class="line">   additab(m, <span class="literal">true</span>, canfail)</div><div class="line">   <span class="keyword">if</span> m.bad &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> m</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 检查concrete_type是否符合interface_type 并且创建对应的itab结构体 将其放到hash表中</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">   inter := m.inter</div><div class="line">   typ := m._type</div><div class="line">   x := typ.uncommon()</div><div class="line"></div><div class="line">   ni := <span class="built_in">len</span>(inter.mhdr)</div><div class="line">   nt := <span class="keyword">int</span>(x.mcount)</div><div class="line">   xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</div><div class="line">   j := <span class="number">0</span></div><div class="line">   <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</div><div class="line">      i := &amp;inter.mhdr[k]</div><div class="line">      itype := inter.typ.typeOff(i.ityp)</div><div class="line">      name := inter.typ.nameOff(i.name)</div><div class="line">      iname := name.name()</div><div class="line">      ipkg := name.pkgPath()</div><div class="line">      <span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</div><div class="line">         ipkg = inter.pkgpath.name()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</div><div class="line">         t := &amp;xmhdr[j]</div><div class="line">         tname := typ.nameOff(t.name)</div><div class="line">         <span class="comment">// 检查方法名字是否一致</span></div><div class="line">         <span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</div><div class="line">            pkgPath := tname.pkgPath()</div><div class="line">            <span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</div><div class="line">               pkgPath = typ.nameOff(x.pkgpath).name()</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 是否导出或在同一个包</span></div><div class="line">            <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</div><div class="line">               <span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</div><div class="line">                    <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></div><div class="line">                  ifn := typ.textOff(t.ifn)</div><div class="line">                  *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">goto</span> nextimethod</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// didn't find method</span></div><div class="line">      <span class="keyword">if</span> !canfail &#123;</div><div class="line">         <span class="keyword">if</span> locked &#123;</div><div class="line">            unlock(&amp;ifaceLock)</div><div class="line">         &#125;</div><div class="line">         <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="string">""</span>, typ.<span class="keyword">string</span>(), inter.typ.<span class="keyword">string</span>(), iname&#125;)</div><div class="line">      &#125;</div><div class="line">      m.bad = <span class="literal">true</span></div><div class="line">      <span class="keyword">break</span></div><div class="line">   nextimethod:</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> !locked &#123;</div><div class="line">      throw(<span class="string">"invalid itab locking"</span>)</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 加到Hash Slot链表中</span></div><div class="line">   h := itabhash(inter, typ)</div><div class="line">   m.link = hash[h]</div><div class="line">   m.inhash = <span class="literal">true</span></div><div class="line">   atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，并不是每次接口赋值都要去检查一次对象是否符合接口要求，而是只在第一次生成itab信息，之后通过hash表即可找到itab信息。</p><h3 id="3-接口赋值"><a href="#3-接口赋值" class="headerlink" title="3. 接口赋值"></a>3. 接口赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</div><div class="line">   Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms MyStruct)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   a := <span class="number">1</span></div><div class="line">   b := <span class="string">"str"</span></div><div class="line">   c := MyStruct&#123;&#125;</div><div class="line">   <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125; = a</div><div class="line">   <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = b</div><div class="line">   <span class="keyword">var</span> i3 MyInterface = c</div><div class="line">   <span class="keyword">var</span> i4 <span class="keyword">interface</span>&#123;&#125; = i3</div><div class="line">   <span class="keyword">var</span> i5 = i4.(MyInterface)</div><div class="line">   fmt.Println(i1, i2, i3, i4, i5)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用go1.8编译并反汇编:</p><pre><code>$GO1.8PATH/bin/go build -gcflags &#39;-N -l&#39; -o tmp tmp.go$GO1.8PATH/bin/go tool objdump -s &quot;main\.main&quot; tmp</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">// var i1 interface&#123;&#125; = a</div><div class="line">test.go:16      0x1087146       488b442430                      MOVQ 0x30(SP), AX</div><div class="line">test.go:16      0x108714b       4889442438                      MOVQ AX, 0x38(SP)</div><div class="line">test.go:16      0x1087150       488d05a9e10000                  LEAQ 0xe1a9(IP), AX // 加载a的类型信息(int)</div><div class="line">test.go:16      0x1087157       48890424                        MOVQ AX, 0(SP)</div><div class="line">test.go:16      0x108715b       488d442438                      LEAQ 0x38(SP), AX // 加载a的地址</div><div class="line">test.go:16      0x1087160       4889442408                      MOVQ AX, 0x8(SP)</div><div class="line">test.go:16      0x1087165       e84645f8ff                      CALL runtime.convT2E(SB)</div><div class="line">test.go:16      0x108716a       488b442410                      MOVQ 0x10(SP), AX // 填充i1的type和data</div><div class="line">test.go:16      0x108716f       488b4c2418                      MOVQ 0x18(SP), CX </div><div class="line">test.go:16      0x1087174       48898424a0000000                MOVQ AX, 0xa0(SP)</div><div class="line">test.go:16      0x108717c       48898c24a8000000                MOVQ CX, 0xa8(SP)</div><div class="line">// var i2 interface&#123;&#125; = b</div><div class="line">// 与i1类似 加载类型信息 调用convT2E</div><div class="line">...</div><div class="line">test.go:17      0x10871bc       e8ef44f8ff                      CALL runtime.convT2E(SB)</div><div class="line">test.go:17      0x10871c1       488b442410                      MOVQ 0x10(SP), AX</div><div class="line">test.go:17      0x10871c6       488b4c2418                      MOVQ 0x18(SP), CX</div><div class="line">test.go:17      0x10871cb       4889842490000000                MOVQ AX, 0x90(SP)</div><div class="line">test.go:17      0x10871d3       48898c2498000000                MOVQ CX, 0x98(SP)</div><div class="line">// var i3 MyInterface = c</div><div class="line">test.go:18      0x10871db       488d051e000800                  LEAQ 0x8001e(IP), AX // 加载c的类型信息(MyStruct)</div><div class="line">test.go:18      0x10871e2       48890424                        MOVQ AX, 0(SP)</div><div class="line">test.go:18      0x10871e6       488d442430                      LEAQ 0x30(SP), AX</div><div class="line">test.go:18      0x10871eb       4889442408                      MOVQ AX, 0x8(SP)</div><div class="line">test.go:18      0x10871f0       e86b45f8ff                      CALL runtime.convT2I(SB)</div><div class="line">test.go:18      0x10871f5       488b442410                      MOVQ 0x10(SP), AX</div><div class="line">test.go:18      0x10871fa       488b4c2418                      MOVQ 0x18(SP), CX</div><div class="line">test.go:18      0x10871ff       4889842480000000                MOVQ AX, 0x80(SP)</div><div class="line">test.go:18      0x1087207       48898c2488000000                MOVQ CX, 0x88(SP)</div><div class="line">// var i4 interface&#123;&#125; = i3</div><div class="line">test.go:19      0x108720f       488b842488000000                MOVQ 0x88(SP), AX</div><div class="line">test.go:19      0x1087217       488b8c2480000000                MOVQ 0x80(SP), CX // CX = i3.itab</div><div class="line">test.go:19      0x108721f       48898c24e0000000                MOVQ CX, 0xe0(SP) </div><div class="line">test.go:19      0x1087227       48898424e8000000                MOVQ AX, 0xe8(SP) // 0xe8(SP) = i3.data</div><div class="line">test.go:19      0x108722f       48894c2448                      MOVQ CX, 0x48(SP) </div><div class="line">test.go:19      0x1087234       4885c9                          TESTQ CX, CX</div><div class="line">test.go:19      0x1087237       7505                            JNE 0x108723e</div><div class="line">test.go:19      0x1087239       e915020000                      JMP 0x1087453</div><div class="line">test.go:19      0x108723e       8401                            TESTB AL, 0(CX)</div><div class="line">test.go:19      0x1087240       488b4108                        MOVQ 0x8(CX), AX // (i3.itab+8) 得到 &amp;i3.itab.typ，因此AX=i3.itab.typ 即iface指向对象的具体类型信息，这里是MyStruct</div><div class="line">test.go:19      0x1087244       4889442448                      MOVQ AX, 0x48(SP) // 0x48(SP) = i3.itab.typ</div><div class="line">test.go:19      0x1087249       eb00                            JMP 0x108724b</div><div class="line">test.go:19      0x108724b       488b8424e8000000                MOVQ 0xe8(SP), AX // AX = i3.data</div><div class="line">test.go:19      0x1087253       488b4c2448                      MOVQ 0x48(SP), CX // CX = i3.itab.typ</div><div class="line">test.go:19      0x1087258       48894c2470                      MOVQ CX, 0x70(SP) // i4.typ = i3.itab.typ</div><div class="line">test.go:19      0x108725d       4889442478                      MOVQ AX, 0x78(SP) // i4.data = i3.data</div><div class="line">// var i5 = i4.(MyInterface)</div><div class="line">test.go:20      0x1087262       48c78424f000000000000000        MOVQ $0x0, 0xf0(SP)</div><div class="line">test.go:20      0x108726e       48c78424f800000000000000        MOVQ $0x0, 0xf8(SP)</div><div class="line">test.go:20      0x108727a       488b442478                      MOVQ 0x78(SP), AX</div><div class="line">test.go:20      0x108727f       488b4c2470                      MOVQ 0x70(SP), CX</div><div class="line">test.go:21      0x1087284       488d1535530100                  LEAQ 0x15335(IP), DX</div><div class="line">test.go:20      0x108728b       48891424                        MOVQ DX, 0(SP) // 压入 MyInterface 的 interfacetype</div><div class="line">test.go:20      0x108728f       48894c2408                      MOVQ CX, 0x8(SP) // 压入 i4.type</div><div class="line">test.go:20      0x1087294       4889442410                      MOVQ AX, 0x10(SP) // 压入 i4.data</div><div class="line">test.go:20      0x1087299       e87245f8ff                      CALL runtime.assertE2I(SB) // func assertE2I(inter *interfacetype, e eface) (r iface)</div><div class="line">...</div></pre></td></tr></table></figure><p>可以看到编译器通过convT2E和convT2I将编译器已知的类型赋给接口(其中E代表eface，I代表iface，T代表编译器已知类型，即静态类型)，编译器知晓itab的布局，会在编译期检查接口是否适配，并且生成itab信息，因此编译器生成的convT2X调用是必然成功的。</p><p>对于接口间的赋值，将iface赋给eface比较简单，直接提取eface的interfacetype和data赋给iface即可。而反过来，则需要使用接口断言，接口断言通过assertE2I, assertI2I等函数来完成，这类assert函数根据使用方调用方式有两个版本:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i5 := i4.(MyInterface)         <span class="comment">// call conv.assertE2I</span></div><div class="line">i5, ok := i4.(MyInterface)  <span class="comment">//  call conv.AssertE2I2</span></div></pre></td></tr></table></figure><p>下面看一下几个常用的conv和assert函数实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go1.8/src/runtime/iface.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E</span><span class="params">(t *_type, elem unsafe.Pointer)</span> <span class="params">(e eface)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> raceenabled &#123;</div><div class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;t)), funcPC(convT2E))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> msanenabled &#123;</div><div class="line">        msanread(elem, t.size)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> isDirectIface(t) &#123;</div><div class="line">        <span class="comment">// This case is implemented directly by the compiler.</span></div><div class="line">        throw(<span class="string">"direct convT2E"</span>)</div><div class="line">    &#125;</div><div class="line">    x := newobject(t)</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> We allocate a zeroed object only to overwrite it with</span></div><div class="line">    <span class="comment">// actual data. Figure out how to avoid zeroing. Also below in convT2I.</span></div><div class="line">    typedmemmove(t, x, elem)</div><div class="line">    e._type = t</div><div class="line">    e.data = x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</div><div class="line">    t := tab._type</div><div class="line">    <span class="keyword">if</span> raceenabled &#123;</div><div class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> msanenabled &#123;</div><div class="line">        msanread(elem, t.size)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> isDirectIface(t) &#123;</div><div class="line">        <span class="comment">// This case is implemented directly by the compiler.</span></div><div class="line">        throw(<span class="string">"direct convT2I"</span>)</div><div class="line">    &#125;</div><div class="line">    x := newobject(t)</div><div class="line">    typedmemmove(t, x, elem)</div><div class="line">    i.tab = tab</div><div class="line">    i.data = x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I</span><span class="params">(inter *interfacetype, e eface)</span> <span class="params">(r iface)</span></span> &#123;</div><div class="line">    t := e._type</div><div class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">        <span class="comment">// explicit conversions require non-nil interface value.</span></div><div class="line">        <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="string">""</span>, <span class="string">""</span>, inter.typ.<span class="keyword">string</span>(), <span class="string">""</span>&#125;)</div><div class="line">    &#125;</div><div class="line">    r.tab = getitab(inter, t, <span class="literal">false</span>)</div><div class="line">    r.data = e.data</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在assertE2I中，我们看到了getitab函数，即<code>i5=i4.(MyInterface)</code>中，会去判断i4的concretetype(MyStruct)是否满足MyInterface的interfacetype，由于前面我们执行过<code>var i3 MyInterface = c</code>，因此hash[itabhash(MyInterface, MyStruct)]已经存在itab，所以无需再次检查接口是否满足，从hash表中取出itab即可(里面针对接口的各个方法实现地址都已经初始化完成)。</p><p>而在go1.9中，有一些优化:</p><p>1.对convT2x针对简单类型(如int32,string,slice)进行特例化优化(避免typedmemmove):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">convT2E16, convT2I16</div><div class="line">convT2E32, convT2I32</div><div class="line">convT2E64, convT2I64</div><div class="line">convT2Estring, convT2Istring</div><div class="line">convT2Eslice, convT2Islice</div><div class="line">convT2Enoptr, convT2Inoptr</div></pre></td></tr></table></figure><p>据统计，在编译make.bash的时候，有93%的convT2x调用都可通过以上特例化优化。参考<a href="https://go-review.googlesource.com/c/go/+/36476" target="_blank" rel="external">这里</a>。</p><p>2.优化了剩余对convT2I的调用</p><p>由于itab由编译器生成(参考上面go1.8生成的汇编代码和convT2I函数)，可以直接由编译器将itab和elem直接赋给iface的tab和data字段，避免函数调用和typedmemmove。关于此优化可参考<a href="https://go-review.googlesource.com/c/go/+/20901/9" target="_blank" rel="external">1</a>和<a href="https://go-review.googlesource.com/c/go/+/20902" target="_blank" rel="external">2</a>。</p><p>具体汇编代码不再列出，感兴趣的同学可以自己尝试。</p><p>对接口的构造和转换本质上是对object的type和data两个字段的操作，对空接口eface来说，只需将type和data提取并填入即可，而对于非空接口iface构造和断言，需要判断object或eface是否满足接口定义，并生成对应的itab(包含接口类型，object类型，object接口实现方法地址等信息)，每个已初始化的iface都有itab字段，该字段的生成是通过hash表优化的，以及对于每个interfacetype &lt;-&gt; concrettype对，只需要生成一次itab，之后从hash表中取就可以了。由于编译器知晓itab的内存布局，因此在将iface赋给eface的时候可以避免函数调用，直接将iface.itab.typ赋给eface.typ。</p><h3 id="4-类型反射"><a href="#4-类型反射" class="headerlink" title="4. 类型反射"></a>4. 类型反射</h3><h4 id="4-1-类型-amp-值解析"><a href="#4-1-类型-amp-值解析" class="headerlink" title="4.1 类型&amp;值解析"></a>4.1 类型&amp;值解析</h4><p>类型和值解析无非就是将eface{}的_type和data字段取出进行解析，针对TypeOf的实现很简单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 代码位于relect/type.go</div><div class="line"></div><div class="line">// reflect.Type接口的实现为: reflect.rtype</div><div class="line">// reflect.rtype结构体定义和runtime._type一样，只是实现了reflect.Type接口，实现了一些诸如Elem()，Name()之类的方法:</div><div class="line"></div><div class="line">func TypeOf(i interface&#123;&#125;) Type &#123;</div><div class="line">    // emptyInterface结构体定义与eface一样，都是两个word(type和data)</div><div class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</div><div class="line">    return toType(eface.typ) // 将eface.typ赋给reflect.Type接口，供外部使用</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要知道，对于复合类型，如Ptr, Slice, Chan, Map等，它们的type信息中包含其子类型的信息，如Slice元素类型，而其元素类型也可能是复合类型，因此type实际上是一颗”类型树”，可通过<code>reflect.Elem()</code>和<code>reflect.Key()</code>等API来获取这些子类型信息，但如果如果type不匹配(比如<code>reflect.TypeOf([]int{1,2}).Key()</code>)，会panic。</p><p><code>reflect.ValueOf()</code>则要复杂一些，因为它需要根据type来决定数据应该如何被解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">type Value struct &#123;</div><div class="line">    // 值的类型</div><div class="line">    typ *rtype</div><div class="line">    // 立即数或指向数据的指针</div><div class="line">    ptr unsafe.Pointer</div><div class="line">    // type flag uintptr</div><div class="line">    // 指明值的类型，是否只读，ptr字段是否是指针等</div><div class="line">    flag</div><div class="line">&#125;</div><div class="line"></div><div class="line">func ValueOf(i interface&#123;&#125;) Value &#123;</div><div class="line">    if i == nil &#123;</div><div class="line">        return Value&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    escapes(i)</div><div class="line"></div><div class="line">    return unpackEface(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将数据从interface&#123;&#125;解包为reflec.Value</div><div class="line">func unpackEface(i interface&#123;&#125;) Value &#123;</div><div class="line">    e := (*emptyInterface)(unsafe.Pointer(&amp;i))</div><div class="line">    // NOTE: don&apos;t read e.word until we know whether it is really a pointer or not.</div><div class="line">    t := e.typ</div><div class="line">    if t == nil &#123;</div><div class="line">        return Value&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    f := flag(t.Kind())</div><div class="line">    if ifaceIndir(t) &#123;</div><div class="line">        f |= flagIndir</div><div class="line">    &#125;</div><div class="line">    return Value&#123;t, e.word, f&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 将数据由reflect.Value打包为interface&#123;&#125;</div><div class="line">func packEface(v Value) interface&#123;&#125; &#123;</div><div class="line">    t := v.typ</div><div class="line">    var i interface&#123;&#125;</div><div class="line">    e := (*emptyInterface)(unsafe.Pointer(&amp;i))</div><div class="line">    // First, fill in the data portion of the interface.</div><div class="line">    switch &#123;</div><div class="line">    case ifaceIndir(t):</div><div class="line">        if v.flag&amp;flagIndir == 0 &#123;</div><div class="line">            panic(&quot;bad indir&quot;)</div><div class="line">        &#125;</div><div class="line">        ptr := v.ptr</div><div class="line">        if v.flag&amp;flagAddr != 0 &#123;</div><div class="line">            c := unsafe_New(t)</div><div class="line">            typedmemmove(t, c, ptr)</div><div class="line">            ptr = c</div><div class="line">        &#125;</div><div class="line">        e.word = ptr</div><div class="line">    case v.flag&amp;flagIndir != 0:</div><div class="line">        e.word = *(*unsafe.Pointer)(v.ptr)</div><div class="line">    default:</div><div class="line">        e.word = v.ptr</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    e.typ = t</div><div class="line">    return i</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 将reflect.Value转换为interface&#123;&#125;，相当于reflect.ValueOf的逆操作</div><div class="line">// 等价于: var i interface&#123;&#125; = (v&apos;s underlying value)</div><div class="line">func (v Value) Interface() (i interface&#123;&#125;) &#123;</div><div class="line">   return valueInterface(v, true)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func valueInterface(v Value, safe bool) interface&#123;&#125; &#123;</div><div class="line">   if v.flag == 0 &#123;</div><div class="line">      panic(&amp;ValueError&#123;&quot;reflect.Value.Interface&quot;, 0&#125;)</div><div class="line">   &#125;</div><div class="line">   if safe &amp;&amp; v.flag&amp;flagRO != 0 &#123;</div><div class="line">      panic(&quot;reflect.Value.Interface: cannot return value obtained from unexported field or method&quot;)</div><div class="line">   &#125;</div><div class="line">   if v.flag&amp;flagMethod != 0 &#123;</div><div class="line">      v = makeMethodValue(&quot;Interface&quot;, v)</div><div class="line">   &#125;</div><div class="line">   // 当interface&#123;&#125;作为子类型时，会产生类型为Interface的Value</div><div class="line">   // 如 reflect.TypeOf(m).Elem().Kind() == Interface</div><div class="line">   if v.kind() == Interface &#123;</div><div class="line">      if v.NumMethod() == 0 &#123;</div><div class="line">         return *(*interface&#123;&#125;)(v.ptr)</div><div class="line">      &#125;</div><div class="line">      return *(*interface &#123;</div><div class="line">         M()</div><div class="line">      &#125;)(v.ptr)</div><div class="line">   &#125;</div><div class="line">   return packEface(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和<code>reflect.Type.Elem()</code>一样，<code>reflect.Value</code>也提供一系列的方法进行值解析，如<code>Elem()</code>可以得到Interface或Ptr指向的值，<code>Index()</code>可以得到Array, Slice或String对应下标的元素等。但在使用这些API前要先通过<code>reflect.Type.Kind()</code>确认类型匹配，否则会panic。</p><h4 id="4-2-类型反射"><a href="#4-2-类型反射" class="headerlink" title="4.2 类型反射"></a>4.2 类型反射</h4><p>类型&amp;值解析实际上对将interface{}的type和data提出来，以<code>reflect.Type</code>和<code>reflect.Value</code>接口暴露给用户使用，而类型反射是指提供一个reflect.Type，我们可以创建一个对应类型的对象，这可以通过<code>reflect.New()</code>来完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reflect/value.go</span></div><div class="line"><span class="comment">// New returns a Value representing a pointer to a new zero value</span></div><div class="line"><span class="comment">// for the specified type. That is, the returned Value's Type is PtrTo(typ).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(typ Type)</span> <span class="title">Value</span></span> &#123;</div><div class="line">   <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</div><div class="line">      <span class="built_in">panic</span>(<span class="string">"reflect: New(nil)"</span>)</div><div class="line">   &#125;</div><div class="line">   ptr := unsafe_New(typ.(*rtype))</div><div class="line">   fl := flag(Ptr)</div><div class="line">   <span class="keyword">return</span> Value&#123;typ.common().ptrTo(), ptr, fl&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">// runtime/malloc.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</div><div class="line">   <span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//go:linkname reflect_unsafe_New reflect.unsafe_New</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_unsafe_New</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</div><div class="line">   <span class="keyword">return</span> newobject(typ)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PS: Go的包管理看来还是不够好用，为了达成reflect包和runtime包的”解耦”，先后使用和copy struct define和link method “黑科技”。</p><p><code>reflect.New()</code>创建对应Type的对象并返回其指针，以下是一个简单的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">type User struct &#123;</div><div class="line">   UserId     int</div><div class="line">   Name   string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">   x := User&#123;UserId: 111&#125;</div><div class="line">   typ := reflect.TypeOf(x)</div><div class="line">   // reflect.New返回的是*User 而不是User</div><div class="line">   y := reflect.New(typ).Elem()</div><div class="line">   for i:=0; i&lt;typ.NumField(); i++ &#123;</div><div class="line">      // 根据每个struct field的type 设置其值</div><div class="line">      fieldT := typ.Field(i) </div><div class="line">      fieldV := y.Field(i)</div><div class="line">      kind := fieldT.Type.Kind()</div><div class="line">      if kind == reflect.Int&#123;</div><div class="line">         fieldV.SetInt(123)</div><div class="line">      &#125; else if kind == reflect.String&#123;</div><div class="line">         fieldV.SetString(&quot;wudaijun&quot;)</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   fmt.Println(y.Interface())</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上代码稍改一下，即可实现简单CSV解析：根据提供的struct原型，分析其字段，并一一映射到csv每一列，将csv读出的string转换为对应的struct field type，对于简单类型使用strconv即可完成，对于复合数据结构如Map, Slice，可使用json库来定义和解析。</p><p><code>reflect.New()</code>和<code>reflect.Zero()</code>可用于创建Type对应的对象，除此之外，reflect包还提供了<code>reflect.MapOf()</code>, <code>reflect.SliceOf()</code>等方法用于基于现有类型创建复合类型。具体源码不再列出，参考reflect/type.go和reflect/value.go。</p><p>reflect提供的反射能力不可谓不强大，但在实际使用中仍然不够好用，一个因为Go本质上是静态类型语言，要提供”动态类型”的部分语义是比较复杂和不易用的，这有点像C++提供泛型编程，虽然强大，但也是把双刃剑。</p><p>参考:</p><ol><li><a href="https://studygolang.com/articles/2917" target="_blank" rel="external">Golang汇编快速指南</a></li><li><a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="external">Go Interface源码剖析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从源码的角度学习下Go接口的底层实现，以及接口赋值，反射，断言的实现原理。作为对比，用到了go1.8.6和go1.9.1两个版本。&lt;/p&gt;
&lt;h3 id=&quot;1-eface&quot;&gt;&lt;a href=&quot;#1-eface&quot; class=&quot;headerlink&quot; title=&quot;1. eface&quot;&gt;&lt;/a&gt;1. eface&lt;/h3&gt;&lt;p&gt;空接口通过eface结构体实现，位于runtime/runtime2.go: &lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go 调度模型</title>
    <link href="http://wudaijun.com/2018/01/go-scheduler/"/>
    <id>http://wudaijun.com/2018/01/go-scheduler/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-23T02:03:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="G-P-M-模型"><a href="#G-P-M-模型" class="headerlink" title="G P M 模型"></a>G P M 模型</h3><p>定义于src/runtime/runtime2.go:</p><ul><li>G: Gourtines, 每个Goroutine对应一个G结构体，G保存Goroutine的运行堆栈，即并发任务状态。G并非执行体，每个G需要绑定到P才能被调度执行。</li><li>P: Processors, 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等</li><li>M: Machine, OS线程抽象，负责调度任务，和某个P绑定，从P的runq中不断取出G，切换堆栈并执行，M本身不具备执行状态，在需要任务切换时，M将堆栈状态写回G，任何其它M都能据此恢复执行。</li></ul><a id="more"></a><p>Go1.1之前只有G-M模型，没有P，Dmitry Vyukov在<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw" target="_blank" rel="external">Scalable Go Scheduler Design Doc</a>提出该模型在并发伸缩性方面的问题，并通过加入P(Processors)来改进该问题。</p><p>G-P-M模型示意图:</p><p><img src="/assets/image/go/go-schedule.png" alt=""></p><p>补充说明:</p><ol><li>P的个数由GOMAXPROCS指定，是固定的，因此限制最大并发数</li><li>M的个数是不定的，由Go Runtime调整，默认最大限制为10000个</li></ol><h3 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h3><p>在M与P绑定后，M会不断从P的Local队列(runq)中取出G(无锁操作)，切换到G的堆栈并执行，当P的Local队列中没有G时，再从Global队列中返回一个G(有锁操作，因此实际还会从Global队列批量转移一批G到P Local队列)，当Global队列中也没有待运行的G时，则尝试从其它的P窃取(steal)部分G来执行，源代码如下:</p><pre><code>// go1.9.1  src/runtime/proc.go// 省略了GC检查等其它细节，只保留了主要流程// g:       G结构体定义// sched:   Global队列// 获取一个待执行的Gfunc findrunnable() (gp *g, inheritTime bool) {    // 获取当前的G对象    _g_ := getg()top:    // 获取当前P对象    _p_ := _g_.m.p.ptr()    // 1. 尝试从P的Local队列中取得G 优先_p_.runnext 然后再从Local队列中取    if gp, inheritTime := runqget(_p_); gp != nil {        return gp, inheritTime    }    // 2. 尝试从Global队列中取得G    if sched.runqsize != 0 {        lock(&amp;sched.lock)        // globrunqget从Global队列中获取G 并转移一批G到_p_的Local队列        gp := globrunqget(_p_, 0)        unlock(&amp;sched.lock)        if gp != nil {            return gp, false        }    }    // 3. 检查netpoll任务    if netpollinited() &amp;&amp; sched.lastpoll != 0 {        if gp := netpoll(false); gp != nil { // non-blocking            // netpoll返回的是G链表，将其它G放回Global队列            injectglist(gp.schedlink.ptr())            casgstatus(gp, _Gwaiting, _Grunnable)            if trace.enabled {                traceGoUnpark(gp, 0)            }            return gp, false        }    }    // 4. 尝试从其它P窃取任务    procs := uint32(gomaxprocs)    if atomic.Load(&amp;sched.npidle) == procs-1 {        goto stop    }    if !_g_.m.spinning {        _g_.m.spinning = true        atomic.Xadd(&amp;sched.nmspinning, 1)    }    for i := 0; i &lt; 4; i++ {        // 随机P的遍历顺序        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {            if sched.gcwaiting != 0 {                goto top            }            stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g            // runqsteal执行实际的steal工作，从目标P的Local队列转移一般的G过来            // stealRunNextG指是否steal目标P的p.runnext G            if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {                return gp, false            }        }    }    ...}</code></pre><p>当没有G可被执行时，M会与P解绑，然后进入休眠(idle)状态。</p><h3 id="用户态阻塞-唤醒"><a href="#用户态阻塞-唤醒" class="headerlink" title="用户态阻塞/唤醒"></a>用户态阻塞/唤醒</h3><p>当Goroutine因为Channel操作而阻塞(通过gopark)时，对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而M会跳过该G尝试获取并执行下一个G。</p><p>当阻塞的G被G2唤醒(通过goready)时(比如channel可读/写)，G会尝试加入G2所在P的runnext，然后再是P Local队列和Global队列。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当G被阻塞在某个系统调用上时，此时G会阻塞在<code>_Gsyscall</code>状态，M也处于block on syscall状态，此时仍然可被抢占调度: 执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但队列中仍然有G需要执行，则创建一个新的M。</p><p>当系统调用完成后，G会重新尝试获取一个idle的P，并恢复执行，如果没有idle的P，G将加入到Global队列。</p><p>系统调用能被调度的关键有两点:</p><p>runtime/syscall包中，将系统调用分为SysCall和RawSysCall，前者和后者的区别是前者会在系统调用前后分别调用entersyscall和exitsyscall(位于src/runtime/proc.go)，做一些现场保存和恢复操作，这样才能使P安全地与M解绑，并在其它M上继续执行其它G。某些系统调用本身可以确定会长时间阻塞(比如锁)，会调用entersyscallblock在发起系统调用前直接让P和M解绑(handoffp)。</p><p>另一个关键点是sysmon，它负责检查所有系统调用的执行时间，判断是否需要handoffp。</p><h3 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h3><p>sysmon是一个由runtime启动的M，也叫监控线程，它无需P也可以运行，它每20us~10ms唤醒一次，主要执行:</p><ol><li>释放闲置超过5分钟的span物理内存； </li><li>如果超过2分钟没有垃圾回收，强制执行；</li><li>将长时间未处理的netpoll结果添加到任务队列；</li><li>向长时间运行的G任务发出抢占调度； </li><li>收回因syscall长时间阻塞的P；</li></ol><p>入口在src/runtime/proc.go:sysmon函数，它通过retake实现对syscall和长时间运行的G进行调度:</p><pre><code>func retake(now int64) uint32 {    n := 0    for i := int32(0); i &lt; gomaxprocs; i++ {        _p_ := allp[i]        if _p_ == nil {            continue        }        pd := &amp;_p_.sysmontick        s := _p_.status        if s == _Psyscall {            // Retake P from syscall if it&#39;s there for more than 1 sysmon tick (at least 20us).            t := int64(_p_.syscalltick)            if int64(pd.syscalltick) != t {                pd.syscalltick = uint32(t)                pd.syscallwhen = now                continue            }            // 如果当前P Local队列没有其它G，当前有其它P处于Idle状态，并且syscall执行事件不超过10ms，则不用解绑当前P(handoffp)            if runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; 0 &amp;&amp; pd.syscallwhen+10*1000*1000 &gt; now {                continue            }            // handoffp            incidlelocked(-1)            if atomic.Cas(&amp;_p_.status, s, _Pidle) {                if trace.enabled {                    traceGoSysBlock(_p_)                    traceProcStop(_p_)                }                n++                _p_.syscalltick++                handoffp(_p_)            }            incidlelocked(1)        } else if s == _Prunning {            // Preempt G if it&#39;s running for too long.            t := int64(_p_.schedtick)            if int64(pd.schedtick) != t {                pd.schedtick = uint32(t)                pd.schedwhen = now                continue            }            // 如果当前G执行时间超过10ms，则抢占(preemptone)            if pd.schedwhen+forcePreemptNS &gt; now {                continue            }            // 执行抢占            preemptone(_p_)        }    }    return uint32(n)}</code></pre><h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p>当某个goroutine执行超过10ms，sysmon会向其发起抢占调度请求，由于Go调度不像OS调度那样有时间片的概念，因此实际抢占机制要弱很多: Go中的抢占实际上是为G设置抢占标记(g.stackguard0)，当G调用某函数时(更确切说，在通过newstack分配函数栈时)，被编译器安插的指令会检查这个标记，并且将当前G以runtime.Goched的方式暂停，并加入到全局队列。源代码如下:</p><pre><code>// src/runtime/stack.go// Called from runtime·morestack when more stack is needed.// Allocate larger stack and relocate to new stack.// Stack growth is multiplicative, for constant amortized cost.func newstack(ctxt unsafe.Pointer) {    ...    // gp为当前G    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt    if preempt {        ...        // Act like goroutine called runtime.Gosched.        // G状态由_Gwaiting变为 _Grunning 这是为了能以Gosched的方式暂停Go        casgstatus(gp, _Gwaiting, _Grunning)        gopreempt_m(gp) // never return    }}// 以goched的方式将G重新放入func goschedImpl(gp *g) {    status := readgstatus(gp)    // 由Running变为Runnable    casgstatus(gp, _Grunning, _Grunnable)    // 与M解除绑定    dropg()    lock(&amp;sched.lock)    // 将G放入Global队列    globrunqput(gp)    unlock(&amp;sched.lock)    // 重新调度    schedule()}func gopreempt_m(gp *g) {    if trace.enabled {        traceGoPreempt()    }    goschedImpl(gp)}</code></pre><h3 id="netpoll"><a href="#netpoll" class="headerlink" title="netpoll"></a>netpoll</h3><p>前面的findrunnable，G的获取除了p.runnext，p.runq和sched.runq外，还有一中G从netpoll中获取，<a href="http://morsmachine.dk/netpoller" target="_blank" rel="external">netpoll</a>是Go针对网络IO的一种优化，本质上为了避免网络IO陷入系统调用之中，这样使得即便G发起网络I/O操作也不会导致M被阻塞（仅阻塞G），从而不会导致大量M被创建出来。</p><h3 id="G创建流程"><a href="#G创建流程" class="headerlink" title="G创建流程"></a>G创建流程</h3><p>G结构体会复用，对可复用的G管理类似于待运行的G管理，也有Local队列(p.gfree)和Global队列(sched.gfree)之分，获取算法差不多，优先从p.gfree中获取(无锁操作)，否则从sched.gfree中获取并批量转移一部分(有锁操作)，源代码参考src/runtime/proc.go:gfget函数。</p><p>从Goroutine的角度来看，通过<code>go func()</code>创建时，会从当前闲置的G队列取得可复用的G，如果没有则通过malg新建一个G，然后:</p><ol><li>尝试将G添加到当前P的runnext中，作为下一个执行的G</li><li>否则放到Local队列runq中(无锁)</li><li>如果以上操作都失败，则添加到Global队列sched.runq中(有锁操作，因此也会顺便将当P.runq中一半的G转移到sched.runq)</li></ol><h3 id="G的几种暂停方式"><a href="#G的几种暂停方式" class="headerlink" title="G的几种暂停方式:"></a>G的几种暂停方式:</h3><ol><li>goched: 将当前的G暂停，保存堆栈状态，以Runnable状态放入Global队列中，让当前M继续执行其它任务。无需对G进行唤醒操作，因为总会有M从Global队列取得并执行该M。抢占调度即使用该方式。</li><li>gopark: 与goched的最大区别在于gopark没有将G放回执行队列，而是位于某个等待队列中(如channel的waitq，此时G状态为<code>_Gwaitting</code>)，因此G必须被手动唤醒(通过goready)，否则会丢失任务。应用层阻塞通常使用这种方式。</li><li>notesleep: 既不让出M，也不让G重回任务队列，直接让线程休眠直到被唤醒，该方式更快，通常用于gcMark，stopm这类自旋场景</li><li>goexit: 立即终止G任务，不管其处于调用堆栈的哪个层次，在终止前，确保所有defer正确执行。</li></ol><h3 id="Go调度器的查看方法"><a href="#Go调度器的查看方法" class="headerlink" title="Go调度器的查看方法"></a>Go调度器的查看方法</h3><p>示例程序，对比cgo sleep和time.sleep系统调用情况:</p><pre><code>// #include &lt;unistd.h&gt;import &quot;C&quot;func main() {    var wg sync.WaitGroup    wg.Add(1000)    for i := 0; i &lt; 1000; i++ {        go func() {            C.sleep(1)                     // 测试1            // time.Sleep(time.Second)     // 测试2            wg.Done()        }()    }    wg.Wait()    println(&quot;done!&quot;)    time.Sleep(time.Second * 3)}</code></pre><p>通过GODEBUG运行时环境变量的schedtrace=1000参数，可以每隔1000ms查看一次调度器状态:</p><pre><code>$ GODEBUG=schedtrace=1000 ./test// 测试1输出结果SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=1003 spinningthreads=2 idlethreads=32 runqueue=0 [0 0 0 0]done!SCHED 1001ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]SCHED 2001ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]SCHED 3010ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]// 测试2输出结果SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=1 idlethreads=2 runqueue=129 [0 128 0 0]done!SCHED 1009ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]SCHED 2010ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]SCHED 3019ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</code></pre><p>其中schedtrace日志每一行的字段意义:</p><pre><code>SCHED：调试信息输出标志字符串，代表本行是goroutine scheduler的输出；1001ms：即从程序启动到输出这行日志的时间；gomaxprocs: P的数量；idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；threads: os threads的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；spinningthreads: 处于自旋状态的os thread数量；idlethread: 处于idle状态的os thread的数量；runqueue： go scheduler全局队列中G的数量；[0 0 0 0]: 分别为4个P的local queue中的G的数量。</code></pre><p>可以看出，time.Sleep并没有使用系统调用，而是进行了类似netpoll类似的优化，使得仅仅是G阻塞，M不会阻塞，而在使用cgo sleep的情况下，可以看到大量的闲置M。</p><p>通过运行时环境变量GODEBUG的schedtrace参数可定时查看调度器状态:</p><pre><code>// 每1000ms打印一次$GODEBUG=schedtrace=1000 godoc -http=:6060SCHED 0ms: gomaxprocs=4 idleprocs=3 threads=3 spinningthreads=0 idlethreads=0 runqueue=0 [0 0 0 0]SCHED 1001ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=0 idlethreads=3 runqueue=2 [8 14 5 2]SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=25 spinningthreads=0 idlethreads=19 runqueue=12 [0 0 4 0]SCHED 3006ms: gomaxprocs=4 idleprocs=0 threads=26 spinningthreads=0 idlethreads=8 runqueue=2 [0 1 1 0]...</code></pre><p> GODEBUG还可使用<code>GODEBUG=&quot;schedtrace=1000,scheddetail=1&quot;</code>选项来查看每个G,P,M的调度状态，打出的信息非常详尽复杂，平时应该是用不到。关于Go调试可参考Dmitry Vyukov大牛的<a href="https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs" target="_blank" rel="external">Debugging performance issues in Go programs</a>。</p><p>参考资料:</p><ol><li><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="external">scheduler-tracing-in-go</a></li><li><a href="http://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="external">也谈goroutine调度器—TonyBai</a></li><li><a href="https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf" target="_blank" rel="external">Go学习笔记—雨痕</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;G-P-M-模型&quot;&gt;&lt;a href=&quot;#G-P-M-模型&quot; class=&quot;headerlink&quot; title=&quot;G P M 模型&quot;&gt;&lt;/a&gt;G P M 模型&lt;/h3&gt;&lt;p&gt;定义于src/runtime/runtime2.go:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G: Gourtines, 每个Goroutine对应一个G结构体，G保存Goroutine的运行堆栈，即并发任务状态。G并非执行体，每个G需要绑定到P才能被调度执行。&lt;/li&gt;
&lt;li&gt;P: Processors, 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等&lt;/li&gt;
&lt;li&gt;M: Machine, OS线程抽象，负责调度任务，和某个P绑定，从P的runq中不断取出G，切换堆栈并执行，M本身不具备执行状态，在需要任务切换时，M将堆栈状态写回G，任何其它M都能据此恢复执行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>常见GC算法</title>
    <link href="http://wudaijun.com/2017/12/gc-study/"/>
    <id>http://wudaijun.com/2017/12/gc-study/</id>
    <published>2017-12-02T16:00:00.000Z</published>
    <updated>2017-12-20T08:12:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来看看GC(自动垃圾回收)的主要问题:</p><ol><li>额外的开销(内存/CPU)</li><li>执行GC的时机无法预测，在实时性要求高的场景或事务处理来说可能是不可容忍的</li><li>部分GC算法会Stop-the-world</li></ol><p>各语言运行时在选取GC算法时，都要从这几个方面进行衡量与取舍，下面是一些常见的GC算法。</p><a id="more"></a><h3 id="引用计数-Reference-counting"><a href="#引用计数-Reference-counting" class="headerlink" title="引用计数(Reference counting):"></a>引用计数(Reference counting):</h3><p>为每个对象维护一个计数，保存其它对象指向它的引用数量。当一个引用被覆盖或销毁，该引用对象的引用计数-1，当一个引用被建立或拷贝，引用对象的引用计数+1，如果对象的引用计数为0，则表明该对象不再被访问(inaccessible)，将被回收。引用计数有如下优缺点:</p><p>优点:</p><ol><li>GC开销将被均摊到程序运行期，不会有长时间的回收周期。</li><li>每个对象的生命周期被明确定义，可用于某些编译器的runtime优化。</li><li>算法简单，易于实现。</li><li>即时回收，不会等内存状态到达某个阀值再执行回收。</li></ol><p>缺点:</p><ol><li>引用计数会频繁更新，带来效率开销</li><li>原生的引用计数算法无法回收循环引用的对象链(如<a href="http://wudaijun.com/2014/12/shared_ptr-reference/">C++ shared_ptr引用链</a>)</li></ol><p>针对第一个频繁更新的缺点，可以使用延迟更新和合并更新等技术，这通常能够很好优化局部频繁的引用更新(如for循环)，虽然这也增加了算法实现复杂度。</p><p>针对循环引用的问题，一种解决方案是弱引用(<a href="https://en.wikipedia.org/wiki/Weak_reference" target="_blank" rel="external">weak reference</a>)，弱引用不影响GC，通常的实践是owner持有child的强引用，child持有owner的弱引用，在事件注册器或其它容器中，如果你只希望保存这个引用，但不希望这个引用影响GC时，也可弱引用。弱引用在使用时，需要先判断对象是否还存在，如C++的weak_ptr需要先转换为shared_ptr。但这不能完全避免无意的循环墙引用，一些GC算法可以检测循环引用，例如以追踪式GC的思路，从根出发，回收那些不可达的对象。</p><h3 id="标记-清扫-Mark-and-Sweep"><a href="#标记-清扫-Mark-and-Sweep" class="headerlink" title="标记-清扫(Mark-and-Sweep):"></a>标记-清扫(Mark-and-Sweep):</h3><p>标记-清扫算法为每个对象预留一个Flag位，分为两个阶段，标记阶段会从Root向下递归遍历所有对象，并将所有可达对象的Flag位设为”正在使用”。第二阶段，清扫阶段，遍历所有内存，回收那些所有未被标记为”正在使用”的对象。整个算法的思路很简单，也基本上避免了引用计数法的缺点，但最大的缺点在于回收期间整个系统必须暂停(Stop-the-world)。</p><p><img src="/assets/image/os/mark-and-sweep.gif" alt=""></p><h3 id="三色标记法-Tri-color-marking"><a href="#三色标记法-Tri-color-marking" class="headerlink" title="三色标记法(Tri-color marking):"></a>三色标记法(Tri-color marking):</h3><p>针对原生标记-清扫算法标记过程会STW的缺点，三色标记法改进了标记方案。三色标记法将所有对象分为三类:</p><ul><li>白色: GC的候选对象集合(待处理)</li><li>灰色: 可从根访问，并且还未扫描对白色集合对象的引用(处理中,不会被GC,但引用待确认)</li><li>黑色: 可从根访问，并且不存在对白色集合的引用(处理完成)</li></ul><p>步骤如下:</p><ol><li>初始化，所有对象都是白色</li><li>从根遍历，所有可达对象标记为灰色</li><li>从灰色对象队列中取出对象，将其引用的对象标记为灰色，并将自己标记为黑色</li><li>重复第三步，直到灰色队列为空，此时白色对象即为孤儿对象，进行回收</li></ol><p>三色标记法有个重要的不变量: <strong>黑色对象不会引用任何白色对象</strong>，因此白色对象可以在灰色对象处理完成之后立即回收。此算法最大的特点在于将标记过程拆分和量化，使得用户程序和标记过程可并行执行(需要其它技术追踪标记过程中的对象引用变更)，不用Stop-the-world，算法可按照各个集合的大小阶段性执行GC，并且不用遍历整个内存空间。</p><p><img src="/assets/image/os/tri-color-marking.gif" alt=""></p><h3 id="半空间回收器-semi-space-collector"><a href="#半空间回收器-semi-space-collector" class="headerlink" title="半空间回收器(semi-space collector)"></a>半空间回收器(semi-space collector)</h3><p>半空间收集器将内存分为两半，分别叫<strong>from space</strong>和<strong>to space</strong>，初始时，所有的对象都在<strong>to space</strong>中分配直到空间用完，触发一次回收周期，此时<strong>to space</strong>和<strong>from space</strong>互换，然后将所有根可访问的对象从<strong>from space</strong>拷贝到<strong>to space</strong>，之后程序可以继续执行。新的对象继续在新的<strong>to space</strong>中分配，直到再次空间用完触发回收。该算法的优点是所有存活的数据结构都紧凑排列在<strong>to space</strong>，内存分配也可通过简单的分配指针自增来实现，缺点是浪费了一半的内存空间。这种GC方案也叫<strong>stop-and-copy</strong>。</p><h3 id="三色标记法的一些变形"><a href="#三色标记法的一些变形" class="headerlink" title="三色标记法的一些变形"></a>三色标记法的一些变形</h3><h4 id="moving-or-non-moving"><a href="#moving-or-non-moving" class="headerlink" title="moving or non-moving"></a>moving or non-moving</h4><p>三色标记法执行标记流程后(灰色队列为空)，所有的白色对象可被回收，那么这些白色对象是直接被回收，其它不变还是执行内存拷贝(non-moving)，将黑色对象移动并覆盖不再使用的白色对象内存(moving)。相当于执行内存块调整(compact)，可以让内存结构更有序，下次分配更快。这部分算法独立于三色标记，可以由GC算法在运行时选择。</p><h4 id="mark-and-non-sweep"><a href="#mark-and-non-sweep" class="headerlink" title="mark and non-sweep"></a>mark and non-sweep</h4><p>基于半空间收集器的copy思路，可以运用到三色标记法中，通过颜色互换来模拟space互换，该算法对三色标记的颜色定义有所不同，步骤如下:</p><ol><li>对象只有黑色与白色两种颜色，并且黑色与白色是可以互换的(可通过修改黑白的位映射来实现，无需修改对象)</li><li>所有可被访问的对象都是黑色，所有可被回收的对象为白色</li><li>对象从白色对象空间分配，被分配后即标记为黑色</li><li>当内存空间不足(不再有白色对象)，触发GC，此时所有黑色对象变为白色对象，从根遍历所有可访问的对象，将其由白色变为黑色，此时剩下的白色即为可被回收对象，程序可继续运行</li><li>程序继续从白色空间分配，直到白色空间用完，再次触发GC</li></ol><h3 id="分代GC-Generational-GC"><a href="#分代GC-Generational-GC" class="headerlink" title="分代GC(Generational GC)"></a>分代GC(Generational GC)</h3><p>前面的各种标记扫描算法，都有一个缺点，每次需要遍历标记所有可达对象，包括一些长期存活的对象，或者说，GC也具有局部性: 最近被分配的对象越容易不再使用。分代GC即基于这一启发，它将内存空间按”代(Generation)”分为几个部分(通常是两代，即Young Generation和Old Generation)，并尽可能频繁地在年轻的一代执行GC，当年轻一代的内存空间不够时，将可达对象全部移到上一代，此时年轻代的内存全部闲置，可用于分配新对象，这样更快并且通常也更有效率。当老一代GC不够用时，才执行Full Sweep。</p><p>通常大部分语言的运行时都会混合多种GC算法，比如Erlang的GC(参考<a href="https://segmentfault.com/a/1190000003758525" target="_blank" rel="external">1</a>,<a href="http://blog.csdn.net/mycwq/article/details/26613275" target="_blank" rel="external">2</a>)就混合了分代GC和引用计数(高效)，在进程堆内使用分代GC，对全局数据使用引用计数(即时释放内存)。</p><p>参考:</p><ol><li><a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="external">Reference counting - wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="external">Tracing garbage collection - wikipedia</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看看GC(自动垃圾回收)的主要问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;额外的开销(内存/CPU)&lt;/li&gt;
&lt;li&gt;执行GC的时机无法预测，在实时性要求高的场景或事务处理来说可能是不可容忍的&lt;/li&gt;
&lt;li&gt;部分GC算法会Stop-the-world&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各语言运行时在选取GC算法时，都要从这几个方面进行衡量与取舍，下面是一些常见的GC算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="gc" scheme="http://wudaijun.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用mathjax渲染公式</title>
    <link href="http://wudaijun.com/2017/12/hexo-with-mathjax/"/>
    <id>http://wudaijun.com/2017/12/hexo-with-mathjax/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2017-12-02T15:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在博客中嵌入公式的需求，目前主要有两个数学公式渲染引擎mathjax和KaTeX，前者应用更广泛，支持的语法更全面，因此这里简述将mathjax整合到hexo。</p><h4 id="1-替换Markdown渲染器"><a href="#1-替换Markdown渲染器" class="headerlink" title="1. 替换Markdown渲染器"></a>1. 替换Markdown渲染器</h4><pre><code>npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save</code></pre><p>hexo-renderer-karmed渲染器fork自hexo-renderer-marked，对mathjax的支持更友好，特别是下划线处理(marked会优先将<code>_</code>之间的内容斜体转义)</p><h4 id="2-挂载mathjax脚本"><a href="#2-挂载mathjax脚本" class="headerlink" title="2. 挂载mathjax脚本"></a>2. 挂载mathjax脚本</h4><p>在主题<code>layout/_partial/</code>目录下添加mathjax.ejs:</p><pre><code>&lt;!-- mathjax config similar to math.stackexchange --&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;  MathJax.Hub.Config({    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      processEscapes: true    }  });&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;    MathJax.Hub.Config({      tex2jax: {        skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]      }    });&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;    MathJax.Hub.Queue(function() {        var all = MathJax.Hub.getAllJax(), i;        for(i=0; i &lt; all.length; i += 1) {            all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;        }    });&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=theme.cdn.mathjax + &quot;/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;</code></pre><p>如果用的是jade模板，则添加mathjax.jade:</p><pre><code>//mathjax config similar to math.stackexchangescript(type=&quot;text/x-mathjax-config&quot;).  MathJax.Hub.Config({    tex2jax: {      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],      displayMath: [ [&#39;$$&#39;,&#39;$$&#39;], [&quot;\\[&quot;,&quot;\\]&quot;] ],      processEscapes: true    }  });script(type=&quot;text/x-mathjax-config&quot;).  MathJax.Hub.Config({    tex2jax: {      skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]    }  });script(async, type=&quot;text/javascript&quot;, src=theme.cdn.mathjax + &#39;/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#39;)</code></pre><p>在<code>_partial/after_footer.ejs</code>中添加:</p><pre><code>&lt;% if (page.mathjax){ %&gt;&lt;%- partial(&#39;mathjax&#39;) %&gt;&lt;% } %&gt;</code></pre><p>如果是jade模板，则在<code>_partial/after_footer.jade</code>中添加:</p><pre><code>if page.mathjax == true  include mathjax</code></pre><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h4><p>在主题_config.yml中配置mathjax cdn:</p><pre><code>cdn:    mathjax: https://cdn.mathjax.org</code></pre><p>当需要用到mathjax渲染器时，在文章头部添加<code>mathjax:true</code>:</p><pre><code>layout: postmathjax: true...</code></pre><p>只有添加该选项的文章才会加载mathjax渲染器。</p><h4 id="4-支持mathjax的Markdown编辑器"><a href="#4-支持mathjax的Markdown编辑器" class="headerlink" title="4. 支持mathjax的Markdown编辑器:"></a>4. 支持mathjax的Markdown编辑器:</h4><ul><li><a href="www.inkcode.net/qute">Qute</a> 原生支持mathjax，界面有点Geek。</li><li><p><a href="https://macdown.uranusjr.com/" target="_blank" rel="external">Macdown</a>: Macdown原生不支持mathjax，在md文件中添加(注意https，Macdown为了安全，只会加载https的远程脚本):</p><pre><code>  &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;  MathJax.Hub.Config({      tex2jax: {          inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],          displayMath: [ [&#39;$$&#39;,&#39;$$&#39;], [&quot;\\[&quot;,&quot;\\]&quot;] ],},      TeX: {equationNumbers: {          autoNumber: &quot;AMS&quot;        },Augment: {  Definitions: {         macros: {           overbracket:  [&#39;UnderOver&#39;,&#39;23B4&#39;,1],           underbracket: [&#39;UnderOver&#39;,&#39;23B5&#39;,1],         }       }}},  });  &lt;/script&gt;</code></pre></li></ul><h4 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例:"></a>5. 示例:</h4><pre><code>行内公式: $$ a+b=c $$行间公式:$$\left( \begin{array}{ccc}a &amp; b &amp; c \\d &amp; e &amp; f \\g &amp; h &amp; i\end{array} \right)$$</code></pre><p>得到:</p><p>行内公式: $ a+b=c $</p><p>行间公式:</p><script type="math/tex; mode=display">\left( \begin{array}{ccc}a & b & c \\d & e & f \\g & h & i\end{array} \right)</script><p>具体mathjax语法，这里有一篇不错的<a href="http://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="external">博客</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有在博客中嵌入公式的需求，目前主要有两个数学公式渲染引擎mathjax和KaTeX，前者应用更广泛，支持的语法更全面，因此这里简述将mathjax整合到hexo。&lt;/p&gt;
&lt;h4 id=&quot;1-替换Markdown渲染器&quot;&gt;&lt;a href=&quot;#1-替换Markdown渲染
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="hexo" scheme="http://wudaijun.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>docker 网络模式</title>
    <link href="http://wudaijun.com/2017/11/docker-network/"/>
    <id>http://wudaijun.com/2017/11/docker-network/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-12-02T06:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>以Docker为平台部署服务器时，最应该理解透彻的便是网络配置。离上次学习，Docker网络又更新了不少内容，重新温习一下。</p><p>通过<code>docker run</code>的<code>--network</code>选项可配置容器的网络模式，Docker提供了多种网络工作模式，通过<code>docker network ls</code>可查看默认提供的三种网络模式: none, host, bridge</p><h3 id="none-模式"><a href="#none-模式" class="headerlink" title="none 模式"></a>none 模式</h3><p>不为Docker容器进行任何网络配置，容器将不能访问任何外部的路由(容器内部仍然有loopback接口)，需要手动为其配置网卡，指定IP等，否则与外部只能通过文件IO和标准输入输出交互，或通过<code>docker attach 容器ID</code>进入容器。</p><h3 id="host-模式"><a href="#host-模式" class="headerlink" title="host 模式"></a>host 模式</h3><p>与宿主机共用网络栈，IP和端口，容器本身看起来就像是个普通的进程，它暴露的端口可直接通过宿主机访问。相比于bridge模式，host模式有显著的性能优势(因为走的是宿主机的网络栈，而不是docker deamon为容器虚拟的网络栈)。</p><h3 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h3><p>默认网络模式，此模式下，容器有自己的独立的Network Namespace。简单来说，Docker在宿主机上虚拟了一个子网络，宿主机上所有容器均在这个子网络中获取IP，这个子网通过网桥挂在宿主机网络上。Docker通过NAT技术确保容器可与宿主机外部网络交互。</p><p><img src="/assets/image/tool/docker-bridge.png" alt=""></p><p>Docker服务默认会创建一个docker0网桥，并为网桥指定IP和子网掩码(通常为172.17.0.1/16)。当启动bridge模式的容器时，Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备。veth pair技术保证无论哪一个veth收到报文，都将转发给另一方。veth pair的一端默认挂在docker0网桥上，另一端添加到容器的namespace下，并重命名为eth0，保证容器独享eth0，做到网络隔离。连接在同一个Docker网桥上的容器可以通过IP相互访问。如此实现了宿主机到容器，容器与容器之间的联通性。</p><p>关于网桥:</p><ul><li><p>网桥(Bridges):<br>  工作在数据链路层，连接多个端口，负责转发数据帧。网桥知道它的各个端口的数据链路协议(目前几乎都是以太网)，将来自一个端口的数据帧转发到其它所有端口。有多个端口的网桥又叫做交换机，目前这两个概念没有本质区别。</p><p>  网桥可以用来连接不同的局域网(LAN)，按照最简单的方法，网桥会将某个端口收到的数据无脑转发给其它所有端口，这种泛洪(Flooding)算法效率过低，网桥依靠转发表来转发数据帧，通过自学习算法，记录各个Mac地址在对应哪个端口(转发表数据库)，辅之超时遗忘(Aging)和无环拓扑算法(Loop-Free Topology，典型地如Spanning Tree Protocol, STP)。</p></li><li><p>Linux网桥:</p><p>  Linux下网桥是一个虚拟设备，你可以通过命令创建它，并且为其挂载设备(物理或虚拟网卡)。可通过<code>brctl</code>命令来创建和Linux网桥。管理Linux bridge的具体用法参考: <a href="https://wiki.linuxfoundation.org/networking/bridge。" target="_blank" rel="external">https://wiki.linuxfoundation.org/networking/bridge。</a></p></li><li><p>Docker网桥:</p><p>  Docker网桥通过Linux网桥实现，加上NAT, veth pair, 网络命名空间等技术，实现网络隔离和容器互联。可通过<code>sudo docker network inspect bridge</code>查看Docker网桥配置以及状态。</p></li></ul><p>当容器需要和宿主机外部网络交互时，会在宿主机上分配一个可用端口，通过这个端口做SNAT转换(将容器IP:Port换为宿主机IP:Port)，再向外部网络发出请求。当外部响应到达时，Docker再根据这一层端口映射关系，将响应路由给容器IP:Port。</p><p>外部网络要访问容器Port0，需要先将Port0与宿主机Port1绑定(外部网络无法直接访问宿主机二级网络)，将宿主机IP:Port1暴露给外部网络，外部网络请求到达宿主机时，会进行DNAT转换(将宿主机IP:Port1换为容器IP:Port0)。</p><p>从实现上来讲，Docker的这种NAT(实际上是NATP，包含IP,Port的转换)规则，是Docker Daemon通过修改ipatables规则来实现的，ubuntu下可通过<code>sudo ipatbles -t nat -L</code>来查看和NAT相关的规则。</p><p>总之，Docker容器在bridge模式下不具有一个公有IP，即和宿主机的eth0不处于同一个网段。导致的结果是宿主机以外的世界不能直接和容器进行通信。虽然NAT模式经过中间处理实现了这一点，但是NAT模式仍然存在问题与不便，如：容器均需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等。另外NAT模式会一定程度的影响网络传输效率。</p><p>默认设置下，Docker允许容器之间的互联，可通过<code>--icc=false</code>关闭容器互联(通过iptables DROP实现)，此时容器间相互访问只能通过<code>--link</code>选项链接容器来实现容器访问。<code>—link</code> 选项实际在链接容器的/etc/hosts中添加了一行被链接容器名和其IP的映射，并且会在被链接容器重启后更新该行(这样即使IP有变动也可以通过容器名正确连接)，此外还会添加一条针对两个容器允许连接的iptables规则。但Docker官方文档说<code>--link</code>已经是遗留的选项，更推荐自定义网络模式。</p><h3 id="自定义模式"><a href="#自定义模式" class="headerlink" title="自定义模式"></a>自定义模式</h3><h4 id="自定义bridge网络"><a href="#自定义bridge网络" class="headerlink" title="自定义bridge网络"></a>自定义bridge网络</h4><p>即创建一个新的bridge网络，它的行为和默认的bridge网络类似，可通过<code>docker network</code>创建一个docker网桥:</p><pre><code># 创建一个Docker网桥 命名为my_bridgedocker network create --driver bridge my_bridge# 查看当前Docker支持的所有网络模式 (会多出一个bridge网络模式，名为my_bridge)docker network ls# 将容器挂在my_bridge网桥上docker run --network=my_bridge -it --rm ubuntu# 查看 my_bridge网桥配置和状态docker network inspect my_bridge# 移除 my_bridge网桥docker network rm my_bridge</code></pre><p>自定义网桥通常用于创建一个小的容器网络，在自定义网桥中，<code>--link</code>选项不被支持。</p><h4 id="自定义overlay网络"><a href="#自定义overlay网络" class="headerlink" title="自定义overlay网络"></a>自定义overlay网络</h4><p>前面提到的网络模式，主要解决同一个主机上容器与容器，容器与主机，容器与外界的连接方案，如果要实现跨主机的容器与容器之间的通信方案，可以:</p><ol><li>端口映射</li><li>将物理网卡挂在Docker网桥上，将容器和宿主机配置在同一网段下，见参考3</li><li>使用<a href="http://docs.openvswitch.org/en/latest/howto/docker/" target="_blank" rel="external">OpenvSwich网桥</a>，如通过配置工具pipework，见参考4</li><li>在Docker1.9之后，可以使用原生解决方案Docker overlay</li></ol><p><img src="/assets/image/tool/docker-overlay.png" alt=""></p><p><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">图片出处</a></p><p>overlay网络可以实现跨主机的容器VLAN，具体使用可以参考<a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a>。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在使用Docker时，要注意平台之间实现的差异性，如[Docker For Mac]的实现和标准Docker规范有区别，Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的(而不是像Linux上那样作为进程运行于宿主机)，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。文档在这一点上并没有充分说明，容易踩坑。参考<a href="https://docs.docker.com/docker-for-mac/networking/" target="_blank" rel="external">Docker文档</a> 和 <a href="https://forums.docker.com/t/should-docker-run-net-host-work/14215" target="_blank" rel="external">这篇帖子</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>bridge模式的详细实现可参考[Docker源码分析(七)：Docker Container网络(上)][]</p><ol><li><a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part7" target="_blank" rel="external">Docker源码分析(七)：Docker Container网络(上)</a></li><li><a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="external">Docker networking</a></li><li><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a></li><li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice" target="_blank" rel="external">Docker网络详解及pipework源码解读与实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以Docker为平台部署服务器时，最应该理解透彻的便是网络配置。离上次学习，Docker网络又更新了不少内容，重新温习一下。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;docker run&lt;/code&gt;的&lt;code&gt;--network&lt;/code&gt;选项可配置容器的网络模式，Docker
      
    
    </summary>
    
      <category term="tool" scheme="http://wudaijun.com/categories/tool/"/>
    
    
      <category term="docker" scheme="http://wudaijun.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>探讨服务端回合制战斗系统</title>
    <link href="http://wudaijun.com/2017/09/ngs-battle/"/>
    <id>http://wudaijun.com/2017/09/ngs-battle/</id>
    <published>2017-09-25T16:00:00.000Z</published>
    <updated>2018-04-08T10:22:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与大部分回合制游戏一样，需要服务器计算战斗，客户端以战报的方式回放。这里探讨一下服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。</p><h2 id="战斗流程"><a href="#战斗流程" class="headerlink" title="战斗流程"></a>战斗流程</h2><p>战斗地图是一个X*Y的矩阵，每个参与者(Fighter)初始位于其中一个格子上。战斗开始后，按照回合迭代，达到胜负条件或最大回合数则战斗结束。回合内，英雄按照出手顺序先后行动(Action)，英雄的Action包括移动，释放技能和普攻。</p><p>战斗流程是比较简明易懂的，整个战斗系统的难点在于多样的技能实现。每个英雄有N个技能，每个英雄可通过学习其它技能来实现不同的战斗效果，技能的效果和作用比较繁杂，例如：</p><ul><li>SkillA: 英雄每回合前3次伤害有50%机率使伤害翻倍(最多生效2次)</li><li>SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1，持续两回合</li><li>SkillC: 分裂箭，英雄普攻可对多个敌人造成伤害</li><li>…</li></ul><p>以下我们主要围绕灵活的技能系统为主要需求，讨论如何实现一个稳定，可扩展的战斗系统。</p><h2 id="Event系统"><a href="#Event系统" class="headerlink" title="Event系统"></a>Event系统</h2><p>Event事件管理是实现复杂技能效果的基石，通过Event可以将复杂，易变的技能效果和核心流程解耦。对回合制游戏，典型地Event有回合开始/结束，英雄移动/普攻/受击/死亡等，EventMgr管理这些Event和它们的Handler，主要提供如下接口:</p><pre><code>// Go Codetype EventArgs map[string]interface{}type EventHandler func(EventArgs)// 触发Event， 由战斗流程调用 如回合开始，英雄移动等FireEvent(EventType, EventId, EventArgs)// 监听Event， ListenerId通常为Buff的唯一ID AddEventListener(EventType, EventId, ListenerId, EventHandler)// 注销ListenerId监听的所有Event，通常在Buff结束时调用DelEventListener(ListenerId)</code></pre><p>EventMgr实际上是一个订阅者模式，战斗流程通过FireEvent发布事件，Buff订阅关心的事件并更新自己状态，在Buff结束时注销所有相关的事件监听。两者通过订阅者模式完成解耦，便于扩展。</p><h2 id="技能系统"><a href="#技能系统" class="headerlink" title="技能系统"></a>技能系统</h2><p>技能分为主动技能(概率触发)和被动技能(相当于战斗开始立即触发)。技能的效果分为瞬时性和持续性两种，前者即像普通一样立即造成伤害(其实普攻也可以看做技能的一种)，后者指技能效果包含状态性，有自己的生命周期和状态更新，如Dot伤害，无法移动，沉默等，这个状态通常叫做Buff，关于技能和Buff的区别我的理解是，技能是Buff的容器，是静态的，Buff是技能触发后的实现效果，是动态的。瞬时伤害的技能也可以通过Buff实现，只不过这个Buff生命周期很短，在造成伤害后就消失了。关于Buff的详细实现我们放到后面，我们先看技能系统本身。</p><p>考虑到技能以后的扩展性和可维护性，对其尽可能做抽象是有必要的，抽象出公共的流程，将可变量配置化，可以提升系统稳定性和扩展性，也方便后期做测试。技能本身包含几个阶段：技能触发(概率触发，战斗开始触发)，目标选取(敌军/友军，一个/多个)，技能作用(造成伤害，挂接Buff)，前两个是可抽离到配置的，通过通用的技能触发器和目标选取脚本得到技能所需要的信息传给技能作用模块，由于技能作用效果的多样性，目前我们没有对技能作用进行抽象，是通过脚本各个实现的。</p><h2 id="Buff系统"><a href="#Buff系统" class="headerlink" title="Buff系统"></a>Buff系统</h2><p>技能的各种复杂效果都通过BUFF实现，每个Buff都挂于战场某个参与者(Fighter)上，当Fighter阵亡，其上所有的Buff都会被移除(包括Event关联)。BUFF系统是由一个基于战场事件(Event)的回调系统驱动，整个战场在战斗流程中不断抛出各种Event(如回合开始/结束，Fighter普攻/受击/释放技能，伤害结算等)，BUFF注册这些Event并更新自己Owner(Fighter)的状态，来实现灵活强大的技能效果。</p><h3 id="1-Buff抽象"><a href="#1-Buff抽象" class="headerlink" title="1.Buff抽象"></a>1.Buff抽象</h3><ul><li>Start():Buff开始，即Buff启动脚本，负责初始化状态，注册BUFF的生命周期和相关Event等。</li><li>Update():Buff状态更新，实现Buff作用并更新Buff的状态，对于次数性BUFF(如前N次免伤)，可能调用N次Update，复杂的技能也可能有多个Update函数(关心不同的Event)</li><li>Finish():Buff的正常结束，当BUff结束条件满足(比如Update了N次，或者持续了N回合)调用</li><li>Cancel():Buff被冲突(中断)时的处理</li></ul><p>以上阐述的是Buff的行为抽象，而不是具体实现，在设计Buff时从这四个触法点思考，加上EventMgr注册回调机制，基本可以实现绝大部分各式的Buff效果。例如最开始提到的SkillA: 英雄每回合前3次伤害有50%机率使伤害翻倍(最多生效2次)，这是一个持续整场战斗的Buff(BuffA)，它注册两个Update Event:</p><ul><li><code>BEFORE_DAMAGE</code>(英雄攻击伤害结算前): Update1 中判断如果本回合已触发次数小于2并且满足触发条件(50%概率)，则更新自己的状态(计数器+1)，并产生<strong>伤害翻倍子Buff</strong>(后面讨论)。</li><li><code>ROUND_START</code>(每回合开始): Update2 中重置Buff状态(计数器)。</li></ul><p>目前我们所讨论的Buff都是独立的，有自己生命周期的个体，通过Event注册回调与战斗主流程解耦。但实际上Buff之间是有相互关联的，主要分为三种：Buff属性作用，Buff冲突免疫关系和Buff生命周期，下面分别介绍。</p><h3 id="2-Buff属性作用"><a href="#2-Buff属性作用" class="headerlink" title="2. Buff属性作用"></a>2. Buff属性作用</h3><p>仍然是我们前面的SkillA技能，我们现在来看如何实现伤害翻倍这个Buff，该Buff是SkillA对应的Buff生成的子Buff，它应该被设计为可公用的伤害增加Buff，这个Buff的作用是影响伤害结算流程，按照我们之前的事件注册回调思路，我们可以注册伤害结算这个Event，接收当前算出的伤害，然后*200%并返回新伤害值。如BuffA提升10%伤害，BuffB增加20点真实伤害，BuffC降低20%的伤害，那么最终得到伤害为: <code>(基础伤害*110%+20)*80%</code>，这种方案默认公式计算的顺序与Buff挂载顺序一致，，而正确的伤害值应该为<code>(基础伤害+20)*(1+10%-20%)</code>，如果要处理这种优先级关系，需要遍历所有注册伤害结算Event的Handler，按照类型排序，再依次处理，如果一旦有同类Buff添加或移除，又要重新计算。这样公式与事件管理做到了一起，是不稳定的。</p><p>BuffA,BuffB,BuffC之所以会有复杂的公式计算，一个原因在于它们作用于同一属性的不同维度，BuffA,BuffC作用于伤害值的比例增加这一维度，而BuffB作用于伤害值的绝对值增长这一维度，我们可以将它们分开，作为Fighter两个独虚拟属性ATTR_DAMAGE_ADD, ATTR_DAMAGE_MUL来维护，允许Buff对其修改，但此时的修改是只有加减关系的，避免了优先级的问题，在伤害结算时，通过公式计算: (基础伤害+ATTR_DMAGE_ADD)*ATTR_DAMAGE_MUL即可。</p><p>整个交互流程为: </p><ul><li>战斗流程抛出事件 -&gt; 事件系统 -&gt;Buff系统 -&gt; Fighter属性维度</li><li>战斗流程获取属性 -&gt; 属性系统 -&gt; 公式计算  -&gt; Fighter属性维度</li></ul><p>通过属性系统和事件系统，将战斗流程和Buff系统解耦，将组件职责降到最小，方便测试和扩展。</p><p>比如沉默，眩晕等效果，如果没有虚拟属性，沉默Buff会注册EVENT_BEFORE_SKILL(Fighter释放技能前)这个Event，并且返回false来告知战斗系统它当前不能释放技能。同样，眩晕Buff会注册Fighter EVENT_BEFORE_MOVE, EVENT_BEFORE_ATTACK, EVENT_BEFORE_SKILL三个Event来实现眩晕效果，一来整个战斗流程每次都要合并各类Event的各种返回值(并且EventHandler得不到统一的接口抽象)，效率低下，二来战斗流程不应该依赖外部EventHandler的实现，它只关心值本身(能否移动，能否施法等)，因此虚拟属性本身实际上起一个依赖倒置的作用。如果使用虚拟属性，那么沉默Buff会在ATTR_FORBIDEN_SKILL这个属性上+1，眩晕同理，这样战斗流程在Fighter尝试施放技能时，获取Fighter的ATTR_FORBIDEN_SKILL属性，如果&gt;0，则不能施法。</p><p>Buff通过属性来影响战斗流程，一方面解耦了战斗流程和Buff之间的依赖，另一方面也减轻了Buff与Buff之间的依赖，并且通过属性来固化战斗系统不易变的部分，可以减轻系统复杂度，易于调试。</p><h3 id="3-Buff作用链"><a href="#3-Buff作用链" class="headerlink" title="3. Buff作用链"></a>3. Buff作用链</h3><p>不是所有的Buff都可以通过属性来完成解耦，比如护盾效果，A Buff 加200护盾，B Buff 加300护盾，那么 Fighter 护盾属性为500，此时战斗伤害结算流程扣除400护盾值，那么这个值应该从 A 减还是 B 减，战斗流程并不知晓，需要护盾Buff自己来维护(并且在护盾为0时结束Buff)，并且护盾还有各种类型(物理护盾，魔法护盾等)。属性系统在这里并不适用，因此，我们需要一个Buff作用链来完成护盾的结算流程。比如受击400点魔法伤害，战斗系统抛出 EVENT_FLOW_SHIELD 事件，传入400以及伤害类型，A Buff 收到后判断伤害类型，减免200点伤害(并结束自身)，返回400-200=200，B Buff 伤害类型不满足，返回200，战斗流程得到返回值200，继续后续处理。</p><p>到这里，可能你会问：为什么不将沉默，眩晕这些效果也通过 Buff作用链来完成？实现上是可以的，每次 Fighter移动/攻击/释放技能前，抛出对应事件，检查其返回值，决定是否执行操移动/攻击等。但就我的设计理念而言，能够通过虚拟属性固化的效果尽量固化，对系统复杂度和效率都有好处。</p><p>Buff 作用链和 Buff 事件处理的机制是一样的，只不过前者关心返回值，后者不关心返回值。可公用EventMgr来处理，通过引用类型的EventArgs来更新和返回。</p><h3 id="4-Buff相互关系"><a href="#4-Buff相互关系" class="headerlink" title="4.Buff相互关系"></a>4.Buff相互关系</h3><p>-Buff 冲突:  即该BUFF生效时，已有的哪些Buff会失效，如一些清除负面状态的Buff<br>-Buff 免疫:     即该BUFF生效时，后面来的哪些BUFF不能生效，如BKB免疫眩晕<br>-Buff 叠加:  两种同类增益或减益BUFF同时生效时，按照某个规则进行BUFF效果重新计算生成</p><p>Buff的冲突免疫关系实际上是Buff作用效果的一部分，但是一个可抽象和配置化的流程，在挂载Buff时统一处理。至于Buff叠加，在Buff B的Start节点中，判断是否有指定Buff A存在，如果存在，修正BuffB的效果(或移除已有BuffA)，是个特例流程，做到Buff脚本里面就行了。</p><p>至此，我们通过属性维度和公式计算来避免了作用于同一个属性的Buff的顺序依赖，通过公用流程来处理Buff的免疫和冲突，仅针对Buff叠加这类少见的特殊作用进行特例化处理，这样最大程度的提升了Buff的扩展性，Buff可以独立实现，Buff的关系可通过配置表配置，新加一个Buff无需修改已有的Buff系统，对其它模块的影响也降到最小。</p><h3 id="5-Buff生命周期"><a href="#5-Buff生命周期" class="headerlink" title="5.Buff生命周期"></a>5.Buff生命周期</h3><p>为了达成复用，我们会通过子Buff的概念来实现一些复杂的Buff，SkillA的BuffA，它维护自己的状态，并在条件满足时，产生伤害翻倍这个子Buff，父子Buff的生命周期关系大致有三种:</p><ol><li>完全独立，创建完成之后即不再相互引用</li><li>父Buff结束时，子Buff随之结束</li><li>父Buff通过内部状态控制子Buff的生命周期</li></ol><p>对战斗系统来说，理想情况下，每个Buff应该自己管理自己的生命周期，这样状态内聚在Buff本身，更好地满足正交性和复用性。并且Buff的生命周期耦合容易引发状态错误，如子Buff由于Buff冲突被移除时，父Buff可能并不知晓，当父Buff结束子Buff时会再次触发Buff Finish或Cancel操作。</p><p>因此我们应该尽可能将父子Buff关系弱化(向第一种关系靠齐)，将Buff生命周期独立:</p><ul><li>将Buff的生命周期作为创建子Buff的参数传入，如一个持续两回合的属性Buff，则将”持续两回合”这个周期以事件类型(回合结束), 事件ID(0), 触发次数(2)传入</li><li>用子Buff监听”父Buff移除”事件的方式来将关系2转换为关系1</li><li>用唯一事件ID来完成父子Buff的特例的事件交互，将部分关系3转换为关系1</li></ul><p>由于更复杂的状态控制，比如Buff的结束机制可能不止一种，所以想要完全只保留关系1的父子Buff是比较难的。对于这类少数父子Buff，可考虑特例化实现这个子Buff，比如吸血Buff独立实现可能会比复用恢复Buff更好，如果以上方案都不能很好解决，最后再考虑将其生命周期完全交由父Buff控制(子Buff本身无Event状态)。</p><h2 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h2><p>属性系统针对Fighter的各种属性进行管理，属性系统包括K-V Map和公式计算两部分，前面我们讲到通过虚拟属性来完成Buff与战斗流程间的解耦，那么K-V Map的Key有如下几种:</p><ul><li>固定属性: 当前不受Buff影响的属性，无需公式计算直接获取即可。如Fighter当前血量，位置信息等</li><li>基础属性: 受Buff影响的属性的基础值，如Fighter进入战斗时的初始攻击力，防御力等，基础属性在战斗过程中不变</li><li>Buff属性: 基础属性的可变维度，由各类Buff修改，如攻击力增加值(绝对值)，防御力加成(百分比)</li><li>虚拟属性: 如禁足，沉默，伤害加成等，这些属性原本Fighter上面没有，属于战斗系统需要，也由Buff修改</li></ul><p>我将属性管理器K-V Map保存的”属性”称为属性维度，它们是Buff操作属性的最小粒度，每个属性维度都是纯加减运算，不受Buff先后顺序的影响。对最终属性的计算，由公式计算系统，比如: 最终攻击力 = (攻击力基础值+攻击力增加值)*(1+攻击力加成值)，战斗流程关心Fighter最终攻击力，Buff系统关心其影响的某个属性维度(如攻击力增加值或攻击力加成值)，中间的这一块就是公式计算，将公式计算抽象出来的好处是公式系统可独立变化，甚至可以将公式配置化。属性的计算过程对战斗流程来说是透明的，这给属性维度和公式计算的变更带来的很大的灵活度。</p><h2 id="配置框架"><a href="#配置框架" class="headerlink" title="配置框架"></a>配置框架</h2><p>评估一套配置框架好坏不能简单从可配置性这一点来看，一个完全可配置技能效果，做到通过配置即可添加一些简单技能的配置框架不是不能实现，但开发和维护成本过高，对策划的要求，出错的可能性也更高。因此在设计配置框架时，要结合项目需求，在开发效率，可维护性，可扩展性等方面作出权衡。</p><p>简单提一下我们目前用的配置方案:</p><p>技能基础表:</p><div class="table-container"><table><thead><tr><th>技能ID</th><th>技能类型</th><th>技能距离</th><th>技能目标选取器</th><th>目标数量</th><th>技能BuffIds</th><th>技能描述</th></tr></thead><tbody><tr><td>1</td><td>主动</td><td>同攻击距离</td><td>敌人</td><td>1</td><td>[1001]</td><td>对目标造成Args[0]的伤害，并眩晕Args[1]回合(Buff[0])</td></tr></tbody></table></div><p>技能成长表，即技能的Args表: </p><div class="table-container"><table><thead><tr><th>技能ID</th><th>技能等级</th><th>技能参数</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>[0.8,1]</td></tr><tr><td>1</td><td>2</td><td>[0.9,1]</td></tr></tbody></table></div><p>Buff表:</p><div class="table-container"><table><thead><tr><th>BuffId</th><th>描述</th><th>所属Tags</th><th>冲突Tags</th><th>免疫Tags</th><th>冲突自身</th><th>免疫自身</th></tr></thead><tbody><tr><td>1001</td><td>眩晕</td><td>[控制]</td><td>[]</td><td>[]</td><td>false</td><td>false</td></tr></tbody></table></div><p>技能根据技能类型，距离和目标选取器以及目标数量，通过通用目标选取流程得到目标，然后传入技能作用脚本，技能作用脚本由程序维护，通过技能描述使用技能参数(来自技能成长表)和技能BuffIds(传入Buff作用脚本)，由于多个Buff可能由同一个Buff脚本实现(如攻击力提高，防御力降低)，因此Buff脚本需要外部传入BuffId来获取冲突免疫关系，对程序来说，BuffId是透明的，它只代表一类冲突免疫关系，对策划来讲，Buff脚本是透明的，他只关心Buff相互关系(如A技能的攻击力提升与B技能的攻击力提升不能同时存在)，至于技能和技能参数以及BuffID的关联本身，是不常变的，因此直接硬编码映射。</p><p>Buff的配置方案有两种，一是通过BuffID来配置冲突免疫关系，这种方案灵活性高，但扩展性和维护性差。另一种方案是通过BuffTag，每个Buff可配置自己的Tag(如增益，减益，控制)，根据这些Tag来控制冲突免疫关系，免疫负面状态的Buff对应的配置中免疫Tag为[减益，控制]。这种方案与BuffId无关(免疫自身和冲突自身需单独配置)，维护性和扩展性更高。</p><h2 id="战报系统"><a href="#战报系统" class="headerlink" title="战报系统"></a>战报系统</h2><p>战斗跑在服务器，客户端需要通过战报进行战斗回放，那么战报就要包含整个战斗的详细过程，每回合那个英雄放了什么技能，攻击了谁，等等，客户端根据这些信息”拼凑”出战斗动画。战报的每一”桢”应该为一个最小粒度的事件，如A对B发起了普通攻击应该是: 1. A对B发起普攻，2. B损失了50HP，中间还可能穿插反击和其它Buff效果，客户端在”按桢表现”的时候，还需要一些关联，如B是因为A的普攻而掉血，因此实际上更好的格式为: B由于A的普攻损失了50HP，为了协议扩展性，我们会将这些事件格式统筹起来:</p><div class="table-container"><table><thead><tr><th>事件类型</th><th>FighterId</th><th>事件参数</th><th>解释</th></tr></thead><tbody><tr><td>回合开始</td><td>0</td><td>[1]</td><td>第一回合开始</td></tr><tr><td>发起普攻</td><td>1</td><td>[2]</td><td>Fighter1向Fighter2发起普攻</td></tr><tr><td>受到伤害</td><td>2</td><td>[1,0,50]</td><td>Fighter2由于Fighter1的普攻(BuffId0)损失了50HP</td></tr></tbody></table></div><p>每个事件都有自己的参数意义，这部分和客户端约定即可。这里的事件类型和之前提到的战斗系统的EventMgr很相似，很多触发点也一样，只是是针对各种Buff，一个是针对客户端表现。</p><p>至于事件参数的类型，最常见的可能有整型，浮点数，字符串，在protobuf协议里面可以直接通过复合结构定义:</p><pre><code>message Elem {    sint32  type = 1; // 1: intv 2: fltv 3: strv    sint32  intv = 2;    float   fltv = 3;    string  strv = 4;}</code></pre><p>这种方案很丑陋，但在protobuf3中，由于optional字段默认值不发送和sint32的变长编码，实际发送一个type=1,intv=20的Elem只会占用四个字节(两个字段的内容和编号各占 一个字节)，因此还是比较实用的。参考过<a href="https://developers.google.com/protocol-buffers/docs/proto3#oneof" target="_blank" rel="external">protobuf的oneof</a>，不是很好用，对repeat和map等复合结构的支持不好。</p><h2 id="技能效果扩展"><a href="#技能效果扩展" class="headerlink" title="技能效果扩展"></a>技能效果扩展</h2><h3 id="1-召唤物"><a href="#1-召唤物" class="headerlink" title="1. 召唤物"></a>1. 召唤物</h3><p>SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1持续两回合</p><p>该技能可用前面介绍的已有机制实现: 技能目标选取规则中，配置攻击范围内一个敌人，技能作用脚本中，获取到该目标周围九宫格所有的敌人，对它们施加持续两回合的属性子Buff(攻击距离-1，由子Buff自身管理生命周期)。</p><p>现在考虑SkillB的诅咒区域如果有状态和AI(如存在两回合，每回合跟随施法者移动)，则实现上更为复杂:</p><ul><li>监控所有敌人的移动，当其进入区域时，添加Buff，出去时，移除Buff</li><li>当自己移动时，根据前后状态更新敌人身上的Buff</li><li>两回合后，结束自身</li></ul><p>那如果是召唤一个宠物，并且宠物有血量，可移动，攻击和被攻击呢，是的，答案是以”Fighter”来实现召唤物，这里的Fighter是一个更广泛的概念，它只是一系列接口，如移动/攻击/属性变更等，这样所有能够通过Fighter实现的，技能都可以实现，也算是终极方案了。</p><h3 id="2-行为属性"><a href="#2-行为属性" class="headerlink" title="2. 行为属性"></a>2. 行为属性</h3><p>SkillC: 分裂箭，英雄普攻可对多个敌人造成伤害</p><p>这类技能的特性是会影响已有技能或其它行为，比如改变普攻流程，移动方式等，这种通常很难用属性系统去做，解决方案是将Fighter的行为(普攻/技能/移动等)抽离为可插拨模块(也可理解为行为属性)，初始每个英雄的行为属性被赋默认值，技能可以更改这些行为(如分裂箭可更换普攻行为)，实现更高级别的抽象，战斗流程根据行为类型和次序(如移动/技能/普攻)取出并执行这些行为，行为属性也是召唤物Fighter实现的基础。</p><h3 id="3-全局Buff"><a href="#3-全局Buff" class="headerlink" title="3. 全局Buff"></a>3. 全局Buff</h3><p>SkillD: 腐蚀一片区域，进入区域的敌人受到持续伤害，区域存在2回合，并且不会随施法者死亡消失</p><p>由于其简单，用Fighter实现过于重度，由于其独立的生命周期，不能以普通Buff的形式存在(会随Fighter死亡消失)，那么可以考虑用全局Buff，全局Buff挂在战场上，介于Fighter和普通Buff之间，适合实现一些简单，全局的效果，如天气效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，战斗系统的主要组件就已经介绍得差不多了，总结起来，核心思路是将相对稳定的核心战斗流程和相对动态的技能Buff扩展隔离开来，战斗流程通过事件系统来解耦外部Buff脚本，Buff通过属性系统(包括行为属性)来反馈到战斗流程。在构建的过程中，还要时刻关注到哪些是易变的，比如Buff 冲突免疫关系，伤害计算公式等，将其单独抽出来，封装成模块甚至抽离到配置，尽量将功能做到模块化，离线化，方便模块的扩展和测试。</p><p>将战斗流程”固化”下来，不要交给Buff系统去任意递归迭代，这种思路适用于回合制这类战斗流程相对固定的情形。另一种思路，是”去流程化”，将流程做到Buff中，比如将移动作为一个Buff，那么”禁足”的效果可以直接通过Buff免疫来实现: 如果Fighter已经有禁足Buff，则移动Buff不能挂上去，达成不能移动的效果。沉默和缴械效果也类似。这种思路更为灵活，但相对更复杂和难以调试。通常我们将通用/固定的行为作为流程，特例/易变的流程作为Buff。</p><p>在战斗系统设计中，很多方案都不是绝对的左或者是右，比如普攻是否应该当做特殊技能处理(这样能很方便实现特殊的普攻效果，如分裂箭)？哪些属于流程，哪些属于Buff？哪些效果以Buff实现，哪些效果以Fighter实现？哪些可抽到配置文件，哪些直接写在代码里等等，在实际决策中，往往都是根据实际情况(开发效率，GD需求，扩展性，维护性等)在中间选一个合适点，并且尽可能在细节上封装解耦，以便之后能根据变化进行调整。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与大部分回合制游戏一样，需要服务器计算战斗，客户端以战报的方式回放。这里探讨一下服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。&lt;/p&gt;
&lt;h2 id=&quot;战斗流程&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
      <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>用context库规范化Go的异步调用</title>
    <link href="http://wudaijun.com/2017/08/go-conetxt-usage/"/>
    <id>http://wudaijun.com/2017/08/go-conetxt-usage/</id>
    <published>2017-08-18T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见并发模型"><a href="#常见并发模型" class="headerlink" title="常见并发模型"></a>常见并发模型</h3><p>之前对比过<a href="http://wudaijun.com/2017/05/go-vs-erlang/">Go和Erlang的并发模型</a>，提到了Go的优势在于流控，下面列举几种常见的流控:</p><h4 id="Ping-Pong"><a href="#Ping-Pong" class="headerlink" title="Ping-Pong"></a>Ping-Pong</h4><p>这通常针对于两个goroutine之间进行简单的数据交互和协作，我们常用的RPC也属于此类，通过channel的类型可以灵活实现交互方式:</p><ul><li>同步单工: 单个双向非缓冲channel</li><li>同步双工: 多个单向非缓冲channel</li><li>异步双工: 多个单向缓冲channel</li></ul><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p>流水线如其词语，goroutine是”流水线工人”，channel则为”流水线”，衔接不同的goroutine的输入输出，每个goroutine有一个输入(inbound)channel和输出(outbound)channel:</p><pre><code>// 以下定义一个流水线工人 用于将inbound channel中数字求平方并放入outbound channelfunc sq(in &lt;-chan int) &lt;-chan int {    out := make(chan int)    go func() {        for n := range in {            out &lt;- n * n        }        close(out)    }()    return out}</code></pre><p>流水线goroutine有一些特质：它负责创建并关闭channel(在完成自己的工作后)，这样外部调用无需关心channel的创建和关闭，当channel被关闭，它的下游goroutine会读出零值的数据。我们还可以用链式调用来组装流水线：</p><pre><code>sq(sq(sq(ch)))</code></pre><p>在实际应用中，如DB读写，网络读写等外部阻塞操作通常都放到单独的流水线去做，下游主goroutine可以灵活处理IO结果(如通过select完成IO复用)。</p><h4 id="扇入扇出"><a href="#扇入扇出" class="headerlink" title="扇入扇出"></a>扇入扇出</h4><p>流水线工作通常是一对一的”工作对接”，通过select可以达成IO复用，比如GS同时处理网络消息，RPC调用，Timer消息等，这其实就是简单的扇入模型，扇出模型也比较常见，比如在对一些无状态的任务做分发时，可以让多个goroutine处理一个channel任务队列上的数据，最大程度地提升处理效率。</p><p>上面三个模式是应用最常用到的，因此不再举例具体说明，<a href="http://strucoder.com/2016/03/15/gozhong-de-bing-fa-ke-shi-hua/" target="_blank" rel="external">Go并发可视化</a>这篇文章很好地归纳和总结了这些模型，推荐一读。</p><h3 id="交互规范"><a href="#交互规范" class="headerlink" title="交互规范"></a>交互规范</h3><p>上面只所以提出这三种模型主要是为了导出接下来的问题，当用到多个goroutine时，如何协调它们的工作：</p><h4 id="如何正确关闭其它goroutine"><a href="#如何正确关闭其它goroutine" class="headerlink" title="如何正确关闭其它goroutine"></a>如何正确关闭其它goroutine</h4><p>这类问题的通常情形是：当某个goroutine遇到异常或错误，需要退出时，如何通知其它goroutine，或者当服务器需要停止时，如何正常终止整个并发结构，为了简化处理问题模型，以流水线模型为例，在正常情况下，它们会按照正常的流程结束并关闭channel(上游关闭channel，下游range停止迭代，如此反复)，但当某个下游的goroutine遇到错误需要退出，上游是不知道的，它会将channel写满阻塞，channel内存和函数栈内存将导致内存泄露，在常规处理方案中，我们会使用一个done channel来灵活地通知和协调其它goroutine，通过向done channel写入数据(需要知道要关闭多少个goroutine)或关闭channel(所有的读取者都会收到零值，range会停止迭代)。</p><h4 id="如何处理请求超时"><a href="#如何处理请求超时" class="headerlink" title="如何处理请求超时"></a>如何处理请求超时</h4><p>至于超时和请求放弃，通常我们可以通过select来实现单次请求的超时，比如 A -&gt; B -&gt; C 的Ping-Pong异步调用链，我们可以在A中select设置超时，然后在B调用C时也设置超时，这种机制存在如下问题:</p><ol><li>每次请求链中的单次调用都要启一个timer goroutine</li><li>调用链中的某个环节，并不知道上层设置的超时还有多少，比如B调用C时，如果发现A设置的超时剩余时间不足1ms，可以放弃调用C，直接返回</li><li>A-&gt;B的超时可能先于B-&gt;C的超时发生，从而导致其它问题</li></ol><h4 id="如何安全放弃异步请求"><a href="#如何安全放弃异步请求" class="headerlink" title="如何安全放弃异步请求"></a>如何安全放弃异步请求</h4><p>这个问题可以理解为如何提前结束某次异步调用，接上面提到的A-&gt;B-&gt;C调用链，如果A此时遇到了其它问题，需要提前结束整个调用链(如)，B是不知道的，A和B之间数据交互channel和done channel，没有针对某个请求的取消channel，尽管大部分时候不会遇到这种需求，但针对某个请求的协同机制是缺失的，还需要另行设计。</p><h4 id="如何保存异步调用上下文"><a href="#如何保存异步调用上下文" class="headerlink" title="如何保存异步调用上下文"></a>如何保存异步调用上下文</h4><p>异步调用通常会有上下文，这个上下文不只指调用参数，还包括回调处理参数(非处理结果)，请求相关上下文(如当前时间)等，这类数据从设计上可以通过包含在请求中，或者extern local value，或者每次请求的session mgr来解决，但并不通用，需要开发者自行维护。</p><h3 id="使用context"><a href="#使用context" class="headerlink" title="使用context"></a>使用context</h3><p>以上几个问题并不限于Go，而是异步交互会遇到的普遍问题，只是在Go应用和各类库会大量用到goroutine，所以这类问题比较突出。针对这些问题，Go的内部库(尤其是net,grpc等内部有流水线操作的库)作者开发了context(golang.org/x/net/context)包，用于简化单个请求在多个goroutie的请求域(request-scoped)数据，它提供了:</p><ol><li>请求的超时机制</li><li>请求的取消机制</li><li>请求的上下文存取接口</li><li>goroutine并发访问安全性</li></ol><p>context以组件的方式提供超时(WithTimeout/WithDeadline)，取消(WithCancel)和K-V(WithValue)存取功能，每次调用WithXXX都将基于当前的context(Background为根Context)继承一个Context,一旦父Context被取消，其子Context都会被取消，应用可通过&lt;-context.Done()和<br>context.Err()来判断当前context是否结束和结束的原因(超时/取消)。</p><p>比如针对我们前面的”sq流水线工人”，我们可以通过context让它知道当前流水线的状态，并及时终止:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">out</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</div><div class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</div><div class="line">        <span class="keyword">select</span>&#123;</div><div class="line">        <span class="keyword">case</span> &lt;-ctx.Done():<span class="comment">// 当前流水线被终止</span></div><div class="line">        <span class="built_in">close</span>(out)</div><div class="line">        <span class="keyword">return</span> ctx.Err() <span class="comment">// 终止原因: DeadlineExceeded or Canceled</span></div><div class="line">        <span class="keyword">case</span> out &lt;- n * n:</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">close</span>(out)</div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> out</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以将context在goroutine之间传递，并且针对当前调用通过WithXXX创建子context，设置新的超时，请求上下文等，一旦请求链被取消或超时，context的done channel会被关闭，当前context的所有<code>&lt;-ctx.Done()</code>操作都会返回，并且所有当前context的子context会以相同原因终止。</p><p>比如在A-&gt;B-&gt;C中，B基于A的context通过WithTimeout或WithValue创建子context，子Context的超时和上下文都可以独立于父context(但如果子context设置超时大于父context剩余时间，将不会创建timer)，通过context库内部的继承体系来完成对应用层调用链的记录，并执行链式的超时和取消。</p><p>关于context的进一步了解可参考<a href="https://segmentfault.com/a/1190000006744213" target="_blank" rel="external">Go语言并发模型：使用 context</a>，也可直接阅读源码，实现也比较简单，单文件不到300行代码，但本身的意义却是重大的，go的很多异步库(如net,grpc,etcd等)都用到了这个模块，context正在逐渐成为异步库的API规范，我们也可以从context这个库中得到一些启发，适当地用在自己的项目中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常见并发模型&quot;&gt;&lt;a href=&quot;#常见并发模型&quot; class=&quot;headerlink&quot; title=&quot;常见并发模型&quot;&gt;&lt;/a&gt;常见并发模型&lt;/h3&gt;&lt;p&gt;之前对比过&lt;a href=&quot;http://wudaijun.com/2017/05/go-vs-erlang
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go vs Erlang</title>
    <link href="http://wudaijun.com/2017/05/go-vs-erlang/"/>
    <id>http://wudaijun.com/2017/05/go-vs-erlang/</id>
    <published>2017-05-30T16:00:00.000Z</published>
    <updated>2017-10-31T03:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>源于从Erlang到Go的一些思维碰撞，就像当初从C++到Erlang一样，整理下来记于此。</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor模型，又叫参与者模型，其”一切皆参与者(actor)”的理念与面向对象编程的“一切皆是对象”类似，但是面向对象编程中对象的交互通常是顺序执行的(占用的是调用方的时间片，是否并发由调用方决定)，而Actor模型中actor的交互是并行执行的(不占用调用方的时间片，是否并发由自己决定)。</p><p>在Actor模型中，actor执行体是第一类对象，每个actor都有自己的ID(类比人的身份证)，可以被传递。actor的交互通过发送消息来完成，每个actor都有一个通信信箱(mailbox，本质上是FIFO消息队列)，用于保存已经收到但尚未被处理的消息。actorA要向actorB发消息，只需持有actorB ID，发送的消息将被立即Push到actorB的消息信箱尾部，然后返回。因此Actor的通信原语是异步的。</p><p>从actor自身来说，它的行为模式可简化为:</p><ul><li>发送消息给其它的actor</li><li>接收并处理消息，更新自己的状态</li><li>创建其它的actor</li></ul><p>一个好的Actor模型实现的设计目标:</p><ul><li>调度器: 实现actor的公平调度</li><li>容错性: 具备良好的容错性和完善错误处理机制</li><li>扩展性: 屏蔽actor通信细节，统一本地actor和远程actor的通信方式，进而提供分布式支持</li><li>热更新? (还没弄清楚热更新和Actor模型，函数式范式的关联性)</li></ul><p>在Actor模型上，Erlang已经耕耘三十余载，以上提到的各个方面都有非常出色的表现，其OTP整合了在Actor模型上的最佳实践，是Actor模型的标杆。</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p>顺序通信进程(Communicating sequential processes，CSP)和Actor模型一样，都由独立的，并发的执行实体(process)构成，执行实体间通过消息进行通信。但CSP模型并不关注实体本身，而关注发送消息使用的通道(channel)，在CSP中，channel是第一类对象，process只管向channel写入或读取消息，并不知道也不关心channel的另一端是谁在处理。channel和process是解耦的，可以单独创建和读写，一个process可以读写(订阅)个channel，同样一个channel也可被多个process读写(订阅)。</p><p>对每个process来说：</p><ul><li>从命名channel取出并处理消息</li><li>向命名channel写入消息</li><li>创建新的process</li></ul><p>Go语言并没有完全实现CSP理论(参见<a href="https://www.zhihu.com/question/26192499" target="_blank" rel="external">知乎讨论</a>)，只提取了CSP的process和channel的概念为并发提供理论支持。目前Go已经是CSP的代表性语言。</p><h3 id="CSP-vs-Actor"><a href="#CSP-vs-Actor" class="headerlink" title="CSP vs Actor"></a>CSP vs Actor</h3><ul><li>相同的宗旨：”不要通过共享内存来通信，而应该通过通信来共享内存”</li><li>两者都有独立的，并发执行的通信实体</li><li>Actor第一类对象为执行实体(actor)，CSP第一类对象为通信介质(channel)</li><li>Actor中实体和通信介质是紧耦合的，一个Actor持有一个Mailbox，而CSP中process和channel是解耦的，没有从属关系。从这一层来说，CSP更加灵活</li><li>Actor模型中actor是主体，mailbox是匿名的，CSP模型中channel是主体，process是匿名的。从这一层来说，由于Actor不关心通信介质，底层通信对应用层是透明的。因此在分布式和容错方面更有优势</li></ul><h3 id="Go-vs-Erlang"><a href="#Go-vs-Erlang" class="headerlink" title="Go vs Erlang"></a>Go vs Erlang</h3><ul><li>以上 CSP vs Actor</li><li>均实现了语言级的coroutine，在阻塞时能自动让出调度资源，在可执行时重新接受调度</li><li>go的channel是有容量限制的，因此只能一定程度地异步(本质上仍然是同步的)，erlang的mailbox是无限制的(也带来了消息队列膨胀的风险)，并且erlang并不保证消息是否能到达和被正确处理(但保证消息顺序)，是纯粹的异步语义，actor之间做到完全解耦，奠定其在分布式和容错方面的基础</li><li>erlang/otp在actor上扩展了分布式(支持异质节点)，热更和高容错，go在这些方面还有一段路要走(受限于channel，想要在语言级别支持分布式是比较困难的)</li><li>go在消息流控上要做得更好，因为channel的两个特性: 有容量限制并独立于goroutine存在。前者可以控制消息流量并反馈消息处理进度，后者让goroutine本身有更高的处理灵活性。典型的应用场景是扇入扇出，Boss-Worker等。相比go，erlang进程总是被动低处理消息，如果要做流控，需要自己做消息进度反馈和队列控制，灵活性要差很多。另外一个例子就是erlang的receive操作需要遍历消息队列(<a href="http://www.jianshu.com/p/41f2e943c795" target="_blank" rel="external">参考</a>)，而如果用go做同步调用，通过单独的channel来做则更优雅高效</li></ul><h3 id="Actor-in-Go"><a href="#Actor-in-Go" class="headerlink" title="Actor in Go"></a>Actor in Go</h3><p>在用Go写GS框架时，不自觉地会将goroutine封装为actor来使用:</p><ul><li>GS的执行实体(如玩家，公会)的逻辑具备强状态和功能聚合性，不易拆分，因此通常是一个实体一个goroutine</li><li>实体接收的逻辑消息具备弱优先级，高顺序性的特点，因此通常实体只会暴露一个Channel与其它实体交互(结合go的interface{}很容易统一channel类型)，这个channel称为RPC channel，它就像这个goroutine的ID，几乎所有逻辑goroutine之间通过它进行交互</li><li>除此之外，实体还有一些特殊的channel，如定时器，外部命令等。实体goroutine对这些channel执行select操作，读出消息进行处理</li><li>加上goroutine的状态数据之后，此时的goroutine的行为与actor相似：接收消息(多个消息源)，处理消息，更新状态数据，向其它goroutine发送消息(通过RPC channel)</li></ul><p>到目前为止，goroutine和channel解耦的优势并未体现出来，我认为主要的原因仍然是GS执行实体的强状态性和对异步交互流程的顺序性导致的。</p><p>在研究这个问题的过程中，发现已经有人已经用go实现了Actor模型: <a href="https://github.com/AsynkronIT/protoactor-go。" target="_blank" rel="external">https://github.com/AsynkronIT/protoactor-go。</a> 支持分布式，甚至supervisor，整体思想和用法和erlang非常像，真是有种他山逢知音的感觉。:)</p><p>参考：</p><ol><li><a href="http://jolestar.com/parallel-programming-model-thread-goroutine-actor/" target="_blank" rel="external">http://jolestar.com/parallel-programming-model-thread-goroutine-actor/</a></li><li><a href="https://www.zhihu.com/question/26192499" target="_blank" rel="external">https://www.zhihu.com/question/26192499</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源于从Erlang到Go的一些思维碰撞，就像当初从C++到Erlang一样，整理下来记于此。&lt;/p&gt;
&lt;h3 id=&quot;Actor&quot;&gt;&lt;a href=&quot;#Actor&quot; class=&quot;headerlink&quot; title=&quot;Actor&quot;&gt;&lt;/a&gt;Actor&lt;/h3&gt;&lt;p&gt;Acto
      
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Erlang+Lua的一次重构</title>
    <link href="http://wudaijun.com/2017/03/erlang-lua-reconstruction/"/>
    <id>http://wudaijun.com/2017/03/erlang-lua-reconstruction/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-30T03:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前所在的项目基于<a href="http://wudaijun.com/2015/08/erlang-server-design1-cluster-server/">erlang cluster</a>搭建框架，再接入lua用于写逻辑。由于之前有一些erlang+lua的开发经验，因此着手项目的重构和优化，过程中一些体会，记录于此。</p><p>先简述一下项目架构，erlang做集群，网络层，节点交互，DB交互等，lua层只写逻辑。一个erlang的Actor持有一个luastate，为了加速erlang和lua之间的交互效率：</p><ol><li>将逻辑数据置于lua中而不是erlang中，在落地时，以二进制格式丢给erlang进行DB操作</li><li>以<code>lual_ref</code>和msgid等方式，尽量用整数代理字符串</li><li>erlang和lua异步运行，lua跑在原生线程池中，这在<a href="http://wudaijun.com/2015/09/erlang-server-design2-erlang-lua-battle/">这篇博文</a>中介绍过</li></ol><p>除了这些，还需要注意lua的沙盒环境管理，错误处理，热更新等，这里不再详述。就目前这种结构而言，还有一些缺陷：</p><ol><li>原子线程池忙碌可能导致的erlang虚拟机假死，需要保证原生线程池最多占用的核数不超过erlang虚拟机能使用的核数</li><li>lua state本身带来的不稳定性，特别是内存，在Actor过多时将会非常明显</li></ol><p>第二点，也是目前我们遇到的最棘手的问题，我们知道，在lua中，模块，函数，均是一个闭包，闭包包含函数和外部环境(UpValue，ENV等)，因此在lua中，每个lua state都完整包含加载的所有模块和函数，并且很难共享。我们项目通过一个share lua state完成了对配置表这类静态数据的共享(跨系统进程级的共享可参考<a href="http://blog.codingnow.com/2012/07/dev_note_24.html" target="_blank" rel="external">云风blog</a>)，但本身逻辑代码占用内存仍然很大，随着逻辑和功能模块的增加，基本一个lua state加载完模块什么也不做，会占用6-7M内存。意味着如果一个玩家一个lua state，那么一台16G内存的服务器，基本只能容纳2000个玩家，内存吃紧，而CPU过剩。因此本次重构也只要针对这个问题。</p><p>之前项目组曾针对玩家进行了优化，将主城位于一个岛的玩家归位一组，再将岛按照<code>%M</code>的方式放到M个lua state容器上，这样得到一个复杂的，三层逻辑的lua state。针对玩家这一块的内存占用确实大大减少了，但调试难度也提升了，并且扩展性不好，不能将这种容器扩展到其它service(如Union)上。</p><p>按照系统本身的理想设计，一个service(player, union)对应一个lua state，由一个erlang process代理这个lua state，并且通过cluster注册/共享这个service的状态信息。但由于lua state的内存占用，不能再奢侈地将service和lua state 1:1调配，多service在逻辑代码中共用一个lua state已经无可避免，我们可以简单将整个系统分为几个层级，</p><div class="table-container"><table><thead><tr><th>service</th><th>lua state</th><th>erlang process</th><th>cluster</th></tr></thead><tbody><tr><td>N</td><td>1</td><td>?</td><td>?</td></tr></tbody></table></div><p>因此有以下几种可能的方案：</p><ol><li><code>N 1 N N</code>：每个service对应一个erlang process，多个erlang process将代理同一个lua state，这就需要lua state可以”被并发”，也就是同一个lua state只能绑定一个原生线程池上执行，这一点是可以实现的。这种方案在erlang层会获得更好的并发性能，并且cluster层语义不变。</li><li><code>N 1 1 N</code>：一个erlang process作为container的概念代理一个lua state，容纳N个service，并且将service和erlang process的映射关系写入cluster，cluster层对外提供的语义不变，但service的actor属性被弱化，service的一致性状态是个问题。</li><li><code>N 1 1 1</code>：与上种方案类似，只不过将service到container的映射通过算法算出来，而不写入cluster，container本身被编号（编号时，可考虑将serverid编入，这样开新服有一定的扩展性，PS: <a href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">一致性哈希</a>方案不适用于游戏这类强状态逻辑），某个service将始终分配在指定container上。这种方案减少了cluster负担，并且减少了service不一致性的BUG。但由于container有状态，在每次系统启动后，service和container的映射关系就确定了，因此整个集群的可伸缩性降低了。</li></ol><p>经过几番讨论，我们最终选择了第三个方案，虽然个人认为这类固定分配的方案，与分布式的理念是相悖的，但目前稳定性和一致性才是首要目标。由于采用计算而不是通过mnesia保存映射关系，mnesia的性能和系统一致性得到了提升。本次重构在某些方面与我上一个项目<a href="http://wudaijun.com/2016/01/erlang-server-design5-server-node/">针对cluster的优化</a>有点相似，一个对系统服务进行横向切割，另一个则纵向切割，前者的初衷是为了更好地交互效率，后者则是处于对lua state资源的复用，两者都降低了系统的可伸缩性，得到了”一个更大粒度”的service。</p><p>整个重构过程中，有几点感触：</p><p>erlang和lua结合本身不是一种好的解决方案，或者说，erlang接入其它语言写逻辑都不合适，异质化的系统会打乱erlang本身的调度(不管通过nif还是线程池)，并且给整个系统带来不稳定性(CPU，内存)。另外，接入其它语言可能破坏erlang的原子语义和并发性。拿lua来说，原生线程池会和erlang调度线程抢占CPU并且很难管控，加之lua有自己的GC，因此在内存和CPU这两块关键资源上，erlang失去了控制权，给系统带来不稳定性。再加之lua state的内存占用以及lua state不支持并发，你可能要花更多的时间来调整系统结构，最终得到一个相对稳定的系统。如果处理得不好，用erlang做底层的可靠性和并发性将荡然无存。</p><p>系统设计，是一个不断根据当前情况取舍的过程，想要一步到位是不可能的。简单，可控，开发效率高才是主要指标，才能最大程度地适应各种变化，快速响应需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前所在的项目基于&lt;a href=&quot;http://wudaijun.com/2015/08/erlang-server-design1-cluster-server/&quot;&gt;erlang cluster&lt;/a&gt;搭建框架，再接入lua用于写逻辑。由于之前有一些erlang+lua
      
    
    </summary>
    
      <category term="erlang" scheme="http://wudaijun.com/categories/erlang/"/>
    
    
      <category term="lua" scheme="http://wudaijun.com/tags/lua/"/>
    
      <category term="erlang" scheme="http://wudaijun.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Lua 闭包 环境 包管理</title>
    <link href="http://wudaijun.com/2017/02/lua-notes/"/>
    <id>http://wudaijun.com/2017/02/lua-notes/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2017-10-31T06:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><ul><li>访问一个不存在的全局变量得到nil</li><li>释放一个全局变量只需将其赋值为nil，效果与未定义该变量一样</li><li>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量</li><li>局部变量比全局变量访问更快</li></ul><a id="more"></a><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1. 基本特性"></a>1. 基本特性</h3><ol><li>多参数/返回值匹配：多余忽略，缺少用nil补足</li><li>可变参数：arg，table.pack，table.unpack</li><li>命名参数：参数的非顺序填充方式</li><li>正确处理尾调用：Lua能够高效正确处理尾调用，而不会导致栈溢出</li></ol><h3 id="2-第一类函数"><a href="#2-第一类函数" class="headerlink" title="2. 第一类函数"></a>2. 第一类函数</h3><p>函数是第一类值，函数可以像其它值（string, number）样用于赋给变量，作为函数参数或返回值。函数定义实际上是一个赋值语句，将类型为function的变量赋给一个变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo.bar</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></div><div class="line"><span class="comment">-- 等价于</span></div><div class="line">foo.bar = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></div></pre></td></tr></table></figure><p>从这个角度来看，自然，与变量一样，Lua有全局函数和局部函数之分。</p><h3 id="3-词法闭包"><a href="#3-词法闭包" class="headerlink" title="3. 词法闭包"></a>3. 词法闭包</h3><p>词法闭包是指当在一个函数内部嵌套定义另一个函数时，内部函数体可以访问到外部函数的局部变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCounter</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> i = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>     <span class="comment">-- anonymous function</span></div><div class="line">        i = i + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> i</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line">c1 = newCounter()</div><div class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 1</span></div><div class="line"><span class="built_in">print</span>(c1())  <span class="comment">--&gt; 2</span></div><div class="line">c2 = newCounter()</div><div class="line"><span class="built_in">print</span>(c2())  <span class="comment">--&gt; 1</span></div><div class="line"></div><div class="line"><span class="comment">-- 打印c1所有的upvalue 输出: i</span></div><div class="line"><span class="keyword">local</span> i=<span class="number">1</span></div><div class="line"><span class="keyword">local</span> up = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(c1, i)</div><div class="line"><span class="keyword">while</span>(up ~= <span class="literal">nil</span>) <span class="keyword">do</span></div><div class="line">    <span class="built_in">print</span>(up, <span class="string">"  "</span>)</div><div class="line">    i = i+<span class="number">1</span></div><div class="line">    up = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(c1, i)</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="built_in">print</span>(c1, c2) <span class="comment">-- function: 0x7f8df1d02100        function: 0x7f8df1d02160</span></div></pre></td></tr></table></figure><p>这种情况下，我们称i为匿名函数的外部局部变量(external local variable)或upvalue。在这里，newCounter函数返回了一个闭包(closure)。闭包是指一个函数和它的upvalues，闭包机制保证了即使upvalue已经超出了其作用域(newCounter返回)，仍然能正确被闭包函数引用而不会释放(由Lua GC管理)。在上例中，我们说c1和c2是建立在同一个函数上，但作用于同一个局部变量(i)不同实例的两个不同的闭包。</p><p>通过打印的upvalues可以看到，只有被闭包函数引用的外部局部变量，才算作该闭包函数的upvalue，Lua会按照闭包函数引用的顺序为upvalue编号，该编号与upvalue定义顺序无关。</p><p>最后一点是，闭包函数都是动态生成的，这和<a href="http://wudaijun.com/2016/09/go-basic/">Go中的闭包</a>有所不同，Go的闭包函数是在编译时生成的，不同的闭包可以共享闭包函数(同一个函数地址)。Lua的闭包函数动态生成会一定程度地影响运行效率和内存占用。</p><p>Lua闭包除了用于高级函数，回调函数，迭代器等上下文环境中以外，在完全不同的上下文环境，可用于重定义或预定义函数，通过这种方法，可以为代码创建一个安全的执行环境(也叫沙箱，sandbox)。</p><p>Lua还提供了对C闭包的支持，每当你在Lua中创建一个新的C函数，你可以将这个函数与任意多个upvalues联系起来，每一个upvalue 可以持有一个单独的Lua值。当函数被调用的时候，可以通过假索引(<code>lua_upvalueindex</code>)自由的访问任何一个upvalues。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(lua_State *L)</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> val = lua_tonumber(L, lua_upvalueindex(<span class="number">1</span>));</div><div class="line">    lua_pushnumber(L, ++val);   <span class="comment">/* new value */</span></div><div class="line">    lua_pushvalue(L, <span class="number">-1</span>);       <span class="comment">/* duplicate it */</span></div><div class="line">    lua_replace(L, lua_upvalueindex(<span class="number">1</span>));  <span class="comment">/* update upvalue */</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* return new value */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">newCounter</span> <span class="params">(lua_State *L)</span> </span>&#123;</div><div class="line">    lua_pushnumber(L, <span class="number">0</span>);</div><div class="line">    lua_pushcclosure(L, &amp;counter, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C闭包与Lua闭包在概念上很相似，但有两点不同：</p><ol><li>C函数的upvalues是显示push到栈中的，而Lua则可通过闭包函数引用确定哪些是upvalues</li><li>C闭包不能共享upvalues，每个闭包在栈中都有独立的变量集，但你可以通过将upvalues指向同一个table来实现共享</li></ol><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Chunk是一系列语句，Lua执行的每一块语句，比如一个文件或者交互模式下的每一行都是一个Chunk。</p><p>当我们执行loadfile(“test.lua”)时，便将test.lua的内容编译后的Chunk作为一个函数返回，如果出现编译错误，则返回nil和错误信息。而dofile相当于:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofile</span> <span class="params">(filename)</span></span></div><div class="line">    <span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(filename))</div><div class="line">    <span class="keyword">return</span> f()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>loadstring和dostring的关系类似，只是接收字符串而不是文件名为参数。</p><p>再看require，require和dofile完成同样的功能，但主要有几点不同：</p><ol><li>require会搜索Lua环境目录来加载文件</li><li>require会判断文件是否已经加载而避免重复加载统一文件</li><li>require可以用于加载C .so库，功能类似loadlib，参考<a href="http://wudaijun.com/2014/12/lua-C/">这里</a></li></ol><p>一个lua模块编译后的Chunk被作为匿名函数被执行，那么定义于模块中函数对模块局部变量的引用就形成了闭包，所以说Lua中的闭包真是无处不在。</p><h2 id="Enviroment"><a href="#Enviroment" class="headerlink" title="Enviroment"></a>Enviroment</h2><p>Lua中的环境用table来表示，这简化了环境处理也带来了不少灵活性。</p><p>在Lua5.1及之前，Lua将环境本身存储在一个全局变量_G中，其中包含了全局变量，内置函数，内置模块等。我们在使用任何符号x时，如果在当前函数的局部变量和upvalues无法找到符号定义(PS: Lua查找变量定义的规则为：局部变量 -&gt; 外部局部变量(upvalue) -&gt; 全局变量)，则会返回_G.x的值。由于_G是一个table，因此我们可以用它实现一些有意思的功能：</p><ol><li>通过动态名字访问全局变量： <code>_G[varname]</code></li><li>通过_G的metatable改变对未定义全局变量的读(<code>__index</code>)和写(<code>__newindex</code>)行为</li><li>通过setfenv改变指定函数的_G环境，制造函数执行的沙盒环境</li></ol><p>现在再回头来看闭包，实际上，Lua闭包除了函数和upvalues，还包括函数环境，这三者组成了一个完整的执行沙盒。</p><p>在Lua5.2及之后，Lua取消了setfenv函数，用_ENV方案替代了_G方案：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- before Lua 5.1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">  <span class="built_in">setfenv</span>(<span class="number">1</span>, &#123;&#125;)</div><div class="line">  <span class="comment">-- code here</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">-- after Lua 5.2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">local</span> <span class="built_in">_ENV</span> = &#123;&#125;</div><div class="line">  <span class="comment">-- code here</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="keyword">or</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> <span class="built_in">_ENV</span> = &#123;&#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>_ENV有三个特性：</p><ol><li>对全局变量x的引用，将转换为_ENV.x</li><li>每个编译后的Chunk，都有一个_ENV upvalue(哪怕并未使用)，作为Chunk环境，并作用于其内定义的函数</li><li>在初始化时，_ENV=_G</li></ol><p>除了以上三点外，_ENV和普通变量并无区别。因此我们可以直接通过<code>local _ENV = {}</code>来覆盖接下来的代码的环境。将环境(_ENV)作为一个普通的upvalue来处理，这样做的好处是简化了闭包的概念，闭包等于函数加upvalues(没有了全局变量_G)，为闭包优化(如合并相同upvalues的闭包)提供更好的支持，同时也减少了<code>setfenv(f, env)</code>带来的不确定性和不安全性(函数的_ENV upvalue在闭包返回时就已经确定了)。</p><p>有_ENV还是一个table，因此对全局变量的访问控制等trick，仍然很容易实现。Lua目前仍然保留_G，但理解它们的别是比较重要的：</p><p>我们都知道Lua有一个全局注册表(Registry)，其中包含整个Lua虚拟机的信息，在Registry的<code>LUA_RIDX_GLOBALS</code>索引中，保存了Globals(也就是_G)，在创建Globals时，会生成<code>_G._G=_G</code>的自引用。在引入_ENV后，初始时，<code>_ENV=_G</code>，一旦编译器将_ENV放入Chunk的upvalue后，_ENV将作为普通upvalue被看待，因此我们可以对其重新赋值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">1</span> <span class="comment">-- 此时 _ENV.i == _G.i == 1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">local</span> <span class="built_in">_ENV</span>=&#123;i=<span class="number">2</span>, <span class="built_in">print</span>=<span class="built_in">print</span>, <span class="built_in">_G</span>=<span class="built_in">_G</span>&#125;</div><div class="line">    <span class="built_in">print</span>(i, <span class="built_in">_ENV</span>.i, <span class="built_in">_G</span>.i)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">()</span></span></div><div class="line">    <span class="built_in">print</span>(i, <span class="built_in">_ENV</span>.i, <span class="built_in">_G</span>.i)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">f() <span class="comment">-- 2 2 1</span></div><div class="line">g() <span class="comment">-- 1 1 1</span></div></pre></td></tr></table></figure><p>因此，_ENV除了在创建时和_G都指向Registry[LUA_RIDX_GLOBALS]之外，和_G并没有直接联系(<code>_G={}</code>不会影响函数环境，<code>_G.x=1</code>仍然会影响注册表中的Globals)，Lua5.2及之后的环境都由_ENV指定，_G出于历史原因保留，但实际上Lua并不在内部再使用：</p><blockquote><p>Lua keeps a distinguished environment called the global environment. This value is kept at a special index in the C registry (see §4.5). In Lua, the global variable _G is initialized with this same value. (_G is never used internally.)</p></blockquote><ul><li>参考<a href="http://lua-users.org/lists/lua-l/2014-08/msg00345.html" target="_blank" rel="external">_ENV vs _G</a>，<a href="http://stackoverflow.com/questions/14290527/recreating-setfenv-in-lua-5-2" target="_blank" rel="external">setfenv in Lua5.2</a></li></ul><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>在Lua中，有闭包，灵活的table和环境管理，想要实现包管理有非常多的方法：</p><h3 id="1-基本方法"><a href="#1-基本方法" class="headerlink" title="1. 基本方法"></a>1. 基本方法</h3><p>最简单的方法就是直接使用table和第一类函数特性：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">complex = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex.new</span><span class="params">(r,i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex.add</span><span class="params">(c1,c2)</span></span> ... <span class="keyword">end</span></div><div class="line">...</div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure><p>执行这个Chunk后，便可以通过<code>complex.xxx()</code>使用complex中定义的API了。这种方案主要的缺点是包内包外的调用都必须加上前缀，并且不能很好地隐藏私有成员。</p><h3 id="2-局部函数"><a href="#2-局部函数" class="headerlink" title="2. 局部函数"></a>2. 局部函数</h3><p>通过局部函数再导出的方式，我们可以解决包内调用前缀和隐藏私有成员(不导出即可)的问题。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c1,c2)</span></span> ... <span class="keyword">end</span></div><div class="line">...</div><div class="line">complex = &#123;new = new, add = add&#125;</div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure></p><p>但这样容易忘了local，造成全局命名空间污染。</p><h3 id="3-独立环境"><a href="#3-独立环境" class="headerlink" title="3. 独立环境"></a>3. 独立环境</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">complex = &#123;&#125;</div><div class="line"><span class="comment">-- before Lua5.1: setfenv(1, complex)</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">_ENV</span> = complex</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(r,  i)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span><span class="params">(c1, c2)</span></span> ... <span class="keyword">end</span></div><div class="line"><span class="keyword">return</span> complex</div></pre></td></tr></table></figure><p>现在，包内所有全局符号new, add都会被转换为complex.new, complex.add，并且我们为包创建了一个独立沙盒环境，如果要在包内访问全局符号，也有多种方法:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 方案1: 保存老的全局环境 之后访问全局符号需要加上 _G.前缀</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">_G</span> = <span class="built_in">_G</span></div><div class="line"><span class="comment">-- 方案2: 通过metatable 效率低一些，并且外部可通过complex.print访问_G.print</span></div><div class="line"><span class="built_in">setmetatable</span>(complex, &#123;<span class="built_in">__index</span> = <span class="built_in">_G</span>&#125;)</div><div class="line"><span class="comment">-- 方案3: 只导出要使用的函数 这种方法隔离型更好，并且更快</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">sqrt</span> = <span class="built_in">math</span>.<span class="built_in">sqrt</span></div><div class="line"><span class="keyword">local</span> <span class="built_in">print</span> = <span class="built_in">print</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Variables&quot;&gt;&lt;a href=&quot;#Variables&quot; class=&quot;headerlink&quot; title=&quot;Variables&quot;&gt;&lt;/a&gt;Variables&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;访问一个不存在的全局变量得到nil&lt;/li&gt;
&lt;li&gt;释放一个全局变量只需将其赋值为nil，效果与未定义该变量一样&lt;/li&gt;
&lt;li&gt;Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量&lt;/li&gt;
&lt;li&gt;局部变量比全局变量访问更快&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="lua" scheme="http://wudaijun.com/categories/lua/"/>
    
    
      <category term="lua" scheme="http://wudaijun.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X下的资源限制</title>
    <link href="http://wudaijun.com/2017/02/max-osx-ulimit/"/>
    <id>http://wudaijun.com/2017/02/max-osx-ulimit/</id>
    <published>2017-02-06T16:00:00.000Z</published>
    <updated>2017-02-08T04:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>系统的资源是有限的(如CPU，内存，内核所能打开的最大文件数等)，资源限制对针对进程能使用的系统资源设定上限。防止恶意进程无限制地占用系统资源。</p><p>资源限制分为两种，硬限制(Hard Limit)和软限制(Soft Limit)，软限制作用于实际进程并且可以修改，但不能超过硬限制，硬限制只有Root权限才能修改。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>在Mac OS X下，有如下三个命令与系统资源有关。</p><h3 id="launchctl"><a href="#launchctl" class="headerlink" title="launchctl"></a>launchctl</h3><p>launchctl管理OS X的启动脚本，控制启动计算机时需要开启的服务(通过后台进程launchd)。也可以设置定时执行特定任务的脚本，类似Linux cron。</p><p>例如，开机时自动启动Apache服务器：</p><pre><code>$ sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist</code></pre><p>关于launchctl的plist格式和用法参考:</p><ol><li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/launchctl.1.html" target="_blank" rel="external">launchctl man page</a></li><li><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html" target="_blank" rel="external">launchd plist man page</a></li><li><a href="http://paul.annesley.cc/2012/09/mac-os-x-launchd-is-cool/" target="_blank" rel="external">mac-os-x-launchd-is-cool</a></li><li><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="external">creating launchd jobs</a></li></ol><p>简单来说，plist文件用类似XML格式定义了一个命令(及启动参数)和该命令的执行方式(定时执行，系统启动执行，用户登录执行等)。我们这里不着重讨论，我们关心launchctl中如何查看/更改系统资源限制。</p><pre><code># Usage: launchctl limit [&lt;limit-name&gt; [&lt;both-limits&gt; | &lt;soft-limit&gt; &lt;hard-limit&gt;]# 查看文件描述符限制launchctl limit maxfilesmaxfiles    256            unlimited # 修改软限制为512 系统重启失效sudo launchctl limit maxfiles 512 unlimited# 可将launchctl子命令写入/etc/launchd.conf中# 在launchd启动时 会执行该文件中的命令limit maxfiles 512 unlimited</code></pre><p>通过将更改命令写入plist文件，并在启动时执行，也可永久更改资源限制：</p><ol><li><p>新建Library/LaunchDaemons/limit.maxfiles.plist文件，写入</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;   &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;           &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt;     &lt;dict&gt;     &lt;key&gt;Label&lt;/key&gt;     &lt;string&gt;limit.maxfiles&lt;/string&gt;     &lt;key&gt;ProgramArguments&lt;/key&gt;     &lt;array&gt;       &lt;string&gt;launchctl&lt;/string&gt;       &lt;string&gt;limit&lt;/string&gt;       &lt;string&gt;maxfiles&lt;/string&gt;       &lt;string&gt;64000&lt;/string&gt;       &lt;string&gt;524288&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;RunAtLoad&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;ServiceIPC&lt;/key&gt;     &lt;false/&gt;   &lt;/dict&gt; &lt;/plist&gt;</code></pre></li><li><p>修改文件权限</p><pre><code> sudo chown root:wheel /Library/LaunchDaemons/limit.maxfiles.plist sudo chmod 644 /Library/LaunchDaemons/limit.maxfiles.plist</code></pre></li><li><p>加载plist文件(或重启系统后生效 launchd在启动时会自动加载该目录的plist)</p><pre><code> sudo launchctl load -w /Library/LaunchDaemons/limit.maxfiles.plist</code></pre></li><li><p>确认更改后的限制</p><pre><code> launchctl limit maxfiles</code></pre></li></ol><h3 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h3><p>大多数类Unix系统都通过(Linux/*BSD/OS X)都提供该命令来更改资源限制和内核配置：</p><pre><code># 查看当前内核和进程能打开的文件描述符限制$ sysctl -A | grep kern.maxfileskern.maxfiles: 12288             # 系统级的限制kern.maxfilesperproc: 10240    # 内核级的限制# 通过sysctl命令热更改 系统重启后失效$ sysctl -w kern.maxfilesperproc=20480# 通过配置文件永久更改 重启生效# 在/etc/sysctl.conf中写入kern.maxfiles=20480 kern.maxfilesperproc=24576</code></pre><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>ulimit是shell的内置命令，用于查看/更改当前shell及其创建的子进程的资源限制。使用比较简单：</p><pre><code># 查看当前shell(及其子进程)的所有限制ulimit -a# 改变进程能打开的最大文件描述符数软限制 当shell关闭后失效# 将其写入对应shell的startup文件(如~/.bashrc, ~/.zshrc)，可保留更改ulimit -S -n 1024</code></pre><h2 id="区别联系"><a href="#区别联系" class="headerlink" title="区别联系"></a>区别联系</h2><p>这三个命令的关系在Mac OS X各版本中尤其混乱，先说说本人的一些试验(Mac OS X 10.10.3)：</p><ul><li>在默认配置下(不配置plist和sysctl.conf)，launchctl的maxfiles默认值为(256, unlimited)，sysctl的maxfiles默认值为(12288, 10240)，而ulimit -n得到的值为4864。</li><li>当不定义plist而定义sysctl.conf，那么重启后launchctl和ulimit看到的上限仍为默认值，sysctl看到的上限与sysctl.conf定义的一致。</li><li>当同时在<code>/etc/sysctl.conf</code>和<code>/Library/LaunchDaemons/limit.maxfiles.plist</code>中定义maxfiles时，plist文件中的配置会覆盖sysctl.conf中的配置。如果通过系统重启应用plist，三个命令看到的上限均为plist配置。如果通过launchctl load加载plist，则会同步影响sysctl看到的上限，而不会影响shell下的ulimit上限。</li><li>如果通过launchctl配置的软上限和硬上限分别为S和H(非unlimited)，那么通过launchctl应用配置后最终得到软上限和硬上限都为S。如果设定的上限为S和unlimited，实际上应用的参数为S和10240(sysctl中kern.maxfilesperproc默认值)，当S&gt;10240时，会设置失败，S&lt;10240时，会得到(S, 10240)</li><li><code>ulimit -H -n 1000</code> 降低硬上限无需Root权限，升高则需要</li></ul><p>趁着头大，还可以看看这几篇文章:</p><ol><li><a href="http://superuser.com/questions/827984/open-files-limit-does-not-work-as-before-in-osx-yosemite" target="_blank" rel="external">open files limit does not work as before in osx yosemite</a></li><li><a href="http://krypted.com/mac-os-x/maximum-files-in-mac-os-x/" target="_blank" rel="external">maximum files in mac os x</a></li><li><a href="http://unix.stackexchange.com/questions/108174/how-to-persist-ulimit-settings-in-osx-mavericks" target="_blank" rel="external">how to persist ulimit settings in osx mavericks</a></li><li><a href="https://docs.basho.com/riak/kv/2.2.0/using/performance/open-files-limit/#mac-os-x" target="_blank" rel="external">open files limit in max os x</a></li><li><a href="http://superuser.com/questions/302754/increase-the-maximum-number-of-open-file-descriptors-in-snow-leopard" target="_blank" rel="external">increase the maximum number of open file descriptors in snow leopard</a></li></ol><p>网上对Mac OS X各版本的解决方案各不相同，并且对这三个命令(特别是launchctl和sysctl)在资源限制上的联系与区别也没有清晰的解释。</p><p>按照我的理解和折腾出来的经验：</p><ol><li>ulimit只影响当前Shell下的进程，并且受限于kern.maxfilesperproc</li><li>如果配置了plist，那么重启后，ulimit和sysctl均会继承plist中的值</li><li>热修改sysctl上限值不会影响launchctl，而反之，launchctl会影响sysctl上限值</li></ol><p>综上，在Mac OS X 10.10(我的版本，没试过之前的)之后，使用plist是最合理的方案(但launchctl貌似只能设定一样的软限制和硬限制，如果将硬限制设为ulimited，则会使用kern.maxfilesperproc值)。在系统重启后，kern.maxfilesperproc和ulimit -n都会继承plist maxfiles的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统的资源是有限的(如CPU，内存，内核所能打开的最大文件数等)，资源限制对针对进程能使用的系统资源设定上限。防止恶意进程无限制地占用系统资源。&lt;/p&gt;
&lt;p&gt;资源限制分为两种，硬限制(Hard Limit)和软限制(Soft Limit)，软限制作用于实际进程并且可以修改
      
    
    </summary>
    
      <category term="system" scheme="http://wudaijun.com/categories/system/"/>
    
    
      <category term="system" scheme="http://wudaijun.com/tags/system/"/>
    
      <category term="macosx" scheme="http://wudaijun.com/tags/macosx/"/>
    
  </entry>
  
  <entry>
    <title>Go 常用命令</title>
    <link href="http://wudaijun.com/2017/01/go-command-notes/"/>
    <id>http://wudaijun.com/2017/01/go-command-notes/</id>
    <published>2017-01-19T16:00:00.000Z</published>
    <updated>2018-04-04T02:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><ul><li>Go版本管理: <a href="https://github.com/moovweb/gvm" target="_blank" rel="external">gvm</a>(go version manager)</li><li>GOPATH管理: <a href="https://github.com/pote/gvp" target="_blank" rel="external">gvp</a>(go version package)</li><li>依赖版本管理: <a href="https://github.com/pote/gpm" target="_blank" rel="external">gpm</a>(go package manager)</li></ul><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p>用于编译指定的源码文件或代码包以及它们的依赖包。</p><blockquote><p>import导入路径中的最后一个元素是路径名而不是包名，路径名可以和包名不一样，但同一个目录只能定义一个包(包对应的_test测试包除外)</p></blockquote><a id="more"></a><p>编译包:</p><pre><code># 当前路径方式cd src/foo &amp;&amp; go build# 包导入路径方式go build foo bar# 本地代码包路径方式go build ./src/foo</code></pre><p>go build 在编译只包含库源码文件的代码包时，只做检查性的编译，不会输出任何结果文件。如果编译的是main包，则会将编译结果放到执行命令的目录下。</p><p>编译源码文件:</p><pre><code># 指定源码文件使用文件路径# 指定的多个源码文件必须属于同一个目录(包)go build src/foo/foo1.go src/foo/foo2.go</code></pre><p>当执行以上编译时，编译命令在分析参数的时候如果发现第一个参数是Go源码文件而不是代码包时，会在内部生成一个名为“command-line-arguments”的虚拟代码包。也就是当前的foo1.go foo2.go属于”command-line-arguments”包，而不是foo包，因此除了指定的源码文件和它们所依赖的包，其它文件(如foo3.go)不会被编译。</p><p>同样，对于库源码文件，build不会输出任何结果文件。对于main包的源文件，go build要求有且只能有一个main函数声明，并将生成结果(与指定的第一个源码文件同名)放在执行该命令的当前目录下。</p><p>构建与<code>go build</code>之上的其它命令(如<code>go run</code>，<code>go install</code>)，在编译包或源码文件时，过程和特性是一样的。</p><p>常用选项:</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-v</td><td>打印出那些被编译的代码包的名字。</td></tr><tr><td>-n</td><td>打印编译期间所用到的其它命令，但是并不真正执行它们。</td></tr><tr><td>-x</td><td>打印编译期间所用到的其它命令。注意它与-n标记的区别。</td></tr><tr><td>-a</td><td>强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。</td></tr><tr><td>-work</td><td>打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。</td></tr></tbody></table></div><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>go run编译(通过go build)并运行命令源码文件(main package)，查看过程:</p><pre><code>go run -x -work src/main/main.go# build 临时目录WORK=/var/folders/n5/j8y6skrx1xn3_ls64gl1lrsmmp53rv/T/go-build979313546# main.go依赖foo包  先编译foo包mkdir -p $WORK/foo/_obj/mkdir -p $WORK/cd /Users/wudaijun/Work/test/src/foo/usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/compile -o $WORK/foo.a -trimpath $WORK -p foo -complete -buildid cd61b5a9f3c8eba0f3088adca894fc9bf695826b -D _/Users/wudaijun/Work/test/src/foo -I $WORK -pack ./foo.go# 在虚拟包 command-line-arguments 中编译 main.gomkdir -p $WORK/command-line-arguments/_obj/mkdir -p $WORK/command-line-arguments/_obj/exe/cd /Users/wudaijun/Work/test/src/main/usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/compile -o $WORK/command-line-arguments.a -trimpath $WORK -p main -complete -buildid 9131b7dd9f64a85bb423da7f8a7d408c089a23e8 -D _/Users/wudaijun/Work/test/src/main -I $WORK -I /Users/wudaijun/Work/test/pkg/darwin_amd64 -pack ./main.go# 链接cd ./usr/local/Cellar/go/1.7/libexec/pkg/tool/darwin_amd64/link -o $WORK/command-line-arguments/_obj/exe/main -L $WORK -L /Users/wudaijun/Work/test/pkg/darwin_amd64 -w -extld=clang -buildmode=exe -buildid=9131b7dd9f64a85bb423da7f8a7d408c089a23e8 $WORK/command-line-arguments.a# 从临时目录运行可执行文件$WORK/command-line-arguments/_obj/exe/mainCall Foo()</code></pre><p>可看到<code>go run</code>的执行结果都在WORK临时目录中完成，由于使用了<code>-work</code>选项，因此WORK目录会在<code>go run</code>执行完成后保留。<code>go run</code>只接受命令源文件而不接收包路径作为参数，并且不会在当前目录生成任何文件。</p><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>只比<code>go build</code>多干一件事：安装编译后的结果文件到指定目录。</p><h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h3><h4 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h4><p><code>go test</code>编译指定包或源文件，并执行所在包对应的测试用例。一个符合规范的测试文件指：</p><ul><li>文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码</li><li>你必须import testing这个包</li><li>所有的测试用例函数必须是Test开头</li><li>测试用例会按照源代码中写的顺序依次执行</li><li>测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态</li><li>测试格式：<code>func TestXxx (t *testing.T)</code>,Xxx部分可以为任意的字母数字的组合，但是- - 首字母不能是小写字母[a-z]，例如Testingdiv是错误的函数名</li><li>函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息</li></ul><p>测试分为包内测试和包外测试，即测试源码文件可于被测试源码文件位于同一个包(目录)，或者测试源码文件声明的包名可以是被测试包名+”_test”后缀。</p><h4 id="2-基准测试"><a href="#2-基准测试" class="headerlink" title="2. 基准测试"></a>2. 基准测试</h4><p>基准测试也就是跑分测试，写法和单元测试差不多，只不过函数签名为<code>BenchmarkXxx(b *testing.B)</code>，函数内通过 b.N 作为迭代次数，go test会自动调整这个值，得到合适的测试次数，然后算出每次迭代消耗的时间。</p><h4 id="3-执行测试"><a href="#3-执行测试" class="headerlink" title="3. 执行测试"></a>3. 执行测试</h4><pre><code># 执行当前目录所在包的单元测试go test . # 执行当前目录所在包的单元测试和基准测试(-bench 后面接正则匹配，&#39;.&#39;通配所有 Benchmark)go test -bench . . # 执行当前目录所在包的 TestAbc 单元测试以及 BenchmarkAbc 基准测试go test -run TestAbc -bench BenchmarkAbc . # 在当前目录生成 battle.test 二进制文件而不执行，支持 go build 的所有参数。如可通过 -o 参数指定输出文件go test -c ngs/battle # 直接执行 test 二进制时，test flag 需要加上 &#39;test.&#39; 前缀./battle.test -test.bench . # 以下两条命令等价 并且实际上，编译器也是分为这两步来做的go test -bench . -cpuprofile cpu.prof .go test -c -o my.test . &amp;&amp; my.test -test.bench . -test.cpuprofile cpu.prof# 如果要在 go test 时传入无需编译器加 &#39;test.&#39; 前缀的 flag，可将 flag 放在 -args 选项后:go test -v -args -x -v# 等价于:pkg.test -test.v -x -v</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境管理&quot;&gt;&lt;a href=&quot;#环境管理&quot; class=&quot;headerlink&quot; title=&quot;环境管理&quot;&gt;&lt;/a&gt;环境管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go版本管理: &lt;a href=&quot;https://github.com/moovweb/gvm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gvm&lt;/a&gt;(go version manager)&lt;/li&gt;
&lt;li&gt;GOPATH管理: &lt;a href=&quot;https://github.com/pote/gvp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gvp&lt;/a&gt;(go version package)&lt;/li&gt;
&lt;li&gt;依赖版本管理: &lt;a href=&quot;https://github.com/pote/gpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gpm&lt;/a&gt;(go package manager)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;go-build&quot;&gt;&lt;a href=&quot;#go-build&quot; class=&quot;headerlink&quot; title=&quot;go build&quot;&gt;&lt;/a&gt;go build&lt;/h3&gt;&lt;p&gt;用于编译指定的源码文件或代码包以及它们的依赖包。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;import导入路径中的最后一个元素是路径名而不是包名，路径名可以和包名不一样，但同一个目录只能定义一个包(包对应的_test测试包除外)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
      <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
</feed>
