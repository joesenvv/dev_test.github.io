<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
  <title>Erlang 常用数据结构实现 | wudaijun&#39;s blog | Coding is Funny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="erlang">
  <meta name="description" content="简单介绍一下Erlang常用数据结构的内部实现和特性，主要参考Erlang OTP 18.0源码，和网上很多优秀博客(参见附录)，整理了一些自己项目中常用到的。
Erlang虚拟机使用一个字(64/32位)来表示所有类型的数据，即Eterm。具体的实施方案通过占用Eterm的后几位作为类型标签，然后根据标签类型来解释剩余位的用途。这个标签是多层级的，最外层占用两位，有三种类型：

01: list">
<meta property="og:type" content="article">
<meta property="og:title" content="Erlang 常用数据结构实现">
<meta property="og:url" content="http://wudaijun.com/2015/12/erlang-datastructures/index.html">
<meta property="og:site_name" content="wudaijun's blog">
<meta property="og:description" content="简单介绍一下Erlang常用数据结构的内部实现和特性，主要参考Erlang OTP 18.0源码，和网上很多优秀博客(参见附录)，整理了一些自己项目中常用到的。
Erlang虚拟机使用一个字(64/32位)来表示所有类型的数据，即Eterm。具体的实施方案通过占用Eterm的后几位作为类型标签，然后根据标签类型来解释剩余位的用途。这个标签是多层级的，最外层占用两位，有三种类型：

01: list">
<meta property="og:image" content="http://wudaijun.com/assets/image/erlang/erlang_lists_sample.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/erlang/erlang_tuple_format.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/erlang_refc_binary.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/erlang_sub_binary.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/erlang_binary_append.png">
<meta property="og:updated_time" content="2016-12-27T03:54:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Erlang 常用数据结构实现">
<meta name="twitter:description" content="简单介绍一下Erlang常用数据结构的内部实现和特性，主要参考Erlang OTP 18.0源码，和网上很多优秀博客(参见附录)，整理了一些自己项目中常用到的。
Erlang虚拟机使用一个字(64/32位)来表示所有类型的数据，即Eterm。具体的实施方案通过占用Eterm的后几位作为类型标签，然后根据标签类型来解释剩余位的用途。这个标签是多层级的，最外层占用两位，有三种类型：

01: list">
  
    <link rel="alternative" href="/atom.xml" title="wudaijun&#39;s blog" type="application/atom+xml">
  
  <meta name="summary" content="&lt;p&gt;简单介绍一下Erlang常用数据结构的内部实现和特性，主要参考&lt;a href=&quot;https://github.com/erlang/otp/tree/maint-18&quot;&gt;Erlang OTP 18.0&lt;/a&gt;源码，和网上很多优秀博客(参见附录)，整理了一些自己项目中常用到的。&lt;/p&gt;
&lt;p&gt;Erlang虚拟机使用一个字(64/32位)来表示所有类型的数据，即Eterm。具体的实施方案通过占用Eterm的后几位作为类型标签，然后根据标签类型来解释剩余位的用途。这个标签是多层级的，最外层占用两位，有三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;01: list，剩下62位是指向列表Cons的指针&lt;/li&gt;
&lt;li&gt;10: boxed对象，即复杂对象，剩余62位指向boxed对象的对象头。包括元组，大整数，外部Pid/Port等&lt;/li&gt;
&lt;li&gt;11: immediate立即数，即可以在一个字中表示的小型对象，包括小整数，本地Pid/Port，Atom，NIL等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三种类型是Erlang类型的大框架，前两者是可以看做是引用类型，立即数相当于是值类型，&lt;strong&gt;但无论对于哪种类型，Erlang Eterm本身只占用一个字&lt;/strong&gt;，理解这一点是很重要的。&lt;/p&gt;">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css?v=1.1.4">
</head>

<body>
  <div id="loading" class="active"></div>

  <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar"><img src="/favicon.png"></a>
        <hgroup class="introduce">
          <h5 class="nickname">wudaijun</h5>
          <a href="mailto:wdjlost@gmail.com" title="wdjlost@gmail.com" class="mail">wdjlost@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://blog.csdn.net/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-contao"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wudaijun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>

      <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>wudaijun&#39;s blog &copy; 2017</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

    </div>
  </div>
</aside>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Erlang 常用数据结构实现</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container">
        <h1 class="title">Erlang 常用数据结构实现</h1>
        
        

    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一-_常用类型"><span class="post-toc-text">一. 常用类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-_atom"><span class="post-toc-text">1. atom</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-Pid/Port"><span class="post-toc-text">2.Pid/Port</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-_lists"><span class="post-toc-text">3. lists</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-_tuple"><span class="post-toc-text">4. tuple</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-_binary"><span class="post-toc-text">5. binary</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#heap_binary"><span class="post-toc-text">heap binary</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#refc_bianry"><span class="post-toc-text">refc bianry</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sub_binary"><span class="post-toc-text">sub binary</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bit_string"><span class="post-toc-text">bit string</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#binary追加构造优化"><span class="post-toc-text">binary追加构造优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#binary降级"><span class="post-toc-text">binary降级</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二-_复合类型"><span class="post-toc-text">二. 复合类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-_record"><span class="post-toc-text">1. record</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-_map"><span class="post-toc-text">2. map</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-_array"><span class="post-toc-text">3. array</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三-_参考"><span class="post-toc-text">三. 参考</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-erlang-datastructures" 
  class="post-article article-type-post" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Erlang 常用数据结构实现</h1>
        <div class="post-meta">
            <time datetime="2015-12-05T16:00:00.000Z" itemprop="datePublished" class="post-time">
  2015-12-06
</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/erlang/">erlang</a></li></ul>



        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>简单介绍一下Erlang常用数据结构的内部实现和特性，主要参考<a href="https://github.com/erlang/otp/tree/maint-18" target="_blank" rel="external">Erlang OTP 18.0</a>源码，和网上很多优秀博客(参见附录)，整理了一些自己项目中常用到的。</p>
<p>Erlang虚拟机使用一个字(64/32位)来表示所有类型的数据，即Eterm。具体的实施方案通过占用Eterm的后几位作为类型标签，然后根据标签类型来解释剩余位的用途。这个标签是多层级的，最外层占用两位，有三种类型：</p>
<ul>
<li>01: list，剩下62位是指向列表Cons的指针</li>
<li>10: boxed对象，即复杂对象，剩余62位指向boxed对象的对象头。包括元组，大整数，外部Pid/Port等</li>
<li>11: immediate立即数，即可以在一个字中表示的小型对象，包括小整数，本地Pid/Port，Atom，NIL等</li>
</ul>
<p>这三种类型是Erlang类型的大框架，前两者是可以看做是引用类型，立即数相当于是值类型，<strong>但无论对于哪种类型，Erlang Eterm本身只占用一个字</strong>，理解这一点是很重要的。</p>
<a id="more"></a>
<p>对于二三级标签的细分和编码，一般我们无需知道这些具体的底层细节，以下是几种常用的数据结构实现方式。</p>
<h2 id="一-_常用类型">一. 常用类型</h2><h3 id="1-_atom">1. atom</h3><p>atom用立即数表示，在Eterm中保存的是atom在全局atom表中的索引，依赖于高效的哈希和索引表，Erlang的atom比较和匹配像整数一样高效。atom表是不回收的，并且默认最大值为1024*1024，超过这个限制Erlang虚拟机将会崩溃，可通过<code>+t</code>参数调整该上限。</p>
<h3 id="2-Pid/Port">2.Pid/Port</h3><pre><code>/*  erts/emulator/beam/erl_term.h

 *
 *  <span class="class">Old</span> pid layout(<span class="class">R9B</span>及之前):
 *  
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   <span class="localvars">|s s s|n n n n n n n n n n n n n n n|</span><span class="class">N</span> <span class="class">N</span> <span class="class">N</span> <span class="class">N</span> <span class="class">N</span> <span class="class">N</span> <span class="class">N</span> <span class="class">N</span><span class="localvars">|c c|</span><span class="number">0</span> <span class="number">0</span>|<span class="number">1</span> <span class="number">1</span>|
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *  s : serial  每次n到达<span class="number">2</span>^<span class="number">15</span>之后 自增一次 然后n重新从低位开始
 *  n : number  <span class="number">15</span>位, 进程在本地进程表中的索引
 *  c : creation 每次节点重启，该位自增一次
 *  <span class="class">N</span> : node number 节点名字在atom表中索引
 *
 *
 *  <span class="class">PID</span> layout (internal pids):
 *
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   <span class="localvars">|n n n n n n n n n n n n n n n n n n n n n n n n n n n n|</span><span class="number">0</span> <span class="number">0</span>|<span class="number">1</span> <span class="number">1</span>|
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *  n : number <span class="number">28</span>位进程<span class="class">Pid</span>
 */
</code></pre><p>在Old Pid表示中(R9B及之前版本)，在32位中表示了整个Pid，包括其节点名字等信息，也就是本地进程和外部进程都可以用Eterm立即数表示，显示格式为<code>&lt;N, n, s&gt;</code>。</p>
<p>在R9B之后，随着进程数量增加和其它因素，Pid只在32位中表示本地Pid(A=0)，将32位中除了4位Tag之外的28位，都可用于进程Pid表示，出于Pid表示的历史原因，仍然保留三段式的显示，本地Pid表示变成了<code>&lt;0, Pid低15位, Pid高13位&gt;</code>。对于外部Pid，采用boxed复合对象表示，在将本地Pid发往其它node时，Erlang会自动将为Pid加上本地节点信息，并打包为一个boxed对象，占用6个字。另外，Erlang需要维护Pid表，每个条目占8个字节，当进程数量过大时，Pid表将占用大量内存，Erlang默认可以使用18位有效位来表示Pid(262144)，可通过+P参数调节，最大值为27位(2^27-1)，此时Pid表占用内存为2G。</p>
<pre><code>Eshell V8.1  (abort with ^G)
(n1@T4F-MBP-11)1&gt; node().
'n1@T4F-MBP-11'
% 节点名的二进制表示
(n1@T4F-MBP-11)2&gt; term_to_binary(node()).
&lt;&lt;<span class="number">131,100,0,13</span>,<span class="number">110,49,64,84</span>,<span class="number">52,70,45,77</span>,<span class="number">66,80,45,49</span>,49&gt;&gt;
(n1@T4F-MBP-11)3&gt; self().
&lt;0.63.0&gt;
% term_to_binary会将<span class="keyword">A</span>对应的节点名编码进去
(n1@T4F-MBP-11)4&gt; term_to_binary(self()).
&lt;&lt;<span class="number">131,103,100,0</span>,<span class="number">13,110,49,64</span>,<span class="number">84,52,70,45</span>,<span class="number">77,66,80,45</span>,49,
  <span class="number">49,0,0,0</span>,<span class="number">63,0,0,0</span>,0,2&gt;&gt;
(n1@T4F-MBP-11)5&gt;
</code></pre><h3 id="3-_lists">3. lists</h3><p>列表以标签01标识，剩余62位指向列表的Cons单元，Cons是[Head|Tail]的组合，在内存中体现为两个相邻的Eterm，Head可以是任何类型的Eterm，Tail是列表类型的Eterm。因此形如<code>L2 = [Elem|L1]</code>的操作，实际上构造了一个新的Cons，其中Head是Elem Eterm，Tail是L1 Eterm，然后将L2的Eterm指向了这个新的Cons，因此L2即代表了这个新的列表。对于<code>[Elem|L2] = L1</code>，实际上是提出了L1 Eterm指向的Cons，将Head部分赋给Elem，Tail部分赋给L2，注意Tail本身就是个List的Eterm，因此list是单向列表，并且构造和提取操作是很高效的。需要再次注意的是，Erlang所有类型的Eterm本身只占用一个字大小。这也是诸如list,tuple能够容纳任意类型的基础。</p>
<p>Erlang中进程内对对象的重复引用只需占用一份对象内存(只是Eterm本身一个字的拷贝)，但是在对象跨进程时，对象会被展开，执行速深度拷贝：</p>
<pre><code><span class="variable">Eshell</span> <span class="variable">V7</span>.<span class="number">0.2</span>  (<span class="function_or_atom">abort</span> <span class="function_or_atom">with</span> ^<span class="variable">G</span>)
<span class="prompt">1&gt; </span><span class="variable">L1</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].
[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
<span class="prompt">2&gt; </span><span class="function_or_atom">erts_debug:size</span>(<span class="variable">L1</span>).          
<span class="number">6</span>
<span class="prompt">3&gt; </span><span class="variable">L2</span> = [<span class="variable">L1</span>,<span class="variable">L1</span>,<span class="variable">L1</span>].
[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]
<span class="prompt">4&gt; </span><span class="function_or_atom">erts_debug:size</span>(<span class="variable">L2</span>).          <span class="comment">% 获得L2对象树的大小 3*2+6</span>
<span class="number">12</span>
<span class="prompt">5&gt; </span><span class="function_or_atom">erts_debug:flat_size</span>(<span class="variable">L2</span>).     <span class="comment">% 获得对象平坦展开后的大小 3*(2+6)</span>
<span class="number">24</span>
<span class="prompt">6&gt; </span><span class="variable">P1</span> = <span class="function_or_atom">spawn</span>(<span class="function_or_atom">fun</span>() <span class="arrow">-&gt;</span> <span class="function_or_atom">receive</span> <span class="variable">L</span> <span class="arrow">-&gt;</span> <span class="function_or_atom">io:format</span>(<span class="string">"~p~n"</span>,[<span class="function_or_atom">erts_debug:size</span>(<span class="variable">L</span>)]) <span class="function_or_atom">end</span> <span class="function_or_atom">end</span>).
&lt;<span class="number">0.45</span>.<span class="number">0</span>&gt;
<span class="prompt">7&gt; </span><span class="variable">P1</span> <span class="exclamation_mark">!</span> <span class="variable">L2</span>.                      <span class="comment">% 在跨进程时，对象被展开 执行深度拷贝</span>
<span class="number">24</span>
[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]
</code></pre><p>此时L1, L2的内存布局如下：</p>
<p><img src="/assets/image/erlang/erlang_lists_sample.png" alt=""></p>
<h3 id="4-_tuple">4. tuple</h3><p>tuple属于boxed对象的一种，每个boxed对象都有一个对象头(header)，boxed Eterm即指向这个header，这个header里面包含具体的boxed对象类型，如tuple的header末6位为000000，前面的位数为tuple的size：</p>
<p><img src="/assets/image/erlang/erlang_tuple_format.png" alt=""></p>
<p>tuple实际上就是一个有头部的数组，其包含的Eterm在内存中紧凑排列，tuple的操作效率和数组是一致的。</p>
<p>list和tuple是erlang中用得最多的数据结构，也是其它一些数据结构的基础，如record，map，摘下几个关于list，tuple操作的常用函数，便于加深对结构的理解：</p>
<pre><code><span class="comment"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 $OTP_SRC/erts/emulator/beam/bif.c</span></span><br><span class="line"><span class="function">BIF_RETTYPE <span class="title">tuple_to_list_1</span><span class="params">(BIF_ALIST_1)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Uint n;</span><br><span class="line">    Eterm *tupleptr;</span><br><span class="line">    Eterm <span class="built_in">list</span> = NIL;</span><br><span class="line">    Eterm* hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_not_tuple(BIF_ARG_1))  &#123;</span><br><span class="line">	BIF_ERROR(BIF_P, BADARG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到tuple Eterm所指向的tuple对象头</span></span><br><span class="line">    tupleptr = tuple_val(BIF_ARG_1);</span><br><span class="line">    <span class="comment">// 得到对象头中的tuple size		    </span></span><br><span class="line">    n = arityval(*tupleptr);</span><br><span class="line">    hp = HAlloc(BIF_P, <span class="number">2</span> * n);</span><br><span class="line">    tupleptr++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 倒序遍历 因为list CONS的构造是倒序的</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="comment">// 相当于hp[0]=tupleptr[n]; hp[1] = list; list = make_list(hp);</span></span><br><span class="line">    <span class="comment">// 最后返回的是指向hp的list Eterm</span></span><br><span class="line">	<span class="built_in">list</span> = CONS(hp, tupleptr[n], <span class="built_in">list</span>);</span><br><span class="line">	hp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BIF_RET(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BIF_RETTYPE <span class="title">list_to_tuple_1</span><span class="params">(BIF_ALIST_1)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Eterm <span class="built_in">list</span> = BIF_ARG_1;</span><br><span class="line">    Eterm* cons;</span><br><span class="line">    Eterm res;</span><br><span class="line">    Eterm* hp;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((len = erts_list_length(<span class="built_in">list</span>)) &lt; <span class="number">0</span> || len &gt; 		ERTS_MAX_TUPLE_SIZE) &#123;</span><br><span class="line">	BIF_ERROR(BIF_P, BADARG);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 元素个数 + 对象头</span></span><br><span class="line">    hp = HAlloc(BIF_P, len+<span class="number">1</span>);</span><br><span class="line">    res = make_tuple(hp);</span><br><span class="line">    *hp++ = make_arityval(len);</span><br><span class="line">    <span class="keyword">while</span>(is_list(<span class="built_in">list</span>)) &#123;</span><br><span class="line">	cons = list_val(<span class="built_in">list</span>);</span><br><span class="line">	*hp++ = CAR(cons);</span><br><span class="line">	<span class="built_in">list</span> = CDR(cons);</span><br><span class="line">    &#125;</span><br><span class="line">    BIF_RET(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>可以看到，list，tuple中添加元素，实际上都是在拷贝Eterm本身，Erlang虚拟机会追踪这些引用，并负责垃圾回收。</p>
<h3 id="5-_binary">5. binary</h3><p>Erlang binary用于处理字节块，Erlang其它的数据结构(list,tuple,record)都是以Eterm为单位的，用于处理字节块会浪费大量内存，如”abc”占用了7个字(加上ETerm本身)，binary为字节流提供一种操作高效，占用空间少的解决方案。</p>
<p>之前我们介绍的数据结构都存放在Erlang进程堆上，进程内部可以使用对象引用，在对象跨进程传输时，会执行对象拷贝。为了避免大binary跨进程传输时的拷贝开销，Erlang针对binary作出了优化，将binary分为小binary和大binary。</p>
<h4 id="heap_binary">heap binary</h4><p>小于64字节(定义于erl_binary.h <code>ERL_ONHEAP_BIN_LIMIT</code>宏)的小binary直接创建在进程堆上，称为heap binary，heap binary是一个boxed对象：</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">erl_heap_bin</span> </span>{
    Eterm thing_word;        <span class="comment">/* Subtag HEAP_BINARY_SUBTAG. */</span>
    Uint size;                <span class="comment">/* Binary size in bytes. */</span>
    Eterm data[<span class="number">1</span>];            <span class="comment">/* The data in the binary. */</span>
} ErlHeapBin;
</code></pre><h4 id="refc_bianry">refc bianry</h4><p>大于64字节的binary将创建在Erlang虚拟机全局堆上，称为refc binary(reference-counted binary)，可被所有Erlang进程共享，这样跨进程传输只需传输引用即可，虚拟机会对binary本身进行引用计数追踪，以便GC。refc binary需要两个部分来描述，位于全局堆的refc binary数据本身和位于进程堆的binary引用(称作proc binary)，这两种数据结构定义于global.h中。下图描述refc binary和proc binary的关系：</p>
<p><img src="/assets/image/erlang_refc_binary.png" alt=""></p>
<p>所有的OffHeap(进程堆之外的数据)被组织为一个单向链表，进程控制块(erl_process.h struct process)中的<code>off_heap</code>字段维护链表头和所有OffHeap对象的总大小，当这个大小超过虚拟机阀值时，将导致一次强制GC。注意，refc binary只是OffHeap对象的一种，以后可扩展其它种类。</p>
<h4 id="sub_binary">sub binary</h4><p>sub binary是Erlang为了优化binary分割的(如<code>split_binary/2</code>)，由于Erlang变量不可变语义，拷贝分割的binary是效率比较底下的做法，Erlang通过sub binary来复用原有binary。ErlSubBin定义于<code>erl_binary.h</code>，下图描述<code>split_binary(ProBin, size1)</code>返回一个ErlSubBin二元组的过程：</p>
<p><img src="/assets/image/erlang_sub_binary.png" alt=""></p>
<p>ProBin的size可能小于refc binary的size，如上图中的size3，这是因为refc binary通常会通过预分配空间的方式进行优化。</p>
<p>要注意的是，sub binary只引用proc binary(通过orig)，而不直接引用refc binary，因此图中refc binary的refc字段仍然为1。只要sub binary还有效，对应的proc binary便不会被GC，refc binary的计数也就不为0。</p>
<h4 id="bit_string">bit string</h4><p>当我们通过如<code>&lt;&lt;2:3,3:6&gt;&gt;</code>的位语法构建binary时，将得到<code>&lt;&lt;65,1:1&gt;&gt;</code>这种非字节对齐的数据，即二进制流，在Erlang中被称为bitstring，Erlang的bitstring基于ErlSubBin结构实现，此时bitsize为最后一个字节的有效位数，size为有效字节数(不包括未填满的最后一个字节)，对虚拟机底层来说，sub bianry和bit string是同一种数据结构。</p>
<h4 id="binary追加构造优化">binary追加构造优化</h4><p>在通过<code>C = &lt;&lt;A/binary,B/binary&gt;&gt;</code>追加构造binary时，最自然的做法应当是创建足够空间的C(heap or refc)，再将A和B的数据拷贝进去，但Erlang对binary的优化不止于此，它使用refc binary的预留空间，通过追加的方式提高大binary和频繁追加的效率。</p>
<pre><code><span class="comment"><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Bin0</span> = &lt;&lt;<span class="number">0</span>&gt;&gt;,                    <span class="comment">%% 创建一个heap binary Bin0</span></span><br><span class="line"><span class="variable">Bin1</span> = &lt;&lt;<span class="variable">Bin0</span>/binary,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&gt;&gt;,    <span class="comment">%% 追加目标不是refc binary，创建一个refc binary，预留256字节空间，用Bin0初始化，并追加1,2,3</span></span><br><span class="line"><span class="variable">Bin2</span> = &lt;&lt;<span class="variable">Bin1</span>/binary,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&gt;&gt;,    <span class="comment">%% 追加目标为refc binary且有预留空间 直接追加4,5,6</span></span><br><span class="line"><span class="variable">Bin3</span> = &lt;&lt;<span class="variable">Bin2</span>/binary,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&gt;&gt;,    <span class="comment">%% 同样，将7,8,9追加refc binary预留空间</span></span><br><span class="line"><span class="variable">Bin4</span> = &lt;&lt;<span class="variable">Bin1</span>/binary,<span class="number">17</span>&gt;&gt;,       <span class="comment">%% 此时不能直接追加，否则会覆盖Bin2内容，虚拟机会通过某种机制发现这一点，然后将Bin1拷贝到新的refc binary，再执行追加</span></span><br><span class="line"><span class="tuple">&#123;<span class="variable">Bin4</span>,<span class="variable">Bin3</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过erts_get_internal_state/1可以获取binary状态</span></span><br><span class="line"><span class="comment">% 对应函数源码位于$BEAM_SRC/erl_bif_info.c erts_debug_get_internal_state_1</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span> -&gt;</span></span><br><span class="line">	<span class="variable">B0</span> = &lt;&lt;<span class="number">0</span>&gt;&gt;,</span><br><span class="line">	<span class="function_name">erts_debug:set_internal_state</span>(available_internal_state,true), <span class="comment">% 打开内部状态获取接口 同一个进程只需执行一次</span></span><br><span class="line">	<span class="function_name">f2</span>(<span class="variable">B0</span>). <span class="comment">% 通过参数传递B0 是为了避免虚拟机优化 直接构造B1为heap binary</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">f2</span><span class="params">(<span class="variable">B0</span>)</span> -&gt;</span></span><br><span class="line">  <span class="function_name">io:format</span>(<span class="string">"B0: ~p~n"</span>, [<span class="function_name">erts_debug:get_internal_state</span>(<span class="tuple">&#123;binary_info,<span class="variable">B0</span>&#125;</span>)]),</span><br><span class="line">  <span class="variable">B1</span> = &lt;&lt;<span class="variable">B0</span>/binary, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&gt;&gt;,</span><br><span class="line">  <span class="function_name">io:format</span>(<span class="string">"B1: ~p~n"</span>, [<span class="function_name">erts_debug:get_internal_state</span>(<span class="tuple">&#123;binary_info,<span class="variable">B1</span>&#125;</span>)]),</span><br><span class="line">  <span class="variable">B2</span> = &lt;&lt;<span class="variable">B1</span>/binary, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&gt;&gt;,</span><br><span class="line">  <span class="function_name">io:format</span>(<span class="string">"B2: ~p~n"</span>, [<span class="function_name">erts_debug:get_internal_state</span>(<span class="tuple">&#123;binary_info,<span class="variable">B2</span>&#125;</span>)]),</span><br><span class="line">  ok.</span><br><span class="line"></span><br><span class="line"><span class="comment">% get_internal_state(&#123;binary_info, B&#125;)返回格式:</span></span><br><span class="line"><span class="comment">% proc binary：&#123;refc_binary, pb_size, &#123;binary, orig_size&#125;, pb_flags&#125;</span></span><br><span class="line"><span class="comment">% heap binary：heap_binary</span></span><br><span class="line"><span class="variable">B0</span>: heap_binary</span><br><span class="line"><span class="variable">B1</span>: <span class="tuple">&#123;refc_binary,<span class="number">4</span>,<span class="tuple">&#123;binary,<span class="number">256</span>&#125;</span>,<span class="number">3</span>&#125;</span></span><br><span class="line"><span class="variable">B2</span>: <span class="tuple">&#123;refc_binary,<span class="number">7</span>,<span class="tuple">&#123;binary,<span class="number">256</span>&#125;</span>,<span class="number">3</span>&#125;</span></span><br></pre></td></tr></table></figure></span>
</code></pre><p>binary追加实现源码位于<code>$BEAM_SRC/erl_bits.c erts_bs_append</code>，B1和B2本身是sub binary，基于同一个ProcBin，可追加的refc binary只能被一个ProcBin引用，这是因为可追加refc binary可能会在追加过程中重新分配空间，此时要更新ProcBin引用，而refc binary无法快速追踪到其所有ProcBin引用(只能遍历)，另外，多个ProcBin上的sub binary可能对refc binary覆写。</p>
<p>只有最后追加得到的sub binary才可执行快速追加(通过sub binary和对应ProBin flags来判定)，否则会拷贝并分配新的可追加refc binary。所有的sub binary都是指向ProcBin或heap binary的，不会指向sub binary本身。</p>
<p><img src="/assets/image/erlang_binary_append.png" alt=""></p>
<h4 id="binary降级">binary降级</h4><p>Erlang通过追加优化构造出的可追加refc binary通过空间换取了效率，并且这类refc binary只能被一个proc binary引用(多个proc binary上的sub binary会造成覆写，注意，前面的B1，B2是sub binary而不是ProBin)。比如在跨进程传输时，原本只需拷贝ProBin，但对可追加的refc binary来说，不能直接拷贝ProBin，这时需对binary降级，即将可追加refc binary降级为普通refc binary：</p>
<pre><code><span class="keyword">bs_emasculate(Bin0) </span>-&gt;
<span class="keyword">Bin1 </span>= &lt;&lt;<span class="keyword">Bin0/binary, </span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;,
<span class="label">NewP</span> = spawn(fun() -&gt; receive _ -&gt; ok <span class="preprocessor">end</span> <span class="preprocessor">end</span>),
<span class="label">io</span>:format(<span class="string">"Bin1 info: ~p~n"</span>, [erts_debug:get_internal_state({<span class="keyword">binary_info, </span><span class="keyword">Bin1})]),
</span><span class="label">NewP</span> ! <span class="keyword">Bin1,
</span><span class="label">io</span>:format(<span class="string">"Bin1 info: ~p~n"</span>, [erts_debug:get_internal_state({<span class="keyword">binary_info, </span><span class="keyword">Bin1})]),
</span><span class="keyword">Bin2 </span>= &lt;&lt;<span class="keyword">Bin1/binary, </span><span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&gt;&gt;, % <span class="keyword">Bin1被收缩 </span>这一步会执行refc <span class="keyword">binary拷贝
</span><span class="label">io</span>:format(<span class="string">"Bin2 info: ~p~n"</span>, [erts_debug:get_internal_state({<span class="keyword">binary_info, </span><span class="keyword">Bin2})]),
</span><span class="keyword">Bin2.
</span>
% 运行结果
<span class="number">117</span>&gt; <span class="keyword">bs_emasculate(&lt;&lt;0&gt;&gt;).
</span><span class="keyword">Bin1 </span><span class="preprocessor">info</span>: {refc_binary,<span class="number">4</span>,{<span class="keyword">binary,256},3}
</span><span class="keyword">Bin1 </span><span class="preprocessor">info</span>: {refc_binary,<span class="number">4</span>,{<span class="keyword">binary,4},0}
</span><span class="keyword">Bin2 </span><span class="preprocessor">info</span>: {refc_binary,<span class="number">7</span>,{<span class="keyword">binary,256},3}
</span>&lt;&lt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&gt;&gt;
</code></pre><p>降级操作会重新创建一个普通的refc binary(原有可追加refc binary会被GC?)，同时，降级操作会将B1的flags置0，这保证基于B1的sub binary在执行追加时，会重新拷贝分配refc binary。</p>
<pre><code>// 降级函数($<span class="keyword">BEAM_SRC/erl_bits.c)
</span><span class="label">void</span> erts_emasculate_writable_binary(ProcBin* pb)
{
    <span class="keyword">Binary* </span><span class="keyword">binp;
</span>    Uint unused<span class="comment">;</span>

    pb-&gt;flags = <span class="number">0</span><span class="comment">;</span>
    <span class="keyword">binp </span>= pb-&gt;val<span class="comment">;</span>
    <span class="preprocessor">ASSERT</span>(<span class="keyword">binp-&gt;orig_size </span>&gt;= pb-&gt;size)<span class="comment">;</span>
    unused = <span class="keyword">binp-&gt;orig_size </span>- pb-&gt;size<span class="comment">;</span>
    <span class="comment">/* Our allocators are 8 byte aligned, i.e., shrinking with
       less than 8 bytes will have no real effect */</span>
    <span class="preprocessor">if</span> (unused &gt;= <span class="number">8</span>) {
    // 根据ProBin中的有效字节数，重新创建一个不可追加的refc <span class="keyword">binary
</span>    <span class="keyword">binp </span>= erts_bin_realloc(<span class="keyword">binp, </span>pb-&gt;size)<span class="comment">;</span>
    pb-&gt;val = <span class="keyword">binp;
</span>    pb-&gt;<span class="keyword">bytes </span>= (<span class="keyword">byte </span>*) <span class="keyword">binp-&gt;orig_bytes;
</span>    }
}
</code></pre><blockquote>
<blockquote>
<p>Q: ProcBin B1的字段被更新了，那么Erlang上层如何维护变量不可变语义? </p>
<p>A: 变量不可变指的是Erlang虚拟机上层通过底层屏蔽后所能看到的不变语义，而不是变量底层实现，诸如Pid打包，maps hash扩展等，通过底层差异化处理后，对上层体现的语义和接口都没变，因此我们将其理解为”变量不可变”)。</p>
</blockquote>
</blockquote>
<p>另外，全局堆GC也可能会对可追加refc binary的预留空间进行收缩(shrink)，可参考<code>$BEAM_SRC/erl_gc.c sweep_off_heap</code>函数。</p>
<p>以上都是理论的实现，实际上Erlang虚拟机对二进制还做了一些基于上下文的优化，通过<code>bin_opt_info</code>编译选项可以打印出这些优化。关于binary优化的更多细节，参考<a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html" target="_blank" rel="external">Constructing and Matching Binaries</a>。</p>
<h2 id="二-_复合类型">二. 复合类型</h2><p>基于list和tuple之上，Erlang还提供了一些其它的数据结构，这里列举几个key/value相关的数据结构，在服务器中会经常用到。</p>
<h3 id="1-_record">1. record</h3><p>这个类型无需过多介绍，它就是一个tuple，所谓record filed在预编译后实际上都是通过数值下标来索引，因此它访问field是O(1)复杂度的。</p>
<h3 id="2-_map">2. map</h3><p>虽然record的语法糖让我们在使用tuple时便利了不少，但是比起真正的key/value结构仍然有许多限制，如key只能是原子，key不能动态添加或删除，record变动对热更的支持很差等。proplists能够一定程度地解决这种问题，但是它适合键值少的情况，通常用来做选项配置，并且不能保证key的唯一。</p>
<p>map是OTP 17引进的数据结构，是一个boxed对象，它支持任意类型的Key，模式匹配，动态增删Key等，并且最新的<a href="https://github.com/comtihon/mongodb-erlang" target="_blank" rel="external">mongodb-erlang</a>直接支持map。</p>
<p>在<a href="https://github.com/erlang/otp/tree/maint-17" target="_blank" rel="external">OTP17</a>中，map的内存结构为：</p>
<pre><code><span class="comment"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于 $OTP_SRC/erts/emulator/beam/erl_map.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> map_s &#123;</span><br><span class="line">    Eterm thing_word;	<span class="comment">// 	boxed对象header</span></span><br><span class="line">    Uint  size;			<span class="comment">// 	map 键值对个数</span></span><br><span class="line">    Eterm keys;      	<span class="comment">// 	keys的tuple</span></span><br><span class="line">&#125; <span class="keyword">map_t</span>;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>该结构体之后就是依次存放的Value，因此maps的get操作，需要先遍历keys tuple，找到key所在下标，然后在value中取出该下标偏移对应的值。因此是O(n)复杂度的。详见maps:get源码(<code>$BEAM_SRC/erl_map.c erts_maps_get</code>)。</p>
<p>如此的maps，只能作为record的替用，并不是真正的Key-&gt;Value映射，因此不能存放大量数据。而在OTP18中，maps加入了针对于big map的hash机制，当maps:size &lt; <code>MAP_SMALL_MAP_LIMIT</code>时，使用flatmap结构，也就是上述OTP17中的结构，当maps:size &gt;= <code>MAP_SMALL_MAP_LIMI</code>T时，将自动使用hashmap结构来高效存取数据。<code>MAP_SMALL_MAP_LIMIT</code>在erl_map.h中默认定义为32。</p>
<p>仍然要注意Erlang本身的变量不可变原则，每次执行更新maps，都会导致新开辟一个maps，并且拷贝原maps的keys和values，在这一点上，maps:update比maps:put更高效，因为前者keys数量不会变，因此无需开辟新的keys tuple，拷贝keys tuples ETerm即可。实际使用maps时：</p>
<ol>
<li>更新已有key值时，使用update(:=)而不是put(=&gt;)，不仅可以检错，并且效率更高</li>
<li>当key/value对太多时，对其进行层级划分，保证其拷贝效率</li>
</ol>
<p>实际测试中，OTP18中的maps在存取大量数据时，效率还是比较高的，<a href="https://github.com/wudaijun/Code/blob/master/erlang/map_test.erl" target="_blank" rel="external">这里</a>有一份maps和dict的简单测试函数，可通过OTP17和OTP18分别运行来查看效率区别。通常情况下，我们应当优先使用maps，比起dict，它在模式匹配，mongodb支持，可读性上都有很大优势。</p>
<h3 id="3-_array">3. array</h3><p>Erlang有个叫array的结构，其名字容易给人误解，它有如下特性：</p>
<ol>
<li>array下标从0开始</li>
<li>array有两种模式，一种固定大小，另一种按需自动增长大小，但不会自动收缩</li>
<li>支持稀疏存储，执行array:set(100,value,array:new())，那么[0,99]都会被设置为默认值(undefined)，该默认值可修改。</li>
</ol>
<p>在实现上，array最外层被包装为一个record:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp"><span class="keyword">-record</span><span class="params">(array, <span class="tuple">&#123;</span><br><span class="line">	size :: <span class="function_name">non_neg_integer</span>(),	<span class="comment">%% number of defined entries</span></span><br><span class="line">	max  :: <span class="function_name">non_neg_integer</span>(),	<span class="comment">%% maximum number of entries</span></span><br><span class="line">	default,	<span class="comment">%% the default value (usually 'undefined')</span></span><br><span class="line">    elements :: <span class="function_name">elements</span>(<span class="variable">_</span>)     <span class="comment">%% the tuple tree</span></span><br><span class="line">&#125;</span>)</span></span>.</span><br></pre></td></tr></table></figure>
<p>elements是一个tuple tree，即用tuple包含tuple的方式组成的树，叶子节点就是元素值，元素默认以10个为一组，亦即完全展开的情况下，是一颗十叉树。但是对于没有赋值的节点，array用其叶子节点数量代替，并不展开：</p>
<pre><code>Eshell V7<span class="number">.0</span><span class="number">.2</span>  (<span class="built_in">abort</span> with ^G)
<span class="number">1</span>&gt; <span class="built_in">array</span>:<span class="built_in">set</span>(<span class="number">9</span>,value,<span class="built_in">array</span>:<span class="keyword">new</span>()).
{<span class="built_in">array</span>,<span class="number">10</span>,<span class="number">10</span>,undefined, % 全部展开
       {undefined,undefined,undefined,undefined,undefined,
undefined,undefined,undefined,undefined,value}}

% 只展开了<span class="number">19</span>所在的子树 其它<span class="number">9</span>个节点未展开 
% 注意tuple一共有<span class="number">11</span>个元素，最后一个元素代表本层节点的基数，这主要是出于效率考虑，能够快速检索到元素所在子节点
<span class="number">2</span>&gt; <span class="built_in">array</span>:<span class="built_in">set</span>(<span class="number">19</span>,value,<span class="built_in">array</span>:<span class="keyword">new</span>()).
{<span class="built_in">array</span>,<span class="number">20</span>,<span class="number">100</span>,undefined,
       {<span class="number">10</span>,        
        {undefined,undefined,undefined,undefined,undefined，    undefined,undefined,undefined,undefined,value},
        <span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>}}

% 逐级展开了<span class="number">199</span>所在的子树
<span class="number">3</span>&gt; <span class="built_in">array</span>:<span class="built_in">set</span>(<span class="number">199</span>,value,<span class="built_in">array</span>:<span class="keyword">new</span>()).
{<span class="built_in">array</span>,<span class="number">200</span>,<span class="number">1000</span>,undefined,
       {<span class="number">100</span>,
        {<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,
         {undefined,undefined,undefined,undefined,undefined,
 undefined,undefined,undefined,undefined,value},
         <span class="number">10</span>},
        <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>}}
<span class="number">4</span>&gt;
</code></pre><p>由于完全展开的tuple tree是一颗完全十叉树，因此实际上array的自动扩容也是以10为基数的。在根据Index查找元素时，通过div/rem逐级算出Index所属节点:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 位于$OTP_SRC/lib/stdlib/src/array.erl</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="variable">I</span>, <span class="record_name">#array</span>&#123;size = <span class="variable">N</span>, max = <span class="variable">M</span>, elements = <span class="variable">E</span>, default = <span class="variable">D</span>&#125;)</span></span><br><span class="line">  <span class="title">when</span> <span class="title">is_integer</span><span class="params">(<span class="variable">I</span>)</span>, I &gt;= 0 -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">I</span> &lt; <span class="variable">N</span> -&gt;		<span class="comment">% 有效下标</span></span><br><span class="line">	    <span class="function_name">get_1</span>(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">D</span>);</span><br><span class="line">       <span class="variable">M</span> &gt; <span class="number">0</span> -&gt;		<span class="comment">% I&gt;=N 并且 array处于自动扩容模式 直接返回DefaultValue </span></span><br><span class="line">	    <span class="variable">D</span>;</span><br><span class="line">       <span class="literal">true</span> -&gt;		<span class="comment">% I&gt;=N 并且 array为固定大小  返回badarg</span></span><br><span class="line">	    <span class="function_name">erlang:error</span>(badarg)</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="variable">_I</span>, <span class="variable">_A</span>)</span> -&gt;</span></span><br><span class="line">    <span class="function_name">erlang:error</span>(badarg).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% The use of NODEPATTERN(S) to select the right clause is just a hack,</span></span><br><span class="line"><span class="comment">%% but it is the only way to get the maximum speed out of this loop</span></span><br><span class="line"><span class="comment">%% (using the Beam compiler in OTP 11).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% -define(NODEPATTERN(S), &#123;_,_,_,_,_,_,_,_,_,_,S&#125;). % NODESIZE+1 elements!</span></span><br><span class="line"><span class="function"><span class="title">get_1</span><span class="params">(<span class="variable">I</span>, <span class="variable">E</span>=?<span class="variable">NODEPATTERN</span>(<span class="variable">S</span>)</span>, D) -&gt;</span>		<span class="comment">% 到达已展开的中间节点 向下递归</span></span><br><span class="line">    <span class="function_name">get_1</span>(<span class="variable">I</span> rem <span class="variable">S</span>, <span class="function_name">element</span>(<span class="variable">I</span> div <span class="variable">S</span> + <span class="number">1</span>, <span class="variable">E</span>), <span class="variable">D</span>);</span><br><span class="line"><span class="function"><span class="title">get_1</span><span class="params">(<span class="variable">_I</span>, <span class="variable">E</span>, <span class="variable">D</span>)</span> <span class="title">when</span> <span class="title">is_integer</span><span class="params">(<span class="variable">E</span>)</span> -&gt;</span>	<span class="comment">% 到达未展开的中间节点 返回默认值</span></span><br><span class="line">    <span class="variable">D</span>;</span><br><span class="line"><span class="function"><span class="title">get_1</span><span class="params">(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">_D</span>)</span> -&gt;</span>						<span class="comment">% 到达叶子节点层</span></span><br><span class="line">    <span class="function_name">element</span>(<span class="variable">I</span>+<span class="number">1</span>, <span class="variable">E</span>).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(<span class="variable">I</span>, <span class="variable">Value</span>, <span class="record_name">#array</span>&#123;size = <span class="variable">N</span>, max = <span class="variable">M</span>, default = <span class="variable">D</span>, elements = <span class="variable">E</span>&#125;=<span class="variable">A</span>)</span></span><br><span class="line">  <span class="title">when</span> <span class="title">is_integer</span><span class="params">(<span class="variable">I</span>)</span>, I &gt;= 0 -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">I</span> &lt; <span class="variable">N</span> -&gt;</span><br><span class="line">	    <span class="variable">A</span><span class="record_name">#array</span>&#123;elements = <span class="function_name">set_1</span>(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">Value</span>, <span class="variable">D</span>)&#125;;</span><br><span class="line">       <span class="variable">I</span> &lt; <span class="variable">M</span> -&gt;		<span class="comment">% 更新size, size的主要作用是让读取更加高效 </span></span><br><span class="line">	    <span class="comment">%% (note that this cannot happen if M == 0, since N &gt;= 0)</span></span><br><span class="line">	    <span class="variable">A</span><span class="record_name">#array</span>&#123;size = <span class="variable">I</span>+<span class="number">1</span>, elements = <span class="function_name">set_1</span>(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">Value</span>, <span class="variable">D</span>)&#125;;</span><br><span class="line">       <span class="variable">M</span> &gt; <span class="number">0</span> -&gt;		<span class="comment">% 自动扩容</span></span><br><span class="line">	    <span class="tuple">&#123;<span class="variable">E1</span>, <span class="variable">M1</span>&#125;</span> = <span class="function_name">grow</span>(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">M</span>),</span><br><span class="line">	    <span class="variable">A</span><span class="record_name">#array</span>&#123;size = <span class="variable">I</span>+<span class="number">1</span>, max = <span class="variable">M1</span>,</span><br><span class="line">		    elements = <span class="function_name">set_1</span>(<span class="variable">I</span>, <span class="variable">E1</span>, <span class="variable">Value</span>, <span class="variable">D</span>)&#125;;</span><br><span class="line">       <span class="literal">true</span> -&gt;</span><br><span class="line">	    <span class="function_name">erlang:error</span>(badarg)</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(<span class="variable">_I</span>, <span class="variable">_V</span>, <span class="variable">_A</span>)</span> -&gt;</span></span><br><span class="line">    <span class="function_name">erlang:error</span>(badarg).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% See get_1/3 for details about switching and the NODEPATTERN macro.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set_1</span><span class="params">(<span class="variable">I</span>, <span class="variable">E</span>=?<span class="variable">NODEPATTERN</span>(<span class="variable">S</span>)</span>, X, D) -&gt;</span>		<span class="comment">% 所在节点已展开，向下递归</span></span><br><span class="line">    <span class="variable">I1</span> = <span class="variable">I</span> <span class="keyword">div</span> <span class="variable">S</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="function_name">setelement</span>(<span class="variable">I1</span>, <span class="variable">E</span>, <span class="function_name">set_1</span>(<span class="variable">I</span> rem <span class="variable">S</span>, <span class="function_name">element</span>(<span class="variable">I1</span>, <span class="variable">E</span>), <span class="variable">X</span>, <span class="variable">D</span>));</span><br><span class="line"><span class="function"><span class="title">set_1</span><span class="params">(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">X</span>, <span class="variable">D</span>)</span> <span class="title">when</span> <span class="title">is_integer</span><span class="params">(<span class="variable">E</span>)</span> -&gt;</span>	<span class="comment">% 所在节点未被展开，递归展开节点 并赋值</span></span><br><span class="line">    <span class="function_name">expand</span>(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">X</span>, <span class="variable">D</span>);</span><br><span class="line"><span class="function"><span class="title">set_1</span><span class="params">(<span class="variable">I</span>, <span class="variable">E</span>, <span class="variable">X</span>, <span class="variable">_D</span>)</span> -&gt;</span>						<span class="comment">% 到达叶子节点</span></span><br><span class="line">    <span class="function_name">setelement</span>(<span class="variable">I</span>+<span class="number">1</span>, <span class="variable">E</span>, <span class="variable">X</span>).</span><br></pre></td></tr></table></figure>
<p>更多细节可以参见源码，了解了这些之后，再来看看Erlang array和其它语言数组不一样的地方：</p>
<ul>
<li>索引不是O(1)复杂度，而是O(log10n)</li>
<li>array并不自动收缩</li>
<li>array中的max和size字段，和array具体占用内存没多大关系(节点默认未展开)</li>
<li>array中并没有subarray之类的操作，因为它根本不是线性存储的，而是树形的，因此如果用它来做递归倒序遍历之类的操作，复杂度不是O(n)，而是O(n*log10n)</li>
<li>array中对于没有赋值的元素，给予默认值undefined，这个默认值可以在array:new()中更改，对使用者来说，明确赋值undefined和默认值undefined并无多大区别，但对array内部来说，可能会导致节点展开。</li>
</ul>
<h2 id="三-_参考">三. 参考</h2><ol>
<li>Erlang数据结构实现文章汇总: <a href="http://www.iroowe.com/erlang_eterm_implementation/" target="_blank" rel="external">http://www.iroowe.com/erlang_eterm_implementation/</a></li>
<li>[zhengsyao] Erlang系列精品博客(文中大部分图片出处): <a href="http://www.cnblogs.com/zhengsyao/category/387871.html" target="_blank" rel="external">http://www.cnblogs.com/zhengsyao/category/387871.html</a></li>
<li>[坚强2002] Erlang array: <a href="http://www.cnblogs.com/me-sa/archive/2012/06/14/erlang-array.html" target="_blank" rel="external">http://www.cnblogs.com/me-sa/archive/2012/06/14/erlang-array.html</a></li>
<li>Erlang Effciency Guide: <a href="http://erlang.org/doc/efficiency_guide/introduction.html" target="_blank" rel="external">http://erlang.org/doc/efficiency_guide/introduction.html</a></li>
</ol>

        </div>
        
        <blockquote class="post-copyright">
            <div class="content">
               这里写留言或版权声明：<a href="/2015/12/erlang-datastructures/" target="_blank" rel="external">http://wudaijun.com/2015/12/erlang-datastructures/</a>
            </div>
            <footer>
                <a href="http://wudaijun.com">
                    <img src="/favicon.png" alt="wudaijun">
                    wudaijun
                </a>
            </footer>
        </blockquote>

        

        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/erlang/">erlang</a></li></ul>


            
            <div class="post-share-wrap">
                <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

                <a href="javascript:;" id="share-fab" class="post-share-fab waves-effect waves-circle">
                    <i class="icon icon-share-alt icon-lg"></i>
                </a>
            </div>
            

        </div>
    </div>   

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/01/erlang-server-design5-server-node/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">开发笔记(5) cluster_server集群优化</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2015/11/erlang-map2record/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Erlang Map映射到Record</h4>
      </a>
    </div>
  
</nav>


            
    
<div class="duoshuo">
	<div class="ds-thread" data-thread-key="erlang-datastructures" data-title="Erlang 常用数据结构实现" data-url="http://wudaijun.com/2015/12/erlang-datastructures/"></div>
</div>
<script src="/js/embed.min.js?v=1.1.4"></script>
<script src="//cdn.bootcss.com/marked/0.3.6/marked.min.js" async="async"></script>
<script>
var duoshuoQuery = {short_name:'wudaijun', theme: 'none'}
</script>




</article>


</div>
  </main>
  <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Erlang 常用数据结构实现",
    pic: "/favicon.png",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://wudaijun.com/2015/12/erlang-datastructures/"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


  <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script src="/js/main.min.js?v=1.1.4"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.1.4"></script>





<script src="//s95.cnzz.com/z_stat.php?id=1254033667&web_id=1254033667"></script>





</body>
</html>
